# End-to-end (E2E) Test Plan — Actionable Checklist

This file contains singular, implementable e2e test items grouped by functional sections. Each line is one concrete test that can be automated (scripted) and asserted in CI or locally against the `e2e/kind-setup-single.sh` environment.

Format: [ID] [Area] — Short description
- Steps: explicit step list (copy/paste into test harness)
- Expected: single explicit assertion
- Priority: High / Medium / Low

---

## Use Case Coverage (docs/use-cases.md)

The following tests in `e2e/api/use_cases_test.go` cover real-world scenarios documented in `docs/use-cases.md`:

| Use Case | Test Function | Happy Path | Bad Path |
|----------|--------------|------------|----------|
| Pod Shell Access (kubectl exec) | `TestUseCasePodShellAccess` | ✅ `HappyPath_PodExecWithApproval` | ✅ `ErrorPath_SessionWithoutReason`, `ErrorPath_UnauthorizedUser` |
| Pod Restart and Rollout | `TestUseCasePodRestart` | ✅ `HappyPath_DeploymentRestart` | ✅ `ErrorPath_SessionRejected` |
| Scaling Workloads | `TestUseCaseWorkloadScaling` | ✅ `HappyPath_EmergencyScaleUp` | ✅ `ErrorPath_ApprovalTimeout` |
| Resource Deletion | `TestUseCaseResourceDeletion` | ✅ `HappyPath_PodDeletion` | ✅ `ErrorPath_DenyPolicyBlocks` |
| Debug Tool Pods | `TestDebugSessionLifecycle` (existing) | ✅ | ✅ Validation errors |
| M2M Automated Access | `TestUseCaseM2MAutomatedAccess` | ✅ `HappyPath_AutomationSession` | ✅ `ErrorPath_LongDurationRejected` |
| Self-Service Debugging (BIS) | `TestUseCaseBISDebugging` | ✅ `HappyPath_SelfServiceDebug` | ✅ `ErrorPath_BlockSelfApproval` |
| Ingress Pod Restart | `TestUseCaseIngressRestart` | ✅ `HappyPath_IngressRestart` | - |
| Pod Security Rules | `TestUseCasePodSecurityRules` | ✅ `HappyPath_SREPrivilegedAccess` | ✅ `ErrorPath_RegularUserBlockedFromPrivileged` |
| Session Lifecycle | `TestUseCaseSessionLifecycle` | ✅ `SessionWithdrawal`, `SessionExpiration`, `MultipleSessionsPerUser`, `SessionWithScheduledStart` | ✅ Various lifecycle scenarios |

---

## Cluster & bootstrap

[C-001] Cluster: kind single-cluster creates control-plane and node
- Steps: Run `e2e/kind-setup-single.sh` up to cluster creation (stop after kind create). Verify control-plane node appears with `kubectl get nodes` and Ready status.
- Expected: One control-plane node in Ready state.
- Priority: High

[C-002] Bootstrap: API server flags mount authorization/authentication files
- Steps: After kind create, inspect the control-plane container manifest inside the node (or check `docker exec <node> cat /etc/kubernetes/manifests/kube-apiserver.yaml`) contains `--authorization-config` and `--authentication-config` paths referencing `/etc/kubernetes/authorization-config.yaml` and `/etc/kubernetes/authentication-config.yaml`.
- Expected: kube-apiserver manifest includes both flags and extraVolumes entries.
- Priority: High

## Keycloak / OIDC

[K-001] Keycloak deployment ready
- Steps: Wait for deployment label `app=keycloak` to become Ready. Use `kubectl rollout status`.
- Expected: Deployment reports successfully rolled out (1 available replica).
- Priority: High

[K-002] JWKS reachable through port-forward
- Steps: Port-forward Keycloak service and curl the JWKS URL `/realms/${KEYCLOAK_REALM}/protocol/openid-connect/certs`.
- Expected: HTTP 200 and valid JSON with `keys` array.
- Priority: High

[K-003] AuthenticationConfiguration issuer points to Keycloak
- Steps: Verify generated `$AUTHN_FILE` contains the issuer URL matching the configured `KEYCLOAK_HOST`/realm and includes the certificateAuthority block.
- Expected: `$AUTHN_FILE` contains `issuer.url` with the Keycloak host and `certificateAuthority` block.
- Priority: Medium

## Controller & webhook

[W-001] Controller deployment ready and uses local image
- Steps: After kustomize apply, set image (if needed) and verify deployment labeled `app=breakglass` is ready and that the container image matches the built `breakglass:e2e`.
- Expected: `kubectl get deploy -l app=breakglass` shows available replicas and `kubectl describe deploy` contains `Image: breakglass:e2e`.
- Priority: High

[W-002] Webhook kubeconfig points to correct in-cluster HTTP path for tenant (single-cluster only)
- Steps: Inspect `$WEBHOOK_KCFG` generated by the script; verify the `server:` entry contains `/breakglass/webhook/authorize/${TENANT_A}` (tenant-a) or configurable tenant placeholder.
- Expected: kubeconfig server URL includes `/breakglass/webhook/authorize/${TENANT_A}`.
- Priority: High

[W-003] Webhook authorizer rejects a forbidden request (deny policy)
- Steps: Create a DenyPolicy that denies `create` for `pods` for a specific subject. Use a token from a test identity and attempt to create a Pod; assert response is a denial from the webhook.
- Expected: API request receives an HTTP 429/403-like denial (webhook rejection) and event logged.
- Priority: High

## Tenants & ClusterConfig

[T-001] Create tenant secret from rewritten kubeconfig (single-cluster flow)
- Steps: Use the script's kubeconfig rewrite step to produce `MOD_KUBECONFIG`, then create a secret `tenant-a-admin` from that file and a ClusterConfig for `tenant-a`.
- Expected: Secret is created and ClusterConfig exists with `kubeconfigSecretRef` referencing the secret.
- Priority: High

[T-002] Controller reconciles tenant-scoped CRs for tenant-a and tenant-b
- Steps: For each tenant secret + ClusterConfig, create a BreakglassSession CR and wait for controller to reconcile (observe status or created subresources).
- Expected: Controller reconciles both tenant CRs independently; each CR reaches Ready or expected status.
- Priority: High

## Policy & Deny rules

[P-001] Deny access to secrets for non-admin role
- Steps: Apply a deny policy that prevents `get`/`list` on secrets for a test user. Attempt to list secrets using that user's token.
- Expected: Request is denied by webhook.
- Priority: High

[P-002] Deny creation of privileged pods
- Steps: Apply a deny policy preventing pods with hostPath or privileged= true. Try to create such a pod via API.
- Expected: Creation is blocked and error references deny policy.
- Priority: Medium

## Pod Security Evaluation (pods/exec)

[PS-001] Exec to privileged pod blocked by risk score
- Steps: Create a DenyPolicy with PodSecurityRules (privilegedContainer=100, threshold=80). Exec into a pod with `privileged: true`.
- Expected: Request denied with "Risk score too high" message.
- Priority: High
- Implemented: pkg/api/api_end_to_end_test.go:TestEndToEndSARDeniedByPodSecurityRiskScore

[PS-002] Exec to safe pod allowed when below threshold
- Steps: Create a DenyPolicy with PodSecurityRules (privilegedContainer=100, threshold=80). Exec into a pod with no risky features.
- Expected: Request allowed (score=0 < threshold=80).
- Priority: High
- Implemented: pkg/api/api_end_to_end_test.go:TestEndToEndSARAllowedForSafePod

[PS-003] Exec blocked by blockFactors (hostNetwork)
- Steps: Create a DenyPolicy with `blockFactors: ["hostNetwork"]`. Exec into a pod with `hostNetwork: true`.
- Expected: Request denied regardless of risk score.
- Priority: High
- Implemented: pkg/api/api_end_to_end_test.go:TestEndToEndSARDeniedByBlockFactor

[PS-004] Exec to exempted namespace allowed
- Steps: Create a DenyPolicy with `exemptions.namespaces: ["kube-system"]`. Exec into a privileged pod in kube-system.
- Expected: Request allowed (namespace is exempt).
- Priority: Medium
- Implemented: pkg/api/api_end_to_end_test.go:TestEndToEndSARAllowedByPodSecurityExemption

[PS-005] Exec denied when pod not found (failMode=closed)
- Steps: Create a DenyPolicy with `failMode: closed`. Exec into a pod that doesn't exist.
- Expected: Request denied (fail-closed behavior).
- Priority: Medium
- Implemented: pkg/api/api_end_to_end_test.go:TestEndToEndSARPodSecurityFailModeClosed

[PS-006] Exec allowed when pod not found (failMode=open)
- Steps: Create a DenyPolicy with `failMode: open`. Exec into a pod that doesn't exist.
- Expected: Request allowed (fail-open behavior).
- Priority: Medium
- Implemented: pkg/api/api_end_to_end_test.go:TestEndToEndSARPodSecurityFailModeOpen

[PS-007] Attach to privileged pod blocked
- Steps: Create a DenyPolicy with PodSecurityRules. Attach to a privileged pod.
- Expected: Request denied (attach triggers same evaluation as exec).
- Priority: Medium
- Implemented: pkg/api/api_end_to_end_test.go:TestEndToEndSARPodsAttachEvaluated

[PS-008] Portforward to hostPID pod blocked
- Steps: Create a DenyPolicy with `blockFactors: ["hostPID"]`. Portforward to a pod with `hostPID: true`.
- Expected: Request denied (portforward triggers security evaluation).
- Priority: Medium
- Implemented: pkg/api/api_end_to_end_test.go:TestEndToEndSARPodsPortforwardEvaluated

[PS-009] Policy applies only to specified subresources
- Steps: Create a DenyPolicy with `appliesTo.subresources: ["exec"]`. Exec should be blocked, attach should be allowed.
- Expected: Exec denied, attach allowed (scoped to exec only).
- Priority: Low
- Implemented: pkg/api/api_end_to_end_test.go:TestEndToEndSARPodSecurityScopeSubresource

[PS-010] Escalation override raises risk threshold
- Steps: Create BreakglassEscalation with `podSecurityOverrides.maxAllowedScore: 200`. Exec into privileged pod (score=100).
- Expected: Request allowed (override raises threshold from 50 to 200).
- Priority: Low
- Implemented: pkg/api/api_end_to_end_test.go:TestEndToEndSARPodSecurityWithEscalationOverride

[PS-011] Capability scoring blocks SYS_ADMIN containers
- Steps: Create DenyPolicy with `capabilities: {SYS_ADMIN: 100}` and threshold 80. Exec into pod with SYS_ADMIN capability.
- Expected: Request denied due to capability risk score.
- Priority: Medium
- Implemented: pkg/api/api_end_to_end_test.go:TestEndToEndSARPodSecurityCapabilities

[PS-012] Label-based exemption allows privileged pods with exempt label
- Steps: Create DenyPolicy with `exemptions.podLabels: {"breakglass.telekom.com/security-exempt": "true"}`. Exec into labeled privileged pod.
- Expected: Request allowed (label exemption).
- Priority: Medium
- Implemented: pkg/api/api_end_to_end_test.go:TestEndToEndSARPodSecurityLabelExemption

[PS-013] Cumulative risk score from multiple factors
- Steps: Create DenyPolicy with multiple risk factors (hostNetwork=30, hostPID=30, runAsRoot=30, threshold=60). Test pods with 1, 2, 3 factors.
- Expected: 1 factor allowed, 2 factors warned, 3 factors denied.
- Priority: Medium
- Implemented: pkg/api/api_end_to_end_test.go:TestEndToEndSARPodSecurityCumulativeScore

## Resource Operations (SAR)

[RO-001] List pods in namespace allowed with approved session
- Steps: Create and approve session. Invoke SAR for `list pods` in default namespace.
- Expected: Request allowed.
- Priority: High
- Implemented: pkg/api/api_end_to_end_test.go:TestEndToEndSARResourceOperations

[RO-002] Get deployment allowed with approved session
- Steps: Create and approve session. Invoke SAR for `get deployments` in apps group.
- Expected: Request allowed.
- Priority: High
- Implemented: pkg/api/api_end_to_end_test.go:TestEndToEndSARResourceOperations

[RO-003] Delete pod allowed with approved session
- Steps: Create and approve session. Invoke SAR for `delete pods`.
- Expected: Request allowed.
- Priority: High
- Implemented: pkg/api/api_end_to_end_test.go:TestEndToEndSARResourceOperations

[RO-004] List secrets blocked by deny policy
- Steps: Create deny policy blocking `get`/`list` on secrets. Invoke SAR for `list secrets`.
- Expected: Request denied by policy.
- Priority: High
- Implemented: pkg/api/api_end_to_end_test.go:TestEndToEndSARResourceOperations

[RO-005] Delete namespace blocked by deny policy
- Steps: Create deny policy blocking `delete` on namespaces. Invoke SAR for `delete namespace`.
- Expected: Request denied by policy.
- Priority: High
- Implemented: pkg/api/api_end_to_end_test.go:TestEndToEndSARResourceOperations

## Subresource Operations

[SR-001] Get deployment status allowed
- Steps: Create and approve session. Invoke SAR for `get deployments/status`.
- Expected: Request allowed.
- Priority: Medium
- Implemented: pkg/api/api_end_to_end_test.go:TestEndToEndSARSubresources

[SR-002] Get pod logs allowed
- Steps: Create and approve session. Invoke SAR for `get pods/log`.
- Expected: Request allowed.
- Priority: Medium
- Implemented: pkg/api/api_end_to_end_test.go:TestEndToEndSARSubresources

[SR-003] Pod exec blocked by rule-based deny policy
- Steps: Create deny policy with rule blocking `create pods/exec`. Invoke SAR for pods/exec.
- Expected: Request denied by rule (not pod security).
- Priority: Medium
- Implemented: pkg/api/api_end_to_end_test.go:TestEndToEndSARSubresources

[SR-004] Scale deployment allowed
- Steps: Create and approve session. Invoke SAR for `update deployments/scale`.
- Expected: Request allowed.
- Priority: Low
- Implemented: pkg/api/api_end_to_end_test.go:TestEndToEndSARSubresources

## Wildcard and Pattern Matching

[WP-001] Wildcard deny policy blocks all operations in namespace
- Steps: Create deny policy with `verbs: ["*"], resources: ["*"], namespaces: ["kube-system"]`. Test access to kube-system vs default.
- Expected: kube-system denied, default allowed.
- Priority: Medium
- Implemented: pkg/api/api_end_to_end_test.go:TestEndToEndSARWildcardDenyPolicy

[WP-002] ResourceNames pattern blocks specific secrets
- Steps: Create deny policy with `resourceNames: ["database-password", "api-key"]`. Test access to blocked vs non-blocked secrets.
- Expected: Blocked secrets denied, other secrets allowed.
- Priority: Medium
- Implemented: pkg/api/api_end_to_end_test.go:TestEndToEndSARResourceNamePatterns

## Policy Precedence

[PP-001] Multiple policies evaluated by precedence
- Steps: Create two deny policies with different precedence (10 and 100) blocking different verbs. Test both verbs.
- Expected: Both policies enforce, lower precedence evaluated first.
- Priority: Medium
- Implemented: pkg/api/api_end_to_end_test.go:TestEndToEndSARMultiplePoliciesPrecedence

## Custom Resources

[CR-001] List breakglass sessions allowed
- Steps: Create and approve session. Invoke SAR for `list breakglasssessions` in breakglass.t-caas.telekom.com group.
- Expected: Request allowed.
- Priority: Low
- Implemented: pkg/api/api_end_to_end_test.go:TestEndToEndSARCRDOperations

[CR-002] Get deny policy allowed
- Steps: Create and approve session. Invoke SAR for `get denypolicies`.
- Expected: Request allowed.
- Priority: Low
- Implemented: pkg/api/api_end_to_end_test.go:TestEndToEndSARCRDOperations

## Notifications & MailHog

[M-001] Controller sends escalation email and MailHog receives it
- Steps: Trigger an escalation that generates a notification; query MailHog API to confirm the email arrived and check subject/body contains the escalation id.
- Expected: MailHog API returns one message with expected subject and content.
- Priority: Medium

## Resilience & negative cases

[R-001] Webhook unreachable -> NoOpinion fallback permits operations during bootstrap
- Steps: Temporarily replace the webhook kubeconfig with an invalid one, attempt an operation that would normally be denied, then restore webhook and verify enforcement resumes.
- Expected: Operation allowed while webhook unreachable; enforcement resumes when webhook returns.
- Priority: Low

[R-002] Controller unhealthy rollout detection
- Steps: Set controller image to a broken variant or crashLoop, check that readiness probes fail and alerts/logs indicate deployment problems.
- Expected: Deployment shows unavailable replicas and test harness can detect failure state.
- Priority: Low

---

## Debug Sessions

[D-001] DebugPodTemplate creation and validation
- Steps: Apply a DebugPodTemplate CR with a valid pod spec. Verify the resource is created successfully.
- Expected: `kubectl get debugpodtemplates` shows the template with correct displayName.
- Priority: High

[D-002] DebugSessionTemplate creation with pod template reference
- Steps: Apply a DebugSessionTemplate CR that references an existing DebugPodTemplate. Verify the resource is created successfully.
- Expected: `kubectl get debugsessiontemplates` shows the template with mode=workload.
- Priority: High

[D-003] DebugSession creation via API
- Steps: Create a DebugSession CR via the REST API POST endpoint. Verify the session is created and enters Pending state.
- Expected: DebugSession CR exists with status.state=Pending or PendingApproval.
- Priority: High

[D-004] DebugSession auto-approval for allowed clusters
- Steps: Create a DebugSessionTemplate with autoApproveFor.clusters matching the test cluster. Create a DebugSession. Verify auto-approval.
- Expected: DebugSession transitions to Active state without manual approval.
- Priority: High

[D-005] DebugSession manual approval workflow
- Steps: Create a DebugSessionTemplate without autoApproveFor. Create a DebugSession. Approve via API.
- Expected: DebugSession transitions from PendingApproval to Active after approval.
- Priority: High

[D-006] DebugSession rejection workflow
- Steps: Create a DebugSession requiring approval. Reject via API with reason.
- Expected: DebugSession transitions to Failed state with rejection reason in status.
- Priority: Medium

[D-007] DebugSession workload deployment
- Steps: Create an Active DebugSession with mode=workload. Verify DaemonSet/Deployment is created on target cluster.
- Expected: status.deployedResources lists the created workload. Pods are running in target namespace.
- Priority: High

[D-008] DebugSession participant join
- Steps: Create an Active DebugSession. Use API to join as another user.
- Expected: status.participants includes both owner and joined participant.
- Priority: Medium

[D-009] DebugSession renewal
- Steps: Create an Active DebugSession. Use API to renew the session.
- Expected: status.expiresAt is extended. status.renewalCount is incremented.
- Priority: Medium

[D-010] DebugSession termination
- Steps: Create an Active DebugSession. Use API to terminate.
- Expected: DebugSession transitions to Terminated state. Deployed resources are cleaned up.
- Priority: High

[D-011] DebugSession expiration
- Steps: Create a DebugSession with very short duration (e.g., 1m). Wait for expiration.
- Expected: DebugSession transitions to Expired state. Deployed resources are cleaned up.
- Priority: Medium

[D-012] DebugSession kubectl-debug mode (ephemeral containers)
- Steps: Create a DebugSessionTemplate with mode=kubectl-debug and ephemeralContainers.enabled=true. Create a DebugSession. Verify webhook allows ephemeral container injection.
- Expected: Session is active and kubectl debug commands are permitted.
- Priority: Medium

[D-013] DebugSession constraints enforcement
- Steps: Create a DebugSessionTemplate with maxDuration=1h. Try to create a DebugSession requesting 4h.
- Expected: Session is created with duration capped at maxDuration (1h).
- Priority: Medium

[D-014] DebugSession access control - allowed groups
- Steps: Create a DebugSessionTemplate with allowed.groups=[sre-team]. Try to create session as user not in sre-team.
- Expected: Session creation is rejected with authorization error.
- Priority: High

[D-015] DebugSession cleanup after termination
- Steps: Create and terminate a DebugSession. Verify all deployed resources are removed.
- Expected: No orphaned DaemonSets/Deployments in target namespace from the session.
- Priority: High

## OIDC Authentication (ClusterConfig with authType=OIDC)

[O-001] ClusterConfig with OIDC auth validates secrets
- Steps: Create a ClusterConfig with authType=OIDC pointing to a client secret and CA secret. Wait for the controller to validate. Check status conditions.
- Expected: ClusterConfig status shows Ready=True with reason OIDCValidated when secrets are present and valid.
- Priority: High

[O-002] ClusterConfig with OIDC auth fails on missing client secret
- Steps: Create a ClusterConfig with authType=OIDC but with clientSecretRef pointing to a non-existent secret.
- Expected: ClusterConfig status shows Ready=False with reason SecretMissing and message mentioning "OIDC client secret".
- Priority: High

[O-003] OIDC token acquisition from Keycloak
- Steps: Create ClusterConfig pointing to the e2e Keycloak instance. Configure a Keycloak client with client_credentials grant. Verify controller can obtain a token.
- Expected: ClusterConfig reaches Ready=True, logs show successful token acquisition from Keycloak.
- Priority: High

[O-004] OIDC token refresh on expiry
- Steps: Configure ClusterConfig with OIDC auth. Wait for initial token. Wait for token to near expiry (or force by manipulating cache). Verify refresh token is used.
- Expected: Logs show "refreshing OIDC token" and new token is obtained without re-authenticating.
- Priority: Medium

[O-005] TOFU (Trust On First Use) populates CA secret
- Steps: Create ClusterConfig with authType=OIDC but without clusterCASecretRef. Enable TOFU. Connect to an API server.
- Expected: Controller automatically creates a secret with the API server's CA certificate. ClusterConfig status shows Ready=True.
- Priority: Medium

[O-006] OIDC discovery failure condition
- Steps: Create ClusterConfig with authType=OIDC pointing to an invalid/unreachable issuer URL.
- Expected: ClusterConfig status shows Ready=False with reason OIDCDiscoveryFailed and helpful error message.
- Priority: High

[O-007] OIDC token exchange flow (if enabled)
- Steps: Configure ClusterConfig with tokenExchange.enabled=true. Verify the controller performs RFC 8693 token exchange.
- Expected: Controller exchanges initial token for a cluster-scoped token. Logs show token exchange flow.
- Priority: Low

[O-008] Mixed auth types in same namespace
- Steps: Create two ClusterConfigs in the same namespace: one with authType=Kubeconfig, one with authType=OIDC. Both pointing to different clusters.
- Expected: Both ClusterConfigs are validated independently and reach Ready state with appropriate reasons.
- Priority: Medium

---

How to use

- Each item is intentionally singular and executable by a script. Implement tests in the language of your choice (bash, Go, Python). Each test should:
	1. Prepare preconditions (namespace, secrets, k8s objects).
	2. Execute the step list (kubectl/kustomize/curl or client libs).
	3. Assert the single `Expected` line within a short timeout.

Next steps I can implement for you

- Convert these items into a `tests/e2e/` directory with small bash or Go tests for the top priority items.
- Add a `make e2e-smoke` to run a subset (C-001, K-001, W-001, T-001) in CI.

Generated on: 2025-10-23
Updated on: 2025-01-03 (Comprehensive kitchen-sink coverage)

---

## Multi-User & Multi-Group Authorization

[MU-001] Multiple users from same group can request sessions
- Steps: Create escalation with `allowed.groups: ["dev-team"]`. Have 3 users from dev-team create separate sessions.
- Expected: All 3 sessions created successfully with unique names.
- Priority: High

[MU-002] User in multiple groups can request for any matching escalation
- Steps: Create user in groups ["dev", "ops", "sre"]. Create 3 escalations each allowing one group. User requests each.
- Expected: All 3 requests succeed because user has membership in each.
- Priority: High

[MU-003] User NOT in allowed group cannot request session
- Steps: Create escalation with `allowed.groups: ["admin-only"]`. User in ["dev"] group attempts request.
- Expected: Request rejected with authorization error.
- Priority: High

[MU-004] Group-based approver can approve session
- Steps: Create escalation with `approvers.groups: ["senior-ops"]`. User in senior-ops group approves pending session.
- Expected: Session approved successfully.
- Priority: High

[MU-005] Multiple approvers from same group - first wins
- Steps: Create escalation with `approvers.groups: ["approvers"]`. Two users from group both attempt to approve.
- Expected: First approval succeeds, second gets "already approved" error.
- Priority: Medium

[MU-006] User in both requester and approver group - blockSelfApproval enforced
- Steps: Create escalation with user's group in both allowed.groups and approvers.groups. Set `blockSelfApproval: true`. User requests then tries to approve own session.
- Expected: Self-approval rejected.
- Priority: High

[MU-007] User in both requester and approver group - blockSelfApproval disabled
- Steps: Same as MU-006 but `blockSelfApproval: false`.
- Expected: Self-approval succeeds.
- Priority: Medium

[MU-008] Cross-group escalation chain
- Steps: Create escalation where dev group can request, ops group approves. Verify dev cannot approve, ops cannot request.
- Expected: Each group can only perform their allowed action.
- Priority: High

[MU-009] User added to group mid-session
- Steps: Create session. Add user to approver group. User attempts to approve.
- Expected: Approval succeeds (groups evaluated at action time, not session creation).
- Priority: Medium

[MU-010] User removed from group mid-session
- Steps: Create active session. Remove user from escalation's allowed group. Session should still be active.
- Expected: Existing session remains active (no revocation on group removal).
- Priority: Medium

---

## Complete Session State Machine

[SS-001] Pending → Approved → Active → Expired (happy path)
- Steps: Create session, approve, wait for activation, wait for expiry.
- Expected: Session transitions through all states correctly with timestamps.
- Priority: High

[SS-002] Pending → Rejected (rejection path)
- Steps: Create session, reject with reason.
- Expected: Session in Rejected state with rejection reason and rejector identity.
- Priority: High

[SS-003] Pending → Withdrawn (requester cancels before approval)
- Steps: Create session, requester withdraws before any approver action.
- Expected: Session in Withdrawn state with withdrawal timestamp.
- Priority: High

[SS-004] Pending → ApprovalTimeout (timeout path)
- Steps: Create escalation with `approvalTimeout: 1m`. Create session, wait 70s.
- Expected: Session transitions to ApprovalTimeout state automatically.
- Priority: High

[SS-005] Active → Cancelled (admin cancels active session)
- Steps: Create and approve session. Admin cancels active session.
- Expected: Session in Cancelled state, permissions revoked immediately.
- Priority: High

[SS-006] Active → Dropped (approver revokes)
- Steps: Create and approve session. Approver drops the session.
- Expected: Session in Dropped state, original requester notified.
- Priority: High

[SS-007] Pending → WaitingForScheduledTime → Active
- Steps: Create session with `scheduledStartTime` 2 minutes in future. Approve immediately.
- Expected: Session waits until scheduled time, then becomes Active.
- Priority: High

[SS-008] WaitingForScheduledTime → Cancelled
- Steps: Create scheduled session, approve, then cancel before scheduled time.
- Expected: Session cancelled without ever becoming Active.
- Priority: Medium

[SS-009] Active with IdleTimeout detection
- Steps: Create session with `idleTimeout: 2m`. Let session sit idle.
- Expected: Session expires with idle timeout reason after 2m of no activity.
- Priority: High

[SS-010] Session extension before expiry
- Steps: Create active session. Before expiry, request extension.
- Expected: Session `validUntil` extended, extension count incremented.
- Priority: Medium

[SS-011] Session extension denied after max extensions
- Steps: Create session with `maxExtensions: 2`. Extend twice successfully, third fails.
- Expected: Third extension rejected with "max extensions reached" error.
- Priority: Medium

[SS-012] Multiple pending sessions for same escalation
- Steps: Create 3 pending sessions for same escalation by same user.
- Expected: All 3 created (or limited by `maxPendingPerUser` if configured).
- Priority: Medium

[SS-013] Session with notes/justification required
- Steps: Create escalation with `requireJustification: true`. Create session without reason.
- Expected: Session creation rejected for missing justification.
- Priority: High

[SS-014] Session with approval notes required
- Steps: Create escalation with `requireApprovalNotes: true`. Approve without notes.
- Expected: Approval rejected for missing notes.
- Priority: Medium

---

## Approval Workflows

[AW-001] Single approver workflow
- Steps: Create escalation with single user in `approvers.users`. That user approves.
- Expected: Session approved by listed user.
- Priority: High

[AW-002] Any approver from list can approve
- Steps: Create escalation with 5 users in `approvers.users`. Third user approves.
- Expected: Session approved, approver field shows third user.
- Priority: High

[AW-003] Approver not in list cannot approve
- Steps: Create escalation with specific approvers. Random user attempts approval.
- Expected: Approval rejected with 401 Unauthorized.
- Priority: High

[AW-004] AllowedApproverDomains restriction
- Steps: Create escalation with `allowedApproverDomains: ["telekom.de"]`. User with @example.com email tries to approve.
- Expected: Approval rejected due to domain restriction.
- Priority: High

[AW-005] AllowedApproverDomains allows valid domain
- Steps: Same escalation as AW-004. User with @telekom.de email approves.
- Expected: Approval succeeds.
- Priority: High

[AW-006] Rejection with mandatory reason
- Steps: Create escalation with `requireRejectionReason: true`. Reject without reason.
- Expected: Rejection fails for missing reason.
- Priority: Medium

[AW-007] Rejection workflow with reason
- Steps: Create session, reject with detailed reason.
- Expected: Session rejected, reason stored in status, requester notified.
- Priority: High

[AW-008] Approver comment stored on approval
- Steps: Approve session with comment "Approved for production debugging".
- Expected: Comment stored in session status.
- Priority: Medium

[AW-009] Auto-approval for specific clusters
- Steps: Create escalation with `autoApproveFor.clusters: ["dev-cluster"]`. Request for dev-cluster.
- Expected: Session auto-approved without manual intervention.
- Priority: High

[AW-010] Auto-approval does not apply to other clusters
- Steps: Same escalation as AW-009. Request for prod-cluster.
- Expected: Session requires manual approval.
- Priority: High

---

## Identity Provider Tests

[IDP-001] Single IdentityProvider authentication
- Steps: Create one IdentityProvider CR. Authenticate via that IDP.
- Expected: Token validated, user identity extracted correctly.
- Priority: High

[IDP-002] Multiple IdentityProviders - correct one selected by issuer
- Steps: Create 2 IdentityProviders with different issuers. Authenticate with each.
- Expected: Correct IDP used based on token issuer claim.
- Priority: High

[IDP-003] IdentityProvider with custom email claim
- Steps: Create IDP with `emailClaim: "preferred_email"`. Token has that claim.
- Expected: Email extracted from custom claim.
- Priority: Medium

[IDP-004] IdentityProvider with group claim mapping
- Steps: Create IDP with `groupsClaim: "realm_access.roles"`. Verify groups extracted.
- Expected: Groups correctly mapped from nested claim.
- Priority: Medium

[IDP-005] IdentityProvider group sync to status
- Steps: Create IDP with `syncGroups: true`. Controller populates status.syncedGroups.
- Expected: Status shows synced group memberships.
- Priority: Medium

[IDP-006] AllowedIdentityProvidersForRequests restriction
- Steps: Create escalation with `allowedIdentityProvidersForRequests: ["corp-idp"]`. User from different IDP requests.
- Expected: Request rejected due to IDP restriction.
- Priority: High

[IDP-007] AllowedIdentityProvidersForApprovers restriction
- Steps: Create escalation with `allowedIdentityProvidersForApprovers: ["admin-idp"]`. Approver from different IDP tries to approve.
- Expected: Approval rejected due to IDP restriction.
- Priority: High

[IDP-008] IdentityProvider JWKS refresh
- Steps: Rotate JWKS keys in IDP. Wait for refresh interval. Authenticate with new key.
- Expected: New keys picked up, authentication succeeds.
- Priority: Medium

[IDP-009] IdentityProvider status shows health
- Steps: Create IDP pointing to valid issuer.
- Expected: Status shows Ready condition, lastSuccessfulSync timestamp.
- Priority: Medium

[IDP-010] IdentityProvider invalid issuer URL
- Steps: Create IDP with unreachable issuer URL.
- Expected: Status shows Error condition with reason.
- Priority: Medium

---

## Mail Provider Tests

[MP-001] MailProvider sends session request notification
- Steps: Create session. Check MailHog for notification email.
- Expected: Email received with session details and approval link.
- Priority: High

[MP-002] MailProvider sends approval notification
- Steps: Approve session. Check MailHog for approval confirmation.
- Expected: Email to requester confirming approval.
- Priority: High

[MP-003] MailProvider sends rejection notification
- Steps: Reject session. Check MailHog for rejection email.
- Expected: Email to requester with rejection reason.
- Priority: High

[MP-004] MailProvider sends expiry warning
- Steps: Create session about to expire. Check for warning email.
- Expected: Warning email sent before expiry.
- Priority: Medium

[MP-005] MailProvider with custom templates
- Steps: Create MailProvider with custom template configmap. Trigger notification.
- Expected: Email uses custom template content.
- Priority: Medium

[MP-006] MailProvider SMTP authentication
- Steps: Create MailProvider with SMTP auth credentials.
- Expected: Emails sent successfully with authentication.
- Priority: Medium

[MP-007] MailProvider TLS configuration
- Steps: Create MailProvider with `tls.enabled: true` and CA cert.
- Expected: SMTP connection uses TLS.
- Priority: Medium

[MP-008] MailProvider retry on temporary failure
- Steps: Temporarily block SMTP. Trigger notification. Restore SMTP.
- Expected: Email delivered after retry.
- Priority: Low

[MP-009] MailProvider status shows health
- Steps: Create MailProvider with valid SMTP config.
- Expected: Status shows Ready, successful connection test timestamp.
- Priority: Medium

[MP-010] NotificationExclusions skip specific users
- Steps: Create escalation with `notificationExclusions.users: ["bot@example.com"]`. Bot creates session.
- Expected: No notification email sent.
- Priority: Low

---

## Audit Logging - All Sinks

[AU-001] AuditConfig Log sink writes to stdout
- Steps: Create AuditConfig with log sink. Perform session actions.
- Expected: Audit events appear in controller logs.
- Priority: High

[AU-002] AuditConfig Kafka sink writes to topic
- Steps: Create AuditConfig with Kafka sink. Perform actions. Consume from Kafka topic.
- Expected: Audit events in Kafka with correct schema.
- Priority: High

[AU-003] AuditConfig Webhook sink POSTs to endpoint
- Steps: Create AuditConfig with webhook sink pointing to test endpoint. Perform actions.
- Expected: Webhook receives POST with audit event payload.
- Priority: High

[AU-004] AuditConfig Kubernetes Events sink
- Steps: Create AuditConfig with k8s event sink. Perform session approval.
- Expected: Kubernetes Event created in session's namespace.
- Priority: Medium

[AU-005] AuditConfig multi-sink configuration
- Steps: Create AuditConfig with log + Kafka + webhook sinks.
- Expected: Events written to all 3 sinks.
- Priority: High

[AU-006] AuditConfig event filtering by type
- Steps: Create AuditConfig with `filter.eventTypes: ["session.approved", "session.rejected"]`.
- Expected: Only filtered event types written to sink.
- Priority: Medium

[AU-007] AuditConfig event filtering by severity
- Steps: Create AuditConfig with `filter.minSeverity: "warning"`.
- Expected: Info-level events excluded, warning+ included.
- Priority: Medium

[AU-008] AuditConfig Kafka SASL authentication
- Steps: Create AuditConfig with Kafka SASL credentials.
- Expected: Events written to authenticated Kafka cluster.
- Priority: Medium

[AU-009] AuditConfig Kafka TLS configuration
- Steps: Create AuditConfig with Kafka TLS settings.
- Expected: TLS connection to Kafka brokers.
- Priority: Medium

[AU-010] Audit event for session.requested
- Steps: Create session. Check audit sink.
- Expected: Event with type="session.requested", actor=requester email.
- Priority: High

[AU-011] Audit event for session.approved
- Steps: Approve session. Check audit sink.
- Expected: Event with type="session.approved", actor=approver email, target=session.
- Priority: High

[AU-012] Audit event for session.rejected
- Steps: Reject session. Check audit sink.
- Expected: Event with type="session.rejected", includes rejection reason.
- Priority: High

[AU-013] Audit event for session.expired
- Steps: Let session expire. Check audit sink.
- Expected: Event with type="session.expired".
- Priority: Medium

[AU-014] Audit event for authorization.granted
- Steps: Send SAR request that's allowed. Check audit sink.
- Expected: Event with resource details, user, decision=allowed.
- Priority: High

[AU-015] Audit event for authorization.denied
- Steps: Send SAR request that's denied. Check audit sink.
- Expected: Event with resource details, user, decision=denied, reason.
- Priority: High

[AU-016] Audit event for policy.violation
- Steps: Trigger DenyPolicy violation. Check audit sink.
- Expected: Event with policy name, violating request details.
- Priority: Medium

[AU-017] Audit queue overflow handling
- Steps: Generate many events rapidly with small queue size.
- Expected: Metrics show dropped events, sink doesn't block.
- Priority: Low

---

## DenyPolicy Comprehensive Tests

[DP-001] DenyPolicy blocks specific verbs
- Steps: Create policy denying "delete" on pods. Attempt delete vs get.
- Expected: Delete blocked, get allowed.
- Priority: High

[DP-002] DenyPolicy blocks specific resources
- Steps: Create policy denying all verbs on secrets. Attempt secret vs configmap access.
- Expected: Secrets blocked, configmaps allowed.
- Priority: High

[DP-003] DenyPolicy blocks specific namespaces
- Steps: Create policy denying access to "production" namespace.
- Expected: Production access blocked, other namespaces allowed.
- Priority: High

[DP-004] DenyPolicy blocks specific API groups
- Steps: Create policy denying "apps" group. Attempt deployment vs pod access.
- Expected: Deployments blocked, pods allowed.
- Priority: High

[DP-005] DenyPolicy blocks specific resource names
- Steps: Create policy denying access to secret "database-password".
- Expected: That specific secret blocked, others allowed.
- Priority: Medium

[DP-006] DenyPolicy with label selector
- Steps: Create policy with `selector.matchLabels: {env: prod}`. Apply to prod-labeled resources.
- Expected: Only resources with label blocked.
- Priority: Medium

[DP-007] DenyPolicy precedence ordering
- Steps: Create 2 overlapping policies with different precedence.
- Expected: Lower precedence policy evaluated first.
- Priority: Medium

[DP-008] DenyPolicy exemption by namespace
- Steps: Create policy with `exemptions.namespaces: ["kube-system"]`.
- Expected: kube-system exempt from policy.
- Priority: Medium

[DP-009] DenyPolicy exemption by user
- Steps: Create policy with `exemptions.users: ["admin@example.com"]`.
- Expected: Admin user exempt from policy.
- Priority: Medium

[DP-010] DenyPolicy exemption by group
- Steps: Create policy with `exemptions.groups: ["cluster-admins"]`.
- Expected: Cluster-admins group exempt from policy.
- Priority: Medium

[DP-011] DenyPolicy appliesTo clusters filter
- Steps: Create policy with `appliesTo.clusters: ["prod-cluster"]`. Test on dev-cluster.
- Expected: Policy only enforced on prod-cluster.
- Priority: Medium

[DP-012] DenyPolicy appliesTo escalations filter
- Steps: Create policy with `appliesTo.escalations: ["emergency-access"]`. Test with different escalation.
- Expected: Policy only enforced for specified escalation.
- Priority: Medium

---

## ClusterConfig & Multi-Cluster

[CC-001] ClusterConfig with kubeconfig secret
- Steps: Create ClusterConfig referencing kubeconfig secret.
- Expected: Controller can connect to target cluster.
- Priority: High

[CC-002] ClusterConfig status shows connectivity
- Steps: Create valid ClusterConfig. Check status.
- Expected: Status shows Ready, lastSuccessfulCheck timestamp.
- Priority: High

[CC-003] ClusterConfig with invalid kubeconfig
- Steps: Create ClusterConfig with bad kubeconfig data.
- Expected: Status shows Error with connection failure reason.
- Priority: Medium

[CC-004] ClusterConfig QPS/Burst settings
- Steps: Create ClusterConfig with custom `qps: 100, burst: 200`.
- Expected: Client uses those rate limit settings.
- Priority: Low

[CC-005] ClusterConfig blockSelfApproval setting
- Steps: Create ClusterConfig with `blockSelfApproval: true`. Override at escalation level with false.
- Expected: Escalation-level setting takes precedence.
- Priority: Medium

[CC-006] ClusterConfig allowedApproverDomains setting
- Steps: Create ClusterConfig with domain restriction. Test approvals.
- Expected: Cluster-level restriction enforced.
- Priority: Medium

[CC-007] Hub cluster can manage spoke cluster sessions
- Steps: Create session for spoke cluster from hub. Approve on hub. Verify spoke access.
- Expected: Session grants access on spoke cluster.
- Priority: High

[CC-008] Spoke cluster webhook calls back to hub
- Steps: Configure spoke authorization webhook to call hub. SAR on spoke.
- Expected: Hub validates session, spoke enforces decision.
- Priority: High

[CC-009] ClusterConfig secret rotation
- Steps: Update kubeconfig secret with new credentials. Wait for controller reconcile.
- Expected: Controller uses new credentials without restart.
- Priority: Medium

[CC-010] Multiple ClusterConfigs for different clusters
- Steps: Create 3 ClusterConfigs. Create sessions for each cluster.
- Expected: Each session targets correct cluster.
- Priority: High

---

## Webhook & Authorization

[WH-001] Webhook returns Allow for approved session
- Steps: Create and approve session. Send SAR matching session.
- Expected: Webhook returns allowed=true.
- Priority: High

[WH-002] Webhook returns Deny for no session
- Steps: Send SAR for user with no active session.
- Expected: Webhook returns allowed=false or NoOpinion.
- Priority: High

[WH-003] Webhook returns Deny for expired session
- Steps: Create session, let expire. Send SAR.
- Expected: Webhook returns denied (session not active).
- Priority: High

[WH-004] Webhook handles high concurrency
- Steps: Send 100 concurrent SAR requests.
- Expected: All requests processed within timeout, no errors.
- Priority: Medium

[WH-005] Webhook timeout handling
- Steps: Configure webhook with short timeout. Simulate slow response.
- Expected: Timeout handled gracefully, failure policy applied.
- Priority: Low

[WH-006] Webhook TLS certificate validation
- Steps: Send request to webhook with valid TLS.
- Expected: TLS handshake succeeds.
- Priority: High

[WH-007] Webhook metrics exposed
- Steps: Query /metrics endpoint after webhook requests.
- Expected: Metrics show request counts, latencies, decisions.
- Priority: Medium

[WH-008] Webhook matchConditions CEL filter
- Steps: Configure webhook with CEL matchConditions.
- Expected: Only matching requests reach webhook.
- Priority: Low

[WH-009] Webhook failure policy Fail
- Steps: Configure webhook with failurePolicy=Fail. Make webhook unavailable.
- Expected: Requests denied when webhook unreachable.
- Priority: Medium

[WH-010] Webhook failure policy Ignore
- Steps: Configure webhook with failurePolicy=Ignore. Make webhook unavailable.
- Expected: Requests allowed to pass when webhook unreachable.
- Priority: Medium

---

## BreakglassEscalation Features

[BE-001] Escalation with multiple permission sets
- Steps: Create escalation granting pods read + deployments full access.
- Expected: Approved session has both permission sets.
- Priority: High

[BE-002] Escalation with namespace restrictions
- Steps: Create escalation allowing access only to "app" namespace.
- Expected: Access to other namespaces denied.
- Priority: High

[BE-003] Escalation with resourceNames restrictions
- Steps: Create escalation allowing specific pod names only.
- Expected: Only named pods accessible.
- Priority: Medium

[BE-004] Escalation maxValidFor enforced
- Steps: Create escalation with `maxValidFor: 2h`. Request 4h session.
- Expected: Session capped at 2h.
- Priority: High

[BE-005] Escalation minValidFor enforced
- Steps: Create escalation with `minValidFor: 30m`. Request 10m session.
- Expected: Session minimum enforced at 30m.
- Priority: Medium

[BE-006] Escalation with multiple allowed clusters
- Steps: Create escalation with `allowed.clusters: [dev, staging, prod]`.
- Expected: Sessions can target any of the 3 clusters.
- Priority: High

[BE-007] Escalation cluster not in allowed list
- Steps: Create escalation for specific clusters. Request for unlisted cluster.
- Expected: Request rejected.
- Priority: High

[BE-008] Escalation with hidden approvers
- Steps: Create escalation with `approvers.hiddenFromUI: true`.
- Expected: API doesn't expose approver list to non-admin users.
- Priority: Low

[BE-009] Escalation with podSecurityOverrides
- Steps: Create escalation with higher `maxAllowedScore`. Access privileged pod.
- Expected: Access allowed due to override.
- Priority: Medium

[BE-010] Escalation status shows usage stats
- Steps: Create sessions using escalation. Check escalation status.
- Expected: Status shows session count, last used timestamp.
- Priority: Low

---

## Debug Session Advanced Features

[DS-001] DebugSession with tmux terminal sharing
- Steps: Create debug session with `terminalSharing.enabled: true`. Second user joins.
- Expected: Both users share same terminal session.
- Priority: Medium

[DS-002] DebugSession with command logging
- Steps: Create session with `logCommands: true`. Execute commands.
- Expected: Commands logged to audit sink.
- Priority: Medium

[DS-003] DebugSession renewal workflow
- Steps: Create session with `allowRenewal: true, maxRenewals: 3`. Renew 3 times, fail on 4th.
- Expected: First 3 renewals succeed, 4th rejected.
- Priority: Medium

[DS-004] DebugSession participant roles
- Steps: Create session. Add participant as "viewer" role.
- Expected: Viewer can see but not execute commands.
- Priority: Medium

[DS-005] DebugSession invited participants
- Steps: Create session with `invitedParticipants`. Invited user joins.
- Expected: Pre-invited user can join without additional approval.
- Priority: Low

[DS-006] DebugSession pod node selector
- Steps: Create DebugPodTemplate with nodeSelector. Deploy debug session.
- Expected: Debug pod scheduled on matching nodes.
- Priority: Low

[DS-007] DebugSession resource limits
- Steps: Create template with CPU/memory limits. Deploy session.
- Expected: Debug pod has specified resource limits.
- Priority: Medium

[DS-008] DebugSession with custom image
- Steps: Create template with custom debug image.
- Expected: Debug pod uses specified image.
- Priority: Medium

[DS-009] DebugSession network policy
- Steps: Create template with network access restrictions.
- Expected: Debug pod has limited network access.
- Priority: Low

[DS-010] DebugSession ephemeral container mode
- Steps: Create session in kubectl-debug mode. Inject ephemeral container.
- Expected: Ephemeral container created in target pod.
- Priority: Medium

---

## Metrics & Observability

[MO-001] Session count metrics
- Steps: Create multiple sessions. Query Prometheus metrics.
- Expected: `breakglass_sessions_total` shows correct counts by state.
- Priority: High

[MO-002] Authorization decision metrics
- Steps: Make allow and deny decisions. Query metrics.
- Expected: `breakglass_authorization_decisions_total` with decision labels.
- Priority: High

[MO-003] Webhook latency histogram
- Steps: Make webhook requests. Query histogram.
- Expected: `breakglass_webhook_request_duration_seconds` populated.
- Priority: Medium

[MO-004] Cluster cache hit/miss metrics
- Steps: Access cluster configs. Query cache metrics.
- Expected: Cache hits/misses tracked.
- Priority: Medium

[MO-005] JWT validation metrics
- Steps: Authenticate with valid/invalid tokens. Query metrics.
- Expected: Success/failure counts by issuer.
- Priority: Medium

[MO-006] Pod security evaluation metrics
- Steps: Trigger pod security evaluations. Query metrics.
- Expected: Risk scores, factor counts, decisions tracked.
- Priority: Medium

[MO-007] Audit sink metrics
- Steps: Generate audit events. Query sink metrics.
- Expected: Events processed, errors by sink.
- Priority: Medium

[MO-008] Controller health endpoints
- Steps: Query /healthz and /readyz endpoints.
- Expected: Endpoints return healthy status.
- Priority: High

[MO-009] Metrics scrape by Prometheus
- Steps: Configure Prometheus to scrape /metrics.
- Expected: All metrics scraped successfully.
- Priority: Medium

[MO-010] Custom resource metrics
- Steps: Check controller emits CR-related metrics.
- Expected: Counts for each CRD type.
- Priority: Low

---

## Resilience & Error Handling

[RE-001] Controller restart preserves active sessions
- Steps: Create active sessions. Restart controller. Verify sessions still active.
- Expected: Sessions survive controller restart.
- Priority: High

[RE-002] Controller handles Kubernetes API unavailability
- Steps: Temporarily block API access. Controller continues gracefully.
- Expected: Controller recovers when API returns.
- Priority: Medium

[RE-003] Webhook handles malformed SAR requests
- Steps: Send invalid SAR payload to webhook.
- Expected: Webhook returns error without crashing.
- Priority: Medium

[RE-004] Controller handles concurrent CRD updates
- Steps: Rapidly update same CRD from multiple clients.
- Expected: Controller handles conflicts gracefully.
- Priority: Medium

[RE-005] Controller memory pressure handling
- Steps: Create many resources to increase memory usage.
- Expected: Controller doesn't OOM, garbage collects properly.
- Priority: Low

[RE-006] Cleanup task removes expired sessions
- Steps: Create sessions with short expiry. Wait for cleanup.
- Expected: Cleanup task transitions expired sessions.
- Priority: High

[RE-007] Cleanup handles orphaned resources
- Steps: Create debug session, delete CR manually, leave pod.
- Expected: Orphan cleanup removes leftover pods.
- Priority: Medium

[RE-008] Leader election failover
- Steps: Run 2 controller replicas. Kill leader.
- Expected: Standby takes over leadership.
- Priority: Medium

---

## End-to-End Scenarios

[E2E-001] Complete breakglass flow with all notifications
- Steps: Request session, approve, use, expire. Verify all emails sent.
- Expected: Request, approval, activation, expiry warning, expiry emails all received.
- Priority: High

[E2E-002] Emergency access scenario
- Steps: Create high-priority escalation. Request for production incident. Approve rapidly. Use for debugging.
- Expected: Full flow completes in under 2 minutes.
- Priority: High

[E2E-003] Multi-cluster incident response
- Steps: Create escalation for multiple clusters. Request access to all. Use debug session on each.
- Expected: Single escalation grants access across clusters.
- Priority: Medium

[E2E-004] Audit trail complete for compliance
- Steps: Perform all session operations. Export audit log.
- Expected: Complete trail from request to expiry with all actors and timestamps.
- Priority: High

[E2E-005] Role-based access control validation
- Steps: Create users with different roles. Each attempts operations matching their role.
- Expected: Only authorized operations succeed.
- Priority: High

[E2E-006] Session handoff between shifts
- Steps: User A creates and uses session. User A invites User B as participant before leaving.
- Expected: User B can continue using session after User A leaves.
- Priority: Medium

[E2E-007] Escalation update mid-session
- Steps: Create active session. Update escalation permissions. Create new session.
- Expected: Old session has old permissions, new session has new permissions.
- Priority: Medium

[E2E-008] Full stack with all components
- Steps: Deploy with Keycloak, MailHog, Kafka, multiple clusters. Test complete flow.
- Expected: All integrations work together.
- Priority: High

---

## Test Coverage Summary

| Category | Count | Priority High | Priority Medium | Priority Low |
|----------|-------|---------------|-----------------|--------------|
| Multi-User & Groups | 10 | 6 | 4 | 0 |
| Session State Machine | 14 | 8 | 6 | 0 |
| Approval Workflows | 10 | 6 | 4 | 0 |
| Identity Providers | 10 | 4 | 6 | 0 |
| Mail Providers | 10 | 4 | 5 | 1 |
| Audit Logging | 17 | 8 | 8 | 1 |
| DenyPolicy | 12 | 5 | 7 | 0 |
| ClusterConfig | 10 | 4 | 6 | 0 |
| Webhook | 10 | 4 | 5 | 1 |
| Escalation Features | 10 | 5 | 4 | 1 |
| Debug Sessions | 10 | 2 | 6 | 2 |
| Metrics | 10 | 3 | 6 | 1 |
| Resilience | 8 | 3 | 4 | 1 |
| E2E Scenarios | 8 | 5 | 3 | 0 |
| **TOTAL** | **139** | **67** | **74** | **8** |

**Target: 100% feature coverage across all CRDs and integrations.**
---

## E2E Coverage Gap Analysis (as of January 2026)

This section documents the current E2E test coverage status based on a comprehensive code flow analysis.

### Coverage Status by Functional Area

| Area | Total Flows | Covered | Partial | Uncovered | Coverage % |
|------|-------------|---------|---------|-----------|------------|
| **Session Lifecycle** | 12 | 10 | 1 | 1 | 88% |
| **Escalation Management** | 8 | 6 | 1 | 1 | 81% |
| **DenyPolicy** | 10 | 7 | 2 | 1 | 80% |
| **ClusterConfig** | 7 | 5 | 1 | 1 | 79% |
| **IdentityProvider** | 10 | 6 | 2 | 2 | 70% |
| **MailProvider/Notifications** | 6 | 4 | 1 | 1 | 75% |
| **Debug Sessions** | 15 | 5 | 3 | 7 | 47% |
| **Webhook Authorization** | 12 | 9 | 2 | 1 | 83% |
| **Multi-Cluster** | 6 | 4 | 1 | 1 | 75% |
| **Audit Logging** | 5 | 0 | 1 | 4 | 10% |
| **API Endpoints** | 15 | 13 | 2 | 0 | 93% |
| **TOTAL** | **106** | **69** | **17** | **20** | **74%** |

### Critical Gaps (High Priority)

#### 1. Audit Logging (pkg/audit/) - 10% Coverage
**Production Risk**: Compliance failures, missing audit trail

| Gap | Code Location | Missing Test | Risk |
|-----|--------------|--------------|------|
| Event generation on session approval | `pkg/audit/emitter.go` | Verify audit event emitted after ApproveSession | Audit trail missing for approvals |
| Event generation on session rejection | `pkg/audit/emitter.go` | Verify audit event emitted after RejectSession | Audit trail missing for rejections |
| Kafka sink delivery | `pkg/audit/kafka_sink.go` | Produce event, verify Kafka receives it | Events lost silently |
| API audit endpoint | `pkg/api/audit_handler.go` | GET /api/audit/events returns events | No way to retrieve audit data |
| AuditConfig sink validation | `api/v1alpha1/audit_config_types.go` | Invalid sink config rejected | Silent failures |

#### 2. Debug Sessions (pkg/breakglass/debug_session_*.go) - 47% Coverage
**Production Risk**: Core feature broken, security vulnerabilities

| Gap | Code Location | Missing Test | Risk |
|-----|--------------|--------------|------|
| Workload deployment on target | `debug_session_workload.go` | Create debug session, verify Pod created | No pods get created |
| Pod cleanup on termination | `debug_session_controller.go` | Terminate session, verify Pod deleted | Orphan pods left running |
| Participant join | `debug_session_manager.go` | Second user joins active session | Collaboration broken |
| Session renewal/extension | `debug_session_controller.go` | Extend session duration | Sessions expire unexpectedly |
| Target cluster kubeconfig | `debug_session_workload.go` | Session on spoke cluster | Multi-cluster debug broken |
| Security context validation | `api/v1alpha1/debug_session_types.go` | Privileged container blocked | Security bypass |

#### 3. Session Cleanup Task (pkg/breakglass/cleanup_task.go) - 0% Direct Coverage
**Production Risk**: Sessions never expire, storage leaks

| Gap | Code Location | Missing Test | Risk |
|-----|--------------|--------------|------|
| Scheduled session activation | `scheduled_activation.go:ActivateScheduledSessions()` | ✅ Unit tests added in `scheduled_session_test.go` - E2E needed for full integration | Scheduled sessions never activate |
| Session retention expiry | `cleanup_task.go:cleanupExpiredSessions()` | Session past retention, verify deleted | Storage leaks |
| Background task startup | `cleanup_task.go:Start()` | Verify task running in controller | Silent failures |

### Medium Priority Gaps

#### 4. Multi-Cluster (pkg/cluster/) - 75% Coverage

| Gap | Code Location | Missing Test | Risk |
|-----|--------------|--------------|------|
| ClusterConfigRefs resolution | `pkg/cluster/client_provider.go` | Escalation refs cluster by name | Escalation fails to resolve cluster |
| Cross-cluster SAR authorization | `pkg/webhook/handler.go` | SAR from spoke validated by hub | Auth bypass in multi-cluster |
| Secret rotation cache invalidation | `pkg/cluster/cache.go` | Rotate kubeconfig secret, verify reconnect | Auth failures after rotation |

#### 5. Policy Evaluation (pkg/policy/) - 80% Coverage

| Gap | Code Location | Missing Test | Risk |
|-----|--------------|--------------|------|
| DenyPolicy precedence ordering | `pkg/policy/evaluator.go` | Multiple overlapping policies | Wrong policy applied |
| PodSecurityRules webhook enforcement | `pkg/webhook/handler.go` | SAR for privileged pod denied | Security bypass |

### Lower Priority Gaps

| Feature | Gap | Risk |
|---------|-----|------|
| MailProvider | Email template customization test | Wrong template used |
| IdentityProvider | Issuer URL validation at runtime | Silent auth failures |
| Metrics | Prometheus endpoint scraping | Observability gaps |

### Recommendations

**Sprint 1 (Immediate - Week 1-2)**:
1. Add audit event generation tests (compliance requirement)
2. Add debug session workload deployment test (core feature)
3. Add scheduled session activation test (production use case)

**Sprint 2 (Week 3-4)**:
1. Add cleanup task integration tests
2. Add debug session pod cleanup test
3. Add cross-cluster SAR test (requires multi-kind setup)

**Sprint 3 (Week 5-6)**:
1. Add multi-cluster ClusterConfigRefs test
2. Add DenyPolicy precedence test
3. Add debug session renewal test

### Infrastructure Requirements

Some tests require enhanced e2e infrastructure:

| Test Category | Requirement |
|--------------|-------------|
| Multi-cluster SAR | Second kind cluster as spoke |
| Kafka audit sink | Kafka container in e2e env |
| Scheduled activation | Time control or short durations |
| Debug session cleanup | Pod watching for termination |
