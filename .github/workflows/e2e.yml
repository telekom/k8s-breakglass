# SPDX-FileCopyrightText: 2024 Deutsche Telekom
#
# SPDX-License-Identifier: Apache-2.0

name: E2E Tests

on:
  pull_request:
    branches: [main]
  push:
    branches: [main]
  schedule:
    # Run nightly at 2:00 UTC
    - cron: '0 2 * * *'
  workflow_dispatch: {}

permissions:
  contents: read

env:
  GO_VERSION: '1.25.5'
  KIND_VERSION: 'v0.26.0'
  KIND_NODE_IMAGE: 'kindest/node:v1.34.0'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

concurrency:
  group: e2e-${{ github.ref }}
  cancel-in-progress: true

jobs:
  api-e2e:
    name: API E2E Tests
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v4.1.1

      - name: Set up Go
        uses: actions/setup-go@4dc6199c7b1a012772edbd06daecab0f50c9053c # v5.0.0
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Run E2E setup script
        run: |
          # Use the same script as local development for consistency
          chmod +x e2e/kind-setup-single.sh
          SKIP_PROXY=true CLUSTER_NAME=e2e-cluster ./e2e/kind-setup-single.sh
        env:
          SKIP_PROXY: "true"
          CLUSTER_NAME: "e2e-cluster"

      - name: Export kubeconfig from kind
        run: |
          # Explicitly get kubeconfig from kind and set it
          mkdir -p $HOME/.kube
          kind get kubeconfig --name e2e-cluster > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          export KUBECONFIG=$HOME/.kube/config
          echo "KUBECONFIG=$HOME/.kube/config" >> $GITHUB_ENV
          
          # Verify kubectl works
          echo "Verifying kubectl connectivity..."
          kubectl cluster-info
          kubectl get nodes

      - name: Run E2E prerequisite checks
        run: |
          echo "=== Running prerequisite checks before E2E tests ==="
          
          # Check kubectl connectivity
          echo "1. Checking kubectl connectivity..."
          if ! kubectl cluster-info >/dev/null 2>&1; then
            echo "ERROR: Cannot connect to Kubernetes cluster"
            exit 1
          fi
          echo "   ✓ Kubectl connected"
          
          # Check CRDs are installed
          echo "2. Checking CRDs..."
          for crd in breakglassescalations breakglasssessions denypolicies clusterconfigs identityproviders mailproviders; do
            if ! kubectl get crd ${crd}.breakglass.t-caas.telekom.com >/dev/null 2>&1; then
              echo "   ERROR: CRD ${crd}.breakglass.t-caas.telekom.com not found"
              exit 1
            fi
            echo "   ✓ ${crd} CRD exists"
          done
          
          # Check breakglass controller is running
          echo "3. Checking breakglass controller..."
          BG_NS=$(kubectl get pods --all-namespaces -l app=breakglass -o jsonpath='{.items[0].metadata.namespace}' 2>/dev/null || echo "")
          if [ -z "$BG_NS" ]; then
            echo "   ERROR: Breakglass controller pod not found"
            exit 1
          fi
          POD_STATUS=$(kubectl get pods -n "$BG_NS" -l app=breakglass -o jsonpath='{.items[0].status.phase}')
          if [ "$POD_STATUS" != "Running" ]; then
            echo "   ERROR: Breakglass controller not running (status: $POD_STATUS)"
            exit 1
          fi
          echo "   ✓ Controller running in namespace $BG_NS"
          
          # Check ClusterConfig exists for tenant-a
          echo "4. Checking ClusterConfig for tenant-a..."
          if ! kubectl get clusterconfig -A 2>/dev/null | grep -q tenant-a; then
            echo "   WARNING: No ClusterConfig for tenant-a found"
          else
            echo "   ✓ ClusterConfig for tenant-a exists"
          fi
          
          # Check IdentityProvider exists
          echo "5. Checking IdentityProvider..."
          IDP_COUNT=$(kubectl get identityprovider -A --no-headers 2>/dev/null | wc -l)
          if [ "$IDP_COUNT" -eq 0 ]; then
            echo "   WARNING: No IdentityProvider found"
          else
            echo "   ✓ Found $IDP_COUNT IdentityProvider(s)"
          fi
          
          echo ""
          echo "=== All prerequisite checks passed ==="

      - name: Setup port-forward for tests
        id: portforward
        run: |
          # Discover the breakglass namespace (kustomize may add prefix)
          # Get breakglass namespace (usually breakglass-system in dev)
          BG_NS=$(kubectl get pods --all-namespaces -l app=breakglass -o jsonpath='{.items[0].metadata.namespace}' 2>/dev/null || echo "breakglass-system")
          echo "Breakglass namespace: $BG_NS"
          
          # Find free ports to avoid conflicts
          API_PORT=$(python3 -c 'import socket; s=socket.socket(); s.bind(("", 0)); print(s.getsockname()[1]); s.close()')
          KEYCLOAK_PORT=$(python3 -c 'import socket; s=socket.socket(); s.bind(("", 0)); print(s.getsockname()[1]); s.close()')
          METRICS_PORT=$(python3 -c 'import socket; s=socket.socket(); s.bind(("", 0)); print(s.getsockname()[1]); s.close()')
          AUDIT_WEBHOOK_PORT=$(python3 -c 'import socket; s=socket.socket(); s.bind(("", 0)); print(s.getsockname()[1]); s.close()')
          echo "Using dynamically allocated API port: $API_PORT"
          echo "Using dynamically allocated Keycloak port: $KEYCLOAK_PORT"
          echo "Using dynamically allocated Metrics port: $METRICS_PORT"
          echo "Using dynamically allocated Audit Webhook port: $AUDIT_WEBHOOK_PORT"
          echo "api_port=$API_PORT" >> $GITHUB_OUTPUT
          echo "keycloak_port=$KEYCLOAK_PORT" >> $GITHUB_OUTPUT
          echo "metrics_port=$METRICS_PORT" >> $GITHUB_OUTPUT
          echo "audit_webhook_port=$AUDIT_WEBHOOK_PORT" >> $GITHUB_OUTPUT
          
          # Start port-forward for API (also serves webhook at /api/breakglass/webhook/authorize/:cluster)
          kubectl -n "$BG_NS" port-forward svc/breakglass-breakglass "$API_PORT:8080" &
          echo $! > /tmp/api-pf.pid
          
          # Start port-forward for Metrics (Prometheus metrics on port 8081)
          kubectl -n "$BG_NS" port-forward svc/breakglass-breakglass "$METRICS_PORT:8081" &
          echo $! > /tmp/metrics-pf.pid
          
          # Start port-forward for Keycloak (HTTPS on 8443)
          kubectl -n "$BG_NS" port-forward svc/breakglass-keycloak "$KEYCLOAK_PORT:8443" &
          echo $! > /tmp/keycloak-pf.pid
          
          # Start port-forward for Audit Webhook Receiver (for testing webhook audit sinks)
          kubectl -n "$BG_NS" port-forward svc/breakglass-audit-webhook-receiver "$AUDIT_WEBHOOK_PORT:80" &
          echo $! > /tmp/audit-webhook-pf.pid
          
          # Wait for API to be accessible
          for i in {1..30}; do
            if curl -s "http://localhost:$API_PORT/api/config" >/dev/null 2>&1; then
              echo "API is ready on localhost:$API_PORT"
              break
            fi
            echo "Waiting for API... attempt $i"
            sleep 2
          done
          
          # Wait for Metrics endpoint to be accessible
          for i in {1..30}; do
            if curl -s "http://localhost:$METRICS_PORT/metrics" >/dev/null 2>&1; then
              echo "Metrics endpoint is ready on localhost:$METRICS_PORT"
              break
            fi
            echo "Waiting for Metrics... attempt $i"
            sleep 2
          done
          
          # Wait for Keycloak to be accessible
          for i in {1..30}; do
            if curl -sk "https://localhost:$KEYCLOAK_PORT/realms/breakglass-e2e/.well-known/openid-configuration" >/dev/null 2>&1; then
              echo "Keycloak is ready on localhost:$KEYCLOAK_PORT"
              break
            fi
            echo "Waiting for Keycloak... attempt $i"
            sleep 2
          done
          
          # Wait for Audit Webhook Receiver to be accessible
          for i in {1..15}; do
            if curl -s "http://localhost:$AUDIT_WEBHOOK_PORT/health" >/dev/null 2>&1; then
              echo "Audit webhook receiver is ready on localhost:$AUDIT_WEBHOOK_PORT"
              break
            fi
            echo "Waiting for Audit Webhook Receiver... attempt $i"
            sleep 2
          done
          
          # Verify webhook endpoint is accessible
          echo "Verifying webhook endpoint..."
          curl -s -X POST "http://localhost:$API_PORT/api/breakglass/webhook/authorize/test" -d '{}' || echo "Webhook endpoint accessible (error expected for empty body)"

      - name: Run API E2E tests
        run: |
          E2E_TEST=true go test -v -timeout=20m ./e2e/api/...
        env:
          E2E_TEST: "true"
          E2E_NAMESPACE: "default"
          E2E_CLUSTER_NAME: "tenant-a"
          E2E_SKIP_CLEANUP: "true"
          BREAKGLASS_API_URL: "http://localhost:${{ steps.portforward.outputs.api_port }}"
          BREAKGLASS_WEBHOOK_URL: "http://localhost:${{ steps.portforward.outputs.api_port }}"
          BREAKGLASS_METRICS_URL: "http://localhost:${{ steps.portforward.outputs.metrics_port }}/metrics"
          KAFKA_TEST: "true"
          KEYCLOAK_HOST: "https://localhost:${{ steps.portforward.outputs.keycloak_port }}"
          KEYCLOAK_REALM: "breakglass-e2e"
          # KEYCLOAK_ISSUER_HOST sets the Host header when requesting tokens from Keycloak.
          # This ensures the token's issuer claim matches what the IdentityProvider expects.
          KEYCLOAK_ISSUER_HOST: "breakglass-keycloak.breakglass-system.svc.cluster.local:8443"
          AUDIT_WEBHOOK_TEST: "true"
          AUDIT_WEBHOOK_RECEIVER_EXTERNAL_URL: "http://localhost:${{ steps.portforward.outputs.audit_webhook_port }}"

      - name: Collect E2E diagnostics
        if: always()
        run: |
          echo "========================================"
          echo "=== E2E Test Environment Diagnostics ==="
          echo "========================================"
          echo ""
          
          # MailHog statistics
          echo "=== MailHog Email Statistics ==="
          MAILHOG_PORT=$(python3 -c 'import socket; s=socket.socket(); s.bind(("", 0)); print(s.getsockname()[1]); s.close()')
          kubectl -n breakglass-system port-forward svc/breakglass-mailhog "$MAILHOG_PORT:8025" &
          MAILHOG_PF_PID=$!
          sleep 3
          MAILHOG_MESSAGES=$(curl -s "http://localhost:$MAILHOG_PORT/api/v2/messages" 2>/dev/null || echo '{"total":0}')
          MAILHOG_COUNT=$(echo "$MAILHOG_MESSAGES" | jq -r '.total // 0' 2>/dev/null || echo "0")
          echo "  Total emails in MailHog: $MAILHOG_COUNT"
          if [ "$MAILHOG_COUNT" -gt 0 ]; then
            echo "  Recent email subjects:"
            echo "$MAILHOG_MESSAGES" | jq -r '.items[:10] | .[] | "    - " + (.Content.Headers.Subject[0] // "No subject")' 2>/dev/null || true
          fi
          kill $MAILHOG_PF_PID 2>/dev/null || true
          echo ""
          
          # Kafka statistics (if enabled)
          echo "=== Kafka Statistics ==="
          KAFKA_POD=$(kubectl get pods -n breakglass-system -l app=kafka -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          if [ -n "$KAFKA_POD" ]; then
            echo "  Kafka pod found: $KAFKA_POD"
            # List topics
            echo "  Topics:"
            kubectl exec -n breakglass-system "$KAFKA_POD" -- kafka-topics.sh --bootstrap-server localhost:9092 --list 2>/dev/null | while read topic; do
              echo "    - $topic"
            done || echo "    (unable to list topics)"
            # Count messages in breakglass-audit-events topic (matches audit config)
            AUDIT_COUNT=$(kubectl exec -n breakglass-system "$KAFKA_POD" -- kafka-run-class.sh kafka.tools.GetOffsetShell --broker-list localhost:9092 --topic breakglass-audit-events 2>/dev/null | awk -F: '{sum+=$3} END {print sum}' || echo "0")
            echo "  Audit topic message count: ${AUDIT_COUNT:-0}"
          else
            echo "  Kafka not deployed (skip)"
          fi
          echo ""
          
          # CRD counts
          echo "=== CRD Instance Counts ==="
          echo "  BreakglassEscalations: $(kubectl get breakglassescalations -A --no-headers 2>/dev/null | wc -l | tr -d ' ')"
          echo "  BreakglassSessions: $(kubectl get breakglasssessions -A --no-headers 2>/dev/null | wc -l | tr -d ' ')"
          echo "  DebugSessions: $(kubectl get debugsessions -A --no-headers 2>/dev/null | wc -l | tr -d ' ')"
          echo "  ClusterConfigs: $(kubectl get clusterconfigs -A --no-headers 2>/dev/null | wc -l | tr -d ' ')"
          echo "  IdentityProviders: $(kubectl get identityproviders -A --no-headers 2>/dev/null | wc -l | tr -d ' ')"
          echo "  MailProviders: $(kubectl get mailproviders -A --no-headers 2>/dev/null | wc -l | tr -d ' ')"
          echo "  DenyPolicies: $(kubectl get denypolicies -A --no-headers 2>/dev/null | wc -l | tr -d ' ')"
          echo ""
          
          # Session state distribution
          echo "=== BreakglassSession State Distribution ==="
          for state in Pending Approved Rejected Expired Withdrawn Timeout; do
            count=$(kubectl get breakglasssessions -A -o jsonpath="{.items[?(@.status.state=='$state')].metadata.name}" 2>/dev/null | wc -w | tr -d ' ')
            echo "  $state: $count"
          done
          echo ""
          
          # Controller health
          echo "=== Controller Health ==="
          # Health endpoints are on port 8082 inside the pod, use kubectl to check
          BREAKGLASS_POD=$(kubectl get pods -l app=breakglass -n breakglass-system -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          if [ -n "$BREAKGLASS_POD" ]; then
            # Check pod readiness via kubectl
            POD_READY=$(kubectl get pod "$BREAKGLASS_POD" -n breakglass-system -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' 2>/dev/null || echo "Unknown")
            echo "  Pod Ready: $POD_READY"
            
            # Port-forward to health probe port (8082) briefly to check health
            kubectl port-forward -n breakglass-system "$BREAKGLASS_POD" 18082:8082 &>/dev/null &
            HEALTH_PF_PID=$!
            sleep 2
            HEALTHZ=$(curl -s -o /dev/null -w "%{http_code}" "http://localhost:18082/healthz" 2>/dev/null || echo "failed")
            READYZ=$(curl -s -o /dev/null -w "%{http_code}" "http://localhost:18082/readyz" 2>/dev/null || echo "failed")
            echo "  /healthz: $HEALTHZ"
            echo "  /readyz: $READYZ"
            kill $HEALTH_PF_PID 2>/dev/null || true
            
            # Show pod status
            kubectl get pod "$BREAKGLASS_POD" -n breakglass-system -o wide 2>/dev/null | tail -1 || true
          else
            echo "  Breakglass pod not found"
          fi
          echo ""
          
          # Recent Kubernetes events
          echo "=== Recent Breakglass-Related Events (last 20) ==="
          kubectl get events -A --field-selector involvedObject.apiVersion=breakglass.t-caas.telekom.com/v1alpha1 --sort-by='.lastTimestamp' 2>/dev/null | tail -20 || echo "  No events found"
          echo ""
          
          # Controller Metrics
          echo "=== Controller Metrics (breakglass_* only) ==="
          METRICS_PORT=$(python3 -c 'import socket; s=socket.socket(); s.bind(("", 0)); print(s.getsockname()[1]); s.close()')
          BREAKGLASS_POD=$(kubectl get pods -l app=breakglass -n breakglass-system -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          if [ -n "$BREAKGLASS_POD" ]; then
            kubectl port-forward -n breakglass-system "$BREAKGLASS_POD" "$METRICS_PORT:8081" &>/dev/null &
            METRICS_PF_PID=$!
            sleep 3
            echo "  Fetching metrics from localhost:$METRICS_PORT/metrics..."
            METRICS=$(curl -s "http://localhost:$METRICS_PORT/metrics" 2>/dev/null || echo "")
            if [ -n "$METRICS" ]; then
              # Check if any breakglass_ metrics exist in the output
              BG_METRICS=$(echo "$METRICS" | grep -E 'breakglass_' || echo "")
              if [ -n "$BG_METRICS" ]; then
                echo ""
                echo "  --- Session Metrics ---"
                echo "$BG_METRICS" | grep -E 'breakglass_session' | head -20 || echo "  (no session metrics)"
                echo ""
                echo "  --- Webhook Metrics ---"
                echo "$BG_METRICS" | grep -E 'breakglass_webhook' | head -20 || echo "  (no webhook metrics)"
                echo ""
                echo "  --- Audit Metrics ---"
                echo "$BG_METRICS" | grep -E 'breakglass_audit' | head -20 || echo "  (no audit metrics)"
                echo ""
                echo "  --- Mail Metrics ---"
                echo "$BG_METRICS" | grep -E 'breakglass_mail' | head -20 || echo "  (no mail metrics)"
                echo ""
                echo "  --- Cluster Metrics ---"
                echo "$BG_METRICS" | grep -E 'breakglass_cluster' | head -10 || echo "  (no cluster metrics)"
              else
                echo "  No breakglass_* metrics found. Available metrics prefixes:"
                echo "$METRICS" | grep -v '^#' | cut -d'{' -f1 | cut -d' ' -f1 | sort -u | head -30
              fi
            else
              echo "  Failed to fetch metrics (empty response)"
            fi
            kill $METRICS_PF_PID 2>/dev/null || true
          else
            echo "  Breakglass pod not found for metrics collection"
          fi
          echo ""
          echo "========================================"
          echo "Note: Full logs are collected and output in the next step"
          echo "========================================"

      - name: Collect ALL logs
        if: always()
        run: |
          echo "=== Collecting ALL logs (always collected regardless of test outcome) ==="
          mkdir -p e2e-logs
          
          # Pod Status
          echo "=== Pod Status ===" | tee e2e-logs/pod-status.txt
          kubectl get pods -A | tee -a e2e-logs/pod-status.txt
          
          # Kube-APIServer Logs (from kube-system namespace)
          echo ""
          echo "=== Kube-APIServer Logs ===" 
          APISERVER_POD=$(kubectl get pods -n kube-system -l component=kube-apiserver -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          if [ -n "$APISERVER_POD" ]; then
            echo "Getting kube-apiserver logs from pod: $APISERVER_POD"
            kubectl logs "$APISERVER_POD" -n kube-system --timestamps --limit-bytes=10485760 > e2e-logs/kube-apiserver.log 2>&1 || true
            echo "  Kube-APIServer logs: $(wc -l < e2e-logs/kube-apiserver.log 2>/dev/null || echo 0) lines"
          else
            echo "  Kube-APIServer pod not found via label, trying static pod name"
            kubectl logs kube-apiserver-e2e-cluster-control-plane -n kube-system --timestamps --limit-bytes=10485760 > e2e-logs/kube-apiserver.log 2>&1 || true
          fi
          
          # Get the specific breakglass pod name to ensure we get ALL logs (not truncated)
          BREAKGLASS_POD=$(kubectl get pods -l app=breakglass -n breakglass-system -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)
          
          # Breakglass Controller Logs (FULL - use --limit-bytes to avoid truncation)
          echo ""
          echo "=== Breakglass Controller Logs (full) ===" | tee e2e-logs/breakglass-summary.txt
          if [ -n "$BREAKGLASS_POD" ]; then
            echo "Getting logs from pod: $BREAKGLASS_POD" | tee -a e2e-logs/breakglass-summary.txt
            # Use --limit-bytes=10485760 (10MB) to ensure we get complete logs
            kubectl logs "$BREAKGLASS_POD" -c breakglass -n breakglass-system --timestamps --limit-bytes=10485760 > e2e-logs/breakglass.log 2>&1 || \
              kubectl logs "$BREAKGLASS_POD" -n breakglass-system --timestamps --limit-bytes=10485760 > e2e-logs/breakglass.log 2>&1 || true
            # Also capture previous container logs if the container restarted
            kubectl logs "$BREAKGLASS_POD" -c breakglass -n breakglass-system --timestamps --previous --limit-bytes=10485760 > e2e-logs/breakglass-previous.log 2>&1 || true
            echo "  Logs written to e2e-logs/breakglass.log ($(wc -l < e2e-logs/breakglass.log 2>/dev/null || echo 0) lines)"
            echo "  Previous logs written to e2e-logs/breakglass-previous.log ($(wc -l < e2e-logs/breakglass-previous.log 2>/dev/null || echo 0) lines)"
            # Output ALL controller logs to console for debugging
            echo "=== BEGIN FULL CONTROLLER LOGS ==="
            cat e2e-logs/breakglass.log 2>/dev/null || true
            echo "=== END FULL CONTROLLER LOGS ==="
          else
            echo "No breakglass pod found, trying label selector" | tee -a e2e-logs/breakglass-summary.txt
            kubectl logs -l app=breakglass -n breakglass-system --timestamps --limit-bytes=10485760 > e2e-logs/breakglass.log 2>&1 || true
          fi
          
          # Breakglass Init Container Logs
          echo ""
          echo "=== Breakglass Init Container Logs ===" 
          if [ -n "$BREAKGLASS_POD" ]; then
            kubectl logs "$BREAKGLASS_POD" -c wait-for-keycloak -n breakglass-system --timestamps > e2e-logs/breakglass-init-container.log 2>&1 || echo "No init container logs"
          fi
          
          # Keycloak Logs (full - with limit-bytes and previous)
          echo ""
          echo "=== Keycloak Logs ===" 
          KEYCLOAK_POD=$(kubectl get pods -l app=keycloak -n breakglass-system -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          if [ -n "$KEYCLOAK_POD" ]; then
            kubectl logs "$KEYCLOAK_POD" -n breakglass-system --timestamps --limit-bytes=10485760 > e2e-logs/keycloak.log 2>&1 || true
            kubectl logs "$KEYCLOAK_POD" -n breakglass-system --timestamps --previous --limit-bytes=10485760 > e2e-logs/keycloak-previous.log 2>&1 || true
          else
            kubectl logs -l app=keycloak -n breakglass-system --timestamps --limit-bytes=10485760 > e2e-logs/keycloak.log 2>&1 || true
          fi
          echo "  Keycloak logs: $(wc -l < e2e-logs/keycloak.log 2>/dev/null || echo 0) lines"
          echo "=== BEGIN FULL KEYCLOAK LOGS ==="
          cat e2e-logs/keycloak.log 2>/dev/null || echo "  No Keycloak logs"
          echo "=== END FULL KEYCLOAK LOGS ==="
          
          # MailHog Logs (full)
          echo ""
          echo "=== MailHog Logs ===" 
          kubectl logs -l app=mailhog -n breakglass-system --timestamps --limit-bytes=10485760 > e2e-logs/mailhog.log 2>&1 || true
          
          # Kafka Logs (full - with limit-bytes and previous)
          echo ""
          echo "=== Kafka Logs ===" 
          KAFKA_LOG_POD=$(kubectl get pods -l app=kafka -n breakglass-system -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          if [ -n "$KAFKA_LOG_POD" ]; then
            kubectl logs "$KAFKA_LOG_POD" -n breakglass-system --timestamps --limit-bytes=10485760 > e2e-logs/kafka.log 2>&1 || true
            kubectl logs "$KAFKA_LOG_POD" -n breakglass-system --timestamps --previous --limit-bytes=10485760 > e2e-logs/kafka-previous.log 2>&1 || true
          else
            kubectl logs -l app=kafka -n breakglass-system --timestamps --limit-bytes=10485760 > e2e-logs/kafka.log 2>&1 || true
          fi
          echo "  Kafka logs: $(wc -l < e2e-logs/kafka.log 2>/dev/null || echo 0) lines"
          echo "=== BEGIN FULL KAFKA LOGS ==="
          cat e2e-logs/kafka.log 2>/dev/null || echo "  No Kafka logs"
          echo "=== END FULL KAFKA LOGS ==="
          
          # Kafka Data Dump (all topics and messages)
          echo ""
          echo "=== Kafka Data Dump ===" 
          KAFKA_POD=$(kubectl get pods -n breakglass-system -l app=kafka -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          if [ -n "$KAFKA_POD" ]; then
            echo "Kafka pod: $KAFKA_POD"
            # List all topics
            echo "=== Kafka Topics ==="
            kubectl exec -n breakglass-system "$KAFKA_POD" -- kafka-topics.sh --bootstrap-server localhost:9092 --list 2>/dev/null | tee e2e-logs/kafka-topics.txt || true
            
            # Dump messages from audit topics
            echo "=== Kafka Messages from breakglass-audit-events ==="
            kubectl exec -n breakglass-system "$KAFKA_POD" -- kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic breakglass-audit-events --from-beginning --timeout-ms 5000 2>/dev/null > e2e-logs/kafka-audit-events.json || true
            echo "Captured $(wc -l < e2e-logs/kafka-audit-events.json 2>/dev/null || echo 0) messages from breakglass-audit-events"
            cat e2e-logs/kafka-audit-events.json 2>/dev/null || echo "  No messages"
            
            echo "=== Kafka Messages from breakglass-audit-functional-test ==="
            kubectl exec -n breakglass-system "$KAFKA_POD" -- kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic breakglass-audit-functional-test --from-beginning --timeout-ms 5000 2>/dev/null > e2e-logs/kafka-functional-test.json || true
            echo "Captured $(wc -l < e2e-logs/kafka-functional-test.json 2>/dev/null || echo 0) messages from breakglass-audit-functional-test"
            cat e2e-logs/kafka-functional-test.json 2>/dev/null || echo "  No messages"
            
            # Get topic metadata
            echo "=== Kafka Topic Details ==="
            kubectl exec -n breakglass-system "$KAFKA_POD" -- kafka-topics.sh --bootstrap-server localhost:9092 --describe 2>/dev/null > e2e-logs/kafka-topics-describe.txt || true
            cat e2e-logs/kafka-topics-describe.txt 2>/dev/null || echo "  No topic details"
          else
            echo "  Kafka pod not found"
          fi
          
          # Audit Webhook Receiver Logs (full)
          echo ""
          echo "=== Audit Webhook Receiver Logs ===" 
          kubectl logs -l app=audit-webhook-receiver -n breakglass-system --timestamps > e2e-logs/audit-webhook-receiver.log 2>&1 || true
          echo "=== BEGIN FULL AUDIT WEBHOOK RECEIVER LOGS ==="
          cat e2e-logs/audit-webhook-receiver.log 2>/dev/null || echo "  No Audit Webhook Receiver logs"
          echo "=== END FULL AUDIT WEBHOOK RECEIVER LOGS ==="
          
          # All pods in breakglass namespace (individual logs)
          echo ""
          echo "=== All pod logs in breakglass-system ===" 
          for pod in $(kubectl get pods -n breakglass-system -o name 2>/dev/null); do
            podname=$(basename "$pod")
            kubectl logs "$pod" -n breakglass-system --all-containers --timestamps > "e2e-logs/${podname}.log" 2>&1 || true
            echo "  Captured logs for $podname"
          done
          
          # Events
          echo ""
          echo "=== Recent Events ===" | tee e2e-logs/events.txt
          kubectl get events --sort-by='.lastTimestamp' -A > e2e-logs/events.txt 2>&1 || true
          tail -50 e2e-logs/events.txt
          
          # CRD state snapshots
          echo ""
          echo "=== CRD State Snapshots ===" 
          kubectl get pods -A -o yaml > e2e-logs/pods.yaml 2>&1 || true
          kubectl describe pods -n breakglass-system > e2e-logs/pods-describe.txt 2>&1 || true
          kubectl get breakglassescalations -A -o yaml > e2e-logs/escalations.yaml 2>&1 || true
          kubectl get breakglasssessions -A -o yaml > e2e-logs/sessions.yaml 2>&1 || true
          kubectl get clusterconfigs -A -o yaml > e2e-logs/clusterconfigs.yaml 2>&1 || true
          kubectl get identityproviders -A -o yaml > e2e-logs/identityproviders.yaml 2>&1 || true
          kubectl get denypolicies -A -o yaml > e2e-logs/denypolicies.yaml 2>&1 || true
          kubectl get auditconfigs -A -o yaml > e2e-logs/auditconfigs.yaml 2>&1 || true
          kubectl get mailproviders -A -o yaml > e2e-logs/mailproviders.yaml 2>&1 || true
          
          # List what was captured
          echo ""
          echo "=== Captured Log Files ===" 
          ls -la e2e-logs/

      - name: Upload ALL logs as artifact
        if: always()
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v4.0.0
        with:
          name: e2e-logs-${{ github.run_id }}
          path: e2e-logs/
          retention-days: 7

      - name: Cleanup
        if: always()
        run: |
          kind delete cluster --name e2e-cluster || true

  e2e-prerequisites:
    name: E2E Prerequisites Check
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v4.1.1

      - name: Set up Go
        uses: actions/setup-go@4dc6199c7b1a012772edbd06daecab0f50c9053c # v5.0.0
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Install kind
        run: |
          curl -Lo ./kind https://kind.sigs.k8s.io/dl/${{ env.KIND_VERSION }}/kind-linux-amd64
          chmod +x ./kind
          sudo mv ./kind /usr/local/bin/kind

      - name: Create minimal kind cluster
        run: |
          # Prerequisites tests only need CRDs, not full setup - use minimal cluster
          # Must use K8s 1.30+ for selectableFields CRD feature
          kind create cluster --name prereq-cluster --image ${{ env.KIND_NODE_IMAGE }}
          kubectl wait --for=condition=Ready nodes --all --timeout=120s

      - name: Install CRDs only
        run: make install

      - name: Run prerequisite tests
        run: |
          E2E_TEST=true go test -v -run TestE2EPrerequisites ./e2e/...
        env:
          E2E_TEST: "true"

      - name: Cleanup
        if: always()
        run: kind delete cluster --name prereq-cluster || true

  # UI E2E tests (Playwright) - future implementation
  # ui-e2e:
  #   name: UI E2E Tests
  #   runs-on: ubuntu-latest
  #   timeout-minutes: 30
  #   needs: api-e2e
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v4.1.1
  #
  #     - name: Set up Node.js
  #       uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4.4.0
  #       with:
  #         node-version: '22'
  #         cache: 'npm'
  #         cache-dependency-path: frontend/package-lock.json
  #
  #     - name: Install Playwright
  #       run: |
  #         cd frontend
  #         npm ci
  #         npx playwright install --with-deps chromium
  #
  #     - name: Run UI E2E tests
  #       run: |
  #         cd frontend
  #         npx playwright test
  #
  #     - name: Upload Playwright report
  #       if: always()
  #       uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v4.0.0
  #       with:
  #         name: playwright-report
  #         path: frontend/playwright-report/
