name: Release

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch: {}

permissions:
  contents: write
  packages: write
  id-token: write

env:
  GO_VERSION: '1.24.1'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true
      - name: Generate manifests
        run: |
          make manifests
          tar -czf manifests-${{ github.ref_name }}.tgz config/crd/bases
      - name: Upload manifests artifact
        uses: actions/upload-artifact@v4
        with:
          name: manifests
          path: manifests-${{ github.ref_name }}.tgz
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3
        with:
          install: true
      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=${{ github.ref_name }}
            type=raw,value=latest
      - name: Build & Push Image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          platforms: linux/amd64,linux/arm64
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      - name: Tag and push image to Artifactory OCI
        env:
          ARTIFACTORY_URL: artifactory.devops.telekom.de
          ARTIFACTORY_REPO: cit-t-caas-oci/images/t-caas
        run: |
          set -e
          # docker CLI login using environment secrets
          echo "Logging in to Artifactory OCI at ${ARTIFACTORY_URL}"
          echo "${{ secrets.AF_TOKEN }}" | docker login --username ${{ secrets.AF_USER }} --password-stdin https://${ARTIFACTORY_URL}
          echo "Docker login status: $(docker info --format '{{json .}}' 2>/dev/null || echo 'docker info not available')"
          # Diagnose Artifactory repo accessibility
          REPO_KEY=$(echo "${ARTIFACTORY_REPO}" | cut -d'/' -f1)
          echo "Checking Artifactory storage API for repo key: ${REPO_KEY}"
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -u "${{ secrets.AF_USER }}:${{ secrets.AF_TOKEN }}" "https://${ARTIFACTORY_URL}/artifactory/api/storage/${REPO_KEY}" ) || true
          echo "Artifactory storage API HTTP status: ${HTTP_STATUS}"
          if [ "${HTTP_STATUS}" != "200" ]; then
            echo "Warning: Artifactory repo ${REPO_KEY} not accessible (HTTP ${HTTP_STATUS}). Ensure AF_USER/AF_TOKEN are valid and have deploy permissions."
          fi
          # Retrieve tag list from docker metadata output and push each tag with Artifactory repo prefix
          IMAGE=${{ env.IMAGE_NAME }}
          # meta.tags contains comma separated tags from docker/metadata-action; we will push the main tag (ref_name)
          TAG=${{ github.ref_name }}
          ART_IMG=${ARTIFACTORY_URL}/${ARTIFACTORY_REPO}/${IMAGE}:${TAG}
          echo "Tagging ${REGISTRY}/${IMAGE}:${TAG} -> ${ART_IMG}"
          set -x
          docker pull ${REGISTRY}/${IMAGE}:${TAG} || true
          docker tag ${REGISTRY}/${IMAGE}:${TAG} ${ART_IMG}
          docker push ${ART_IMG} || (echo "docker push failed"; exit 1)
          set +x
          # Small wait for Artifactory to index
          sleep 3
          # Check whether the pushed image path exists in Artifactory storage (best-effort)
          CHECK_PATH=$(echo "${ARTIFACTORY_REPO}/${IMAGE}" | sed 's@//*@/@g')
          echo "Checking storage for path: ${CHECK_PATH}"
          HTTP_STATUS_AFTER=$(curl -s -o /dev/null -w "%{http_code}" -u "${{ secrets.AF_USER }}:${{ secrets.AF_TOKEN }}" "https://${ARTIFACTORY_URL}/artifactory/api/storage/${CHECK_PATH}?list" ) || true
          echo "Artifactory storage API HTTP status for pushed path: ${HTTP_STATUS_AFTER}"
          if [ "${HTTP_STATUS_AFTER}" = "200" ]; then
            echo "Artifact path appears present in Artifactory."
          else
            echo "Artifact path not found or not accessible (HTTP ${HTTP_STATUS_AFTER}). It might be a permission issue or Artifactory indexing delay."
          fi
      - name: Generate SBOM (Syft)
        uses: anchore/sbom-action@v0.17.6
        with:
          image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.ref_name }}
          format: spdx-json
          artifact-name: sbom-${{ github.ref_name }}.json
      - name: Attest provenance (skipped temporarily)
        # Temporarily disabled because ACTIONS_ID_TOKEN_REQUEST_URL isn't available in some runners
        # Re-enable by removing or changing the `if` condition when the environment supports id-token requests.
        if: ${{ false }}
        uses: actions/attest-build-provenance@v1
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          subject-digest: ${{ steps.build.outputs.digest }}
          push-to-registry: true
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            manifests-${{ github.ref_name }}.tgz
            sbom-${{ github.ref_name }}.json
          generate_release_notes: true
