# SPDX-FileCopyrightText: 2025 Deutsche Telekom AG
#
# SPDX-License-Identifier: Apache-2.0

name: Release

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch: {}

permissions:
  contents: read

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # ---------------------------------------------------------------------------
  # Build release manifests and bgctl CLI binaries
  # ---------------------------------------------------------------------------
  prepare:
    permissions:
      contents: read
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
      - name: Set up Go
        uses: actions/setup-go@4b73464bb391d4059bd26b0524d20df3927bd417 # v6.3.0
        with:
          go-version-file: go.mod
          cache: true
      - name: Generate manifests
        run: |
          make manifests
          make kustomize

          # Set the correct image tag for this release
          VERSION=${{ github.ref_name }}
          cd config/deployment
          ../../bin/kustomize edit set image breakglass=ghcr.io/telekom/k8s-breakglass:${VERSION}
          cd ../..

          # Build complete deployment manifests for each target
          ./bin/kustomize build config/base > manifests-base.yaml
          ./bin/kustomize build config/debug > manifests-debug.yaml
          # Create CRDs-only manifest
          ./bin/kustomize build config/crd > manifests-crds.yaml

          # Verify image tag is correct in output
          echo "Verifying image tags in manifests..."
          grep -o "ghcr.io/telekom/k8s-breakglass:${VERSION}" manifests-base.yaml || { echo "ERROR: Image tag not set correctly"; exit 1; }

          # Package everything
          tar -czf manifests-${{ github.ref_name }}.tgz \
            config/crd/bases \
            manifests-base.yaml \
            manifests-debug.yaml \
            manifests-crds.yaml
      - name: Upload manifests artifact
        uses: actions/upload-artifact@bbbca2ddaa5d8feaa63e36b76fdaad77386f024f # v7.0.0
        with:
          name: manifests
          path: |
            manifests-${{ github.ref_name }}.tgz
            manifests-base.yaml
            manifests-debug.yaml
            manifests-crds.yaml
      - name: Build bgctl release assets
        run: |
          set -e
          VERSION=${{ github.ref_name }}
          GIT_COMMIT=${{ github.sha }}
          BUILD_DATE=${{ github.event.head_commit.timestamp }}
          mkdir -p dist
          platforms="linux/amd64 linux/arm64 darwin/amd64 darwin/arm64 windows/amd64"
          for platform in $platforms; do
            os=${platform%/*}
            arch=${platform#*/}
            bin=bgctl
            ext=""
            if [ "$os" = "windows" ]; then
              ext=".exe"
            fi
            outdir="dist/bgctl_${os}_${arch}"
            mkdir -p "$outdir"
            GOOS=$os GOARCH=$arch CGO_ENABLED=0 go build -trimpath \
              -ldflags "-s -w -X github.com/telekom/k8s-breakglass/pkg/version.Version=$VERSION -X github.com/telekom/k8s-breakglass/pkg/version.GitCommit=$GIT_COMMIT -X github.com/telekom/k8s-breakglass/pkg/version.BuildDate=$BUILD_DATE" \
              -o "$outdir/$bin$ext" ./cmd/bgctl
            if [ "$os" = "windows" ]; then
              (cd dist && zip -r "bgctl_${os}_${arch}.zip" "bgctl_${os}_${arch}")
              (cd dist && shasum -a 256 "bgctl_${os}_${arch}.zip" > "bgctl_${os}_${arch}.zip.sha256")
            else
              (cd dist && tar -czf "bgctl_${os}_${arch}.tar.gz" "bgctl_${os}_${arch}")
              (cd dist && shasum -a 256 "bgctl_${os}_${arch}.tar.gz" > "bgctl_${os}_${arch}.tar.gz.sha256")
            fi
          done
          # Generate combined checksums file (only archive files, not directories)
          (cd dist && shasum -a 256 *.tar.gz *.zip > "bgctl_${VERSION}_checksums.txt")
      - name: Upload bgctl artifacts
        uses: actions/upload-artifact@bbbca2ddaa5d8feaa63e36b76fdaad77386f024f # v7.0.0
        with:
          name: bgctl-dist
          path: |
            dist/bgctl_*.tar.gz
            dist/bgctl_*.zip
            dist/bgctl_*.sha256
            dist/bgctl_${{ github.ref_name }}_checksums.txt

  # ---------------------------------------------------------------------------
  # Build per-architecture container images natively (no QEMU emulation)
  # ---------------------------------------------------------------------------
  build-image:
    permissions:
      contents: read
      packages: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: linux/amd64
            runner: ubuntu-latest
          - platform: linux/arm64
            # NOTE: ubuntu-24.04-arm is a GitHub-hosted larger runner with different billing.
            # See: https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners
            runner: ubuntu-24.04-arm
    runs-on: ${{ matrix.runner }}
    steps:
      - uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
      - name: Login to GHCR
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 # v3.7.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Set up Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3.12.0
      - name: Docker meta
        id: meta
        uses: docker/metadata-action@c299e40c65443455700f0fdfc63efafe5b349051 # v5.10.0
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          labels: |
            org.opencontainers.image.title=Kubernetes Breakglass
            org.opencontainers.image.description=Secure, auditable privilege escalation system for Kubernetes clusters with real-time webhook integration and time-bounded access
            org.opencontainers.image.url=https://github.com/telekom/k8s-breakglass
            org.opencontainers.image.documentation=https://github.com/telekom/k8s-breakglass/tree/main/docs
            org.opencontainers.image.source=https://github.com/telekom/k8s-breakglass
            org.opencontainers.image.licenses=Apache-2.0
            org.opencontainers.image.vendor=Deutsche Telekom
            org.opencontainers.image.version=${{ github.ref_name }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp || github.run_started_at }}
            com.github.repo.branch=${{ github.ref_name }}
            com.github.repo.owner=${{ github.repository_owner }}
            com.buildkit.build.ref=${{ github.ref }}
      - name: Build & push single-platform image (by digest)
        id: build
        uses: docker/build-push-action@10e90e3645eae34f1e60eeb005ba3a3d33f178e8 # v6.19.2
        with:
          context: .
          push: true
          # Push by digest only — no tag yet; tags are created in the assemble step
          platforms: ${{ matrix.platform }}
          labels: ${{ steps.meta.outputs.labels }}
          # Note: buildx cache (cache-from/cache-to) is intentionally omitted for
          # release builds to ensure clean, reproducible images without layer reuse
          # from development iterations.
          build-args: |
            VERSION=${{ github.ref_name }}
            GIT_COMMIT=${{ github.sha }}
            BUILD_DATE=${{ github.event.head_commit.timestamp || github.run_started_at }}
          # BUILD_DATE: head_commit.timestamp is set for tag pushes; run_started_at
          # (always available) serves as fallback for workflow_dispatch triggers.
          outputs: type=image,name=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }},push-by-digest=true,name-canonical=true,push=true
      - name: Export digest
        id: set-digest
        run: |
          PLATFORM="${{ matrix.platform }}"
          ARCH_FULL=$(echo "${PLATFORM}" | tr '/' '-')  # e.g., linux-amd64 or linux-arm64
          ARCH_SHORT="${PLATFORM#*/}"  # e.g., amd64 or arm64
          if [ -z "${ARCH_SHORT}" ] || [ "${ARCH_SHORT}" = "${PLATFORM}" ]; then
            echo "Invalid platform format: '${PLATFORM}'. Expected '<os>/<arch>' (e.g., 'linux/amd64')." >&2
            exit 1
          fi
          DIGEST="${{ steps.build.outputs.digest }}"
          if [ -z "${DIGEST}" ]; then
            echo "Error: Build produced no digest for platform '${PLATFORM}' (arch=${ARCH_SHORT})." >&2
            exit 1
          fi
          echo "digest-${ARCH_SHORT}=${DIGEST}" >> "$GITHUB_OUTPUT"
          echo "artifact-name=digest-${ARCH_SHORT}" >> "$GITHUB_OUTPUT"
          echo "arch-full=${ARCH_FULL}" >> "$GITHUB_OUTPUT"
          # Also persist to a file artifact so the assemble job can collect all digests
          mkdir -p /tmp/digests
          echo "${DIGEST}" > "/tmp/digests/${ARCH_FULL}"
      - name: Upload digest
        uses: actions/upload-artifact@bbbca2ddaa5d8feaa63e36b76fdaad77386f024f # v7.0.0
        with:
          name: ${{ steps.set-digest.outputs.artifact-name }}
          path: /tmp/digests/${{ steps.set-digest.outputs.arch-full }}

  # ---------------------------------------------------------------------------
  # Assemble per-arch images into a single multi-arch manifest and tag it
  # ---------------------------------------------------------------------------
  assemble:
    needs: [build-image]
    permissions:
      contents: read
      packages: write
      id-token: write
      attestations: write
    runs-on: ubuntu-latest
    outputs:
      digest: ${{ steps.inspect.outputs.digest }}
    steps:
      - name: Download all digests
        uses: actions/download-artifact@70fc10c6e5e1ce46ad2ea6f2b72d43f7d47b13c3 # v8.0.0
        with:
          pattern: digest-*
          merge-multiple: true
          path: /tmp/digests
      - name: Login to GHCR
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 # v3.7.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Set up Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3.12.0
      - name: Docker meta
        id: meta
        uses: docker/metadata-action@c299e40c65443455700f0fdfc63efafe5b349051 # v5.10.0
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=${{ github.ref_name }}
            type=raw,value=latest,enable=${{ startsWith(github.ref, 'refs/tags/') }}
      - name: Create and push multi-arch manifest
        env:
          REGISTRY: ${{ env.REGISTRY }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
        run: |
          set -euo pipefail

          # Verify digest files exist
          if [ -z "$(ls -A /tmp/digests 2>/dev/null)" ]; then
            echo "Error: No digest files found in /tmp/digests. Artifact download may have failed." >&2
            exit 1
          fi

          # Verify all expected platform digests are present
          for expected in linux-amd64 linux-arm64; do
            if [ ! -f "/tmp/digests/${expected}" ]; then
              echo "Error: Missing digest for platform ${expected}. Cannot assemble incomplete multi-arch manifest." >&2
              exit 1
            fi
          done

          # Display discovered digest files for diagnostics
          echo "Digest files found:"
          ls -la /tmp/digests/

          # Collect per-arch digests into an array
          DIGESTS=()
          for f in /tmp/digests/*; do
            d=$(cat "$f")
            echo "  $(basename "$f"): ${d}"
            DIGESTS+=("${REGISTRY}/${IMAGE_NAME}@${d}")
          done
          echo "Assembling multi-arch manifest from ${#DIGESTS[@]} platform(s): ${DIGESTS[*]}"

          # Build the --tag flags from metadata into an array
          TAGS=()
          while IFS= read -r tag; do
            # Skip empty lines that can result from trailing newlines
            [ -z "${tag}" ] && continue
            TAGS+=("--tag" "$tag")
          done <<< "${{ steps.meta.outputs.tags }}"

          # Ensure we have at least one tag
          if [ ${#TAGS[@]} -eq 0 ]; then
            echo "Error: No tags were generated from docker/metadata-action; aborting multi-arch manifest creation." >&2
            exit 1
          fi

          # Create and push the multi-arch manifest list
          docker buildx imagetools create "${TAGS[@]}" "${DIGESTS[@]}"
      - name: Inspect final image
        id: inspect
        run: |
          set -euo pipefail
          IMG="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.ref_name }}"

          # Extract the top-level digest from the manifest by hashing the raw
          # manifest JSON.  The --raw flag outputs the exact manifest bytes as
          # stored in the registry (no pretty-printing or trailing newline), so
          # sha256sum produces the correct OCI content-addressable digest.
          # We do not rely on --format due to historical incompatibilities
          # across Buildx versions.
          RAW_MANIFEST_DIGEST="sha256:$(docker buildx imagetools inspect "${IMG}" --raw | sha256sum | awk '{print $1}')"

          # Strictly validate the computed digest format: must be sha256: + 64 hex chars.
          if ! printf '%s\n' "${RAW_MANIFEST_DIGEST}" | grep -Eq '^sha256:[0-9a-f]{64}$'; then
            echo "Error: Computed manifest digest has unexpected format: ${RAW_MANIFEST_DIGEST}" >&2
            exit 1
          fi

          # Capture the human-readable inspect output once for diagnostics and
          # cross-checking, avoiding an extra registry round-trip.
          INSPECT_OUTPUT="$(docker buildx imagetools inspect "${IMG}")"
          echo "${INSPECT_OUTPUT}"

          # Best-effort cross-check against the Digest line reported by
          # Buildx/registry.  This is warn-only because the human-readable
          # output format may change across Buildx versions and we do not want
          # a cosmetic parsing failure to block a release.
          REGISTRY_DIGEST="$(echo "${INSPECT_OUTPUT}" | awk '/^Digest:/ {print $2; exit}')" || true
          if [ -n "${REGISTRY_DIGEST}" ] && [ "${REGISTRY_DIGEST}" != "${RAW_MANIFEST_DIGEST}" ]; then
            echo "::warning::Digest cross-check mismatch: computed=${RAW_MANIFEST_DIGEST} registry=${REGISTRY_DIGEST}"
          fi

          DIGEST="${RAW_MANIFEST_DIGEST}"

          echo "digest=${DIGEST}" >> "$GITHUB_OUTPUT"
          echo "Multi-arch manifest digest: ${DIGEST}"
      - name: Attest provenance
        uses: actions/attest-build-provenance@a2bbfa25375fe432b6a289bc6b6cd05ecd0c4c32 # v4.1.0
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          subject-digest: ${{ steps.inspect.outputs.digest }}
          push-to-registry: true
      - name: Install cosign
        uses: sigstore/cosign-installer@faadad0cce49287aee09b3a48701e75088a2c6ad # v4.0.0
      - name: Sign container image (keyless)
        run: |
          set -euo pipefail
          cosign sign --yes ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.inspect.outputs.digest }}
      - name: Generate SBOM for attestation
        uses: anchore/sbom-action@17ae1740179002c89186b61233e0f892c3118b11 # v0.23.0
        with:
          image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.inspect.outputs.digest }}
          format: spdx-json
          output-file: sbom.spdx.json
          upload-release-assets: false
      - name: Attest SBOM (keyless)
        run: |
          cosign attest --yes --type spdxjson --predicate sbom.spdx.json \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.inspect.outputs.digest }}

  # ---------------------------------------------------------------------------
  # Push multi-arch image to Artifactory OCI mirror
  # ---------------------------------------------------------------------------
  artifactory:
    needs: [assemble]
    continue-on-error: true  # Artifactory mirror is best-effort; must not block releases
    permissions:
      packages: read
      id-token: write  # Required for cosign keyless signing/copy
    runs-on: ubuntu-latest
    steps:
      - name: Login to GHCR
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 # v3.7.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Set up Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3.12.0
      - name: Install cosign
        uses: sigstore/cosign-installer@faadad0cce49287aee09b3a48701e75088a2c6ad # v4.0.0
      - name: Tag and push image to Artifactory OCI
        env:
          ARTIFACTORY_URL: artifactory.devops.telekom.de
          ARTIFACTORY_REPO: cit-t-caas-oci/images/t-caas
          REGISTRY: ${{ env.REGISTRY }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
        run: |
          set -euo pipefail
          # docker CLI login using environment secrets
          echo "Logging in to Artifactory OCI at ${ARTIFACTORY_URL}"
          echo "${{ secrets.AF_TOKEN }}" | docker login --username ${{ secrets.AF_USER }} --password-stdin https://${ARTIFACTORY_URL}

          # Diagnose Artifactory repo accessibility
          REPO_KEY=$(echo "${ARTIFACTORY_REPO}" | cut -d'/' -f1)
          echo "Checking Artifactory storage API for repo key: ${REPO_KEY}"
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -u "${{ secrets.AF_USER }}:${{ secrets.AF_TOKEN }}" "https://${ARTIFACTORY_URL}/artifactory/api/storage/${REPO_KEY}" ) || true
          echo "Artifactory storage API HTTP status: ${HTTP_STATUS}"
          if [ "${HTTP_STATUS}" != "200" ]; then
            echo "Warning: Artifactory repo ${REPO_KEY} not accessible (HTTP ${HTTP_STATUS}). Ensure AF_USER/AF_TOKEN are valid and have deploy permissions."
          fi

          IMAGE=${{ env.IMAGE_NAME }}
          TAG=${{ github.ref_name }}
          SRC=${REGISTRY}/${IMAGE}:${TAG}
          DST=${ARTIFACTORY_URL}/${ARTIFACTORY_REPO}/${IMAGE}:${TAG}

          echo "Copying multi-arch manifest ${SRC} -> ${DST}"

          # Use buildx imagetools to copy the full multi-arch manifest (all platforms)
          docker buildx imagetools create --tag "${DST}" "${SRC}"

          # Copy cosign signatures and attestations to Artifactory
          # Cosign artifacts (signatures, SBOM attestations) are stored as OCI referrers
          # alongside the image in GHCR. docker buildx imagetools does not copy these,
          # so we use cosign copy to replicate them to the Artifactory mirror.
          # Use digest-based source reference to ensure we copy artifacts for the exact
          # signed manifest, not whatever the tag resolves to at copy time.
          SRC_DIGEST=${REGISTRY}/${IMAGE}@${{ needs.assemble.outputs.digest }}
          echo "Copying cosign artifacts (signatures + attestations) to Artifactory"
          # Set explicit registry credentials for cosign — docker login credentials
          # are not always reused by cosign for the destination registry.
          export COSIGN_REPOSITORY="${DST}"
          cosign copy "${SRC_DIGEST}" "${DST}" --only=sig,att || echo "::warning::cosign copy failed — Artifactory image will not be verifiable via cosign"

          # Verify the pushed image is indexed in Artifactory (retry with backoff)
          CHECK_PATH=$(echo "${ARTIFACTORY_REPO}/${IMAGE}" | sed 's@//*@/@g')
          echo "Checking storage for path: ${CHECK_PATH}"
          for attempt in 1 2 3; do
            sleep $((attempt * 2))
            HTTP_STATUS_AFTER=$(curl -s -o /dev/null -w "%{http_code}" -u "${{ secrets.AF_USER }}:${{ secrets.AF_TOKEN }}" "https://${ARTIFACTORY_URL}/artifactory/api/storage/${CHECK_PATH}?list" ) || true
            echo "Attempt ${attempt}: HTTP status ${HTTP_STATUS_AFTER}"
            if [ "${HTTP_STATUS_AFTER}" = "200" ]; then
              echo "Artifact path appears present in Artifactory."
              break
            fi
          done
          if [ "${HTTP_STATUS_AFTER}" != "200" ]; then
            echo "Warning: Artifact path not confirmed after retries (HTTP ${HTTP_STATUS_AFTER}). It might be a permission issue or Artifactory indexing delay."
          fi

  # ---------------------------------------------------------------------------
  # Create GitHub Release with manifests, bgctl binaries, and SBOM
  # ---------------------------------------------------------------------------
  release:
    # NOTE: Does not depend on `artifactory` intentionally — Artifactory is a
    # best-effort mirror and should not block GitHub Release creation.
    needs: [prepare, assemble]
    permissions:
      contents: write
      packages: read
    runs-on: ubuntu-latest
    steps:
      - name: Download manifests
        uses: actions/download-artifact@70fc10c6e5e1ce46ad2ea6f2b72d43f7d47b13c3 # v8.0.0
        with:
          name: manifests
          path: .
      - name: Download bgctl dist
        uses: actions/download-artifact@70fc10c6e5e1ce46ad2ea6f2b72d43f7d47b13c3 # v8.0.0
        with:
          name: bgctl-dist
          path: dist
      - name: Create GitHub Release
        uses: softprops/action-gh-release@a06a81a03ee405af7f2048a818ed3f03bbf83c7b # v2.5.0
        with:
          files: |
            manifests-${{ github.ref_name }}.tgz
            manifests-base.yaml
            manifests-debug.yaml
            manifests-crds.yaml
            dist/bgctl_*.tar.gz
            dist/bgctl_*.zip
            dist/bgctl_*.sha256
            dist/bgctl_${{ github.ref_name }}_checksums.txt
          generate_release_notes: true
      - name: Generate SBOM (Syft)
        uses: anchore/sbom-action@17ae1740179002c89186b61233e0f892c3118b11 # v0.23.0
        with:
          image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.ref_name }}
          format: spdx-json
          artifact-name: sbom-${{ github.ref_name }}.json
          upload-release-assets: false
      - name: Upload SBOM to Release (if GH_PUBLISH_TOKEN)
        run: |
          SBOM_FILE=sbom-${{ github.ref_name }}.json
          if [ -n "${{ secrets.GH_PUBLISH_TOKEN }}" ]; then
            echo "Using GH_PUBLISH_TOKEN to attach SBOM to release"
            RELEASE_JSON=$(curl -s -H "Authorization: token ${{ secrets.GH_PUBLISH_TOKEN }}" "https://api.github.com/repos/${{ github.repository }}/releases/tags/${{ github.ref_name }}")
            RELEASE_ID=$(echo "$RELEASE_JSON" | jq -r .id)
            if [ -z "$RELEASE_ID" ] || [ "$RELEASE_ID" = "null" ]; then
              echo "Release for tag '${{ github.ref_name }}' not found."
              exit 1
            fi
            echo "Uploading $SBOM_FILE to release id $RELEASE_ID"
            curl -s -X POST \
              -H "Authorization: token ${{ secrets.GH_PUBLISH_TOKEN }}" \
              -H "Content-Type: application/json" \
              --data-binary "@$SBOM_FILE" \
              "https://uploads.github.com/repos/${{ github.repository }}/releases/${RELEASE_ID}/assets?name=$(basename $SBOM_FILE)" || true
          else
            echo "GH_PUBLISH_TOKEN not present; uploading SBOM as workflow artifact instead"
            gh_version=$(gh --version 2>/dev/null || true)
            if [ -n "$gh_version" ]; then
              echo "gh CLI found, but we will still upload using actions/upload-artifact in CI as a fallback"
            fi
            # fallback: keep sbom in workspace and rely on release assets uploaded elsewhere
          fi
