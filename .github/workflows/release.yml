name: Release

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch: {}

permissions:
  contents: read

env:
  GO_VERSION: '1.24.9'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  release:
    permissions:
      contents: write
      packages: write
      id-token: write
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@1af3b93b6815bc44a9784bd300feb67ff0d1eeb3 # v6.0.0
      - name: Set up Go
        uses: actions/setup-go@4dc6199c7b1a012772edbd06daecab0f50c9053c # v6.1.0
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true
      - name: Generate manifests
        run: |
          make manifests
          tar -czf manifests-${{ github.ref_name }}.tgz config/crd/bases
      - name: Upload manifests artifact
        uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4 # v5.0.0
        with:
          name: manifests
          path: manifests-${{ github.ref_name }}.tgz
      - name: Login to GHCR
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3.6.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Set up QEMU
        uses: docker/setup-qemu-action@c7c53464625b32c7a7e944ae62b3e17d2b600130 # v3.7.0
      - name: Set up Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3.11.1
        with:
          install: true
      - name: Docker meta
        id: meta
        uses: docker/metadata-action@c299e40c65443455700f0fdfc63efafe5b349051 # v5.10.0
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=${{ github.ref_name }}
            type=raw,value=latest
          labels: |
            org.opencontainers.image.title=Kubernetes Breakglass
            org.opencontainers.image.description=Secure, auditable privilege escalation system for Kubernetes clusters with real-time webhook integration and time-bounded access
            org.opencontainers.image.url=https://github.com/telekom/k8s-breakglass
            org.opencontainers.image.documentation=https://github.com/telekom/k8s-breakglass/tree/main/docs
            org.opencontainers.image.source=https://github.com/telekom/k8s-breakglass
            org.opencontainers.image.licenses=Apache-2.0
            org.opencontainers.image.vendor=Deutsche Telekom
            org.opencontainers.image.version=${{ github.ref_name }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}
            com.github.repo.branch=${{ github.ref_name }}
            com.github.repo.owner=${{ github.repository_owner }}
            com.buildkit.build.ref=${{ github.ref }}
      - name: Build & Push Image
        id: build
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 # v6.18.0
        with:
          context: .
          push: true
          platforms: linux/amd64,linux/arm64
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      - name: Tag and push image to Artifactory OCI
        env:
          ARTIFACTORY_URL: artifactory.devops.telekom.de
          ARTIFACTORY_REPO: cit-t-caas-oci/images/t-caas
        run: |
          set -e
          # docker CLI login using environment secrets
          echo "Logging in to Artifactory OCI at ${ARTIFACTORY_URL}"
          echo "${{ secrets.AF_TOKEN }}" | docker login --username ${{ secrets.AF_USER }} --password-stdin https://${ARTIFACTORY_URL}
          echo "Docker login status: $(docker info --format '{{json .}}' 2>/dev/null || echo 'docker info not available')"
          # Diagnose Artifactory repo accessibility
          REPO_KEY=$(echo "${ARTIFACTORY_REPO}" | cut -d'/' -f1)
          echo "Checking Artifactory storage API for repo key: ${REPO_KEY}"
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -u "${{ secrets.AF_USER }}:${{ secrets.AF_TOKEN }}" "https://${ARTIFACTORY_URL}/artifactory/api/storage/${REPO_KEY}" ) || true
          echo "Artifactory storage API HTTP status: ${HTTP_STATUS}"
          if [ "${HTTP_STATUS}" != "200" ]; then
            echo "Warning: Artifactory repo ${REPO_KEY} not accessible (HTTP ${HTTP_STATUS}). Ensure AF_USER/AF_TOKEN are valid and have deploy permissions."
          fi
          # Retrieve tag list from docker metadata output and push each tag with Artifactory repo prefix
          IMAGE=${{ env.IMAGE_NAME }}
          # meta.tags contains comma separated tags from docker/metadata-action; we will push the main tag (ref_name)
          TAG=${{ github.ref_name }}
          ART_IMG=${ARTIFACTORY_URL}/${ARTIFACTORY_REPO}/${IMAGE}:${TAG}
          echo "Tagging ${REGISTRY}/${IMAGE}:${TAG} -> ${ART_IMG}"
          set -x
          docker pull ${REGISTRY}/${IMAGE}:${TAG} || true
          docker tag ${REGISTRY}/${IMAGE}:${TAG} ${ART_IMG}
          docker push ${ART_IMG} || (echo "docker push failed"; exit 1)
          set +x
          # Small wait for Artifactory to index
          sleep 3
          # Check whether the pushed image path exists in Artifactory storage (best-effort)
          CHECK_PATH=$(echo "${ARTIFACTORY_REPO}/${IMAGE}" | sed 's@//*@/@g')
          echo "Checking storage for path: ${CHECK_PATH}"
          HTTP_STATUS_AFTER=$(curl -s -o /dev/null -w "%{http_code}" -u "${{ secrets.AF_USER }}:${{ secrets.AF_TOKEN }}" "https://${ARTIFACTORY_URL}/artifactory/api/storage/${CHECK_PATH}?list" ) || true
          echo "Artifactory storage API HTTP status for pushed path: ${HTTP_STATUS_AFTER}"
          if [ "${HTTP_STATUS_AFTER}" = "200" ]; then
            echo "Artifact path appears present in Artifactory."
          else
            echo "Artifact path not found or not accessible (HTTP ${HTTP_STATUS_AFTER}). It might be a permission issue or Artifactory indexing delay."
          fi
      - name: Create GitHub Release
        uses: softprops/action-gh-release@5be0e66d93ac7ed76da52eca8bb058f665c3a5fe # v2.4.2
        with:
          files: |
            manifests-${{ github.ref_name }}.tgz
          generate_release_notes: true
      - name: Generate SBOM (Syft)
        uses: anchore/sbom-action@fbfd9c6c189226748411491745178e0c2017392d # v0.20.10
        if: ${{ false }}
        with:
          image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.ref_name }}
          format: spdx-json
          artifact-name: sbom-${{ github.ref_name }}.json
      - name: Upload SBOM to Release (if GH_PUBLISH_TOKEN)
        if: ${{ false }}
        run: |
          SBOM_FILE=sbom-${{ github.ref_name }}.json
          if [ -n "${{ secrets.GH_PUBLISH_TOKEN }}" ]; then
            echo "Using GH_PUBLISH_TOKEN to attach SBOM to release"
            RELEASE_JSON=$(curl -s -H "Authorization: token ${{ secrets.GH_PUBLISH_TOKEN }}" "https://api.github.com/repos/${{ github.repository }}/releases/tags/${{ github.ref_name }}")
            RELEASE_ID=$(echo "$RELEASE_JSON" | jq -r .id)
            if [ -z "$RELEASE_ID" ] || [ "$RELEASE_ID" = "null" ]; then
              echo "Release for tag '${{ github.ref_name }}' not found."
              exit 1
            fi
            echo "Uploading $SBOM_FILE to release id $RELEASE_ID"
            curl -s -X POST \
              -H "Authorization: token ${{ secrets.GH_PUBLISH_TOKEN }}" \
              -H "Content-Type: application/json" \
              --data-binary "@$SBOM_FILE" \
              "https://uploads.github.com/repos/${{ github.repository }}/releases/${RELEASE_ID}/assets?name=$(basename $SBOM_FILE)" || true
          else
            echo "GH_PUBLISH_TOKEN not present; uploading SBOM as workflow artifact instead"
            gh_version=$(gh --version 2>/dev/null || true)
            if [ -n "$gh_version" ]; then
              echo "gh CLI found, but we will still upload using actions/upload-artifact in CI as a fallback"
            fi
            # fallback: keep sbom in workspace and rely on release assets uploaded elsewhere
          fi
      - name: Attest provenance (skipped temporarily)
        # Temporarily disabled because ACTIONS_ID_TOKEN_REQUEST_URL isn't available in some runners
        # Re-enable by removing or changing the `if` condition when the environment supports id-token requests.
        if: ${{ false }}
        uses: actions/attest-build-provenance@977bb373ede98d70efdf65b84cb5f73e068dcc2a # v3.0.0
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          subject-digest: ${{ steps.build.outputs.digest }}
          push-to-registry: true
