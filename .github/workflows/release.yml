name: Release

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch: {}

permissions:
  contents: read

env:
  GO_VERSION: '1.25.5'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # ---------------------------------------------------------------------------
  # Build release manifests and bgctl CLI binaries
  # ---------------------------------------------------------------------------
  prepare:
    permissions:
      contents: read
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
      - name: Set up Go
        uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5 # v6.2.0
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true
      - name: Generate manifests
        run: |
          make manifests
          make kustomize

          # Set the correct image tag for this release
          VERSION=${{ github.ref_name }}
          cd config/deployment
          ../../bin/kustomize edit set image breakglass=ghcr.io/telekom/k8s-breakglass:${VERSION}
          cd ../..

          # Build complete deployment manifests for each target
          ./bin/kustomize build config/base > manifests-base.yaml
          ./bin/kustomize build config/debug > manifests-debug.yaml
          # Create CRDs-only manifest
          ./bin/kustomize build config/crd > manifests-crds.yaml

          # Verify image tag is correct in output
          echo "Verifying image tags in manifests..."
          grep -o "ghcr.io/telekom/k8s-breakglass:${VERSION}" manifests-base.yaml || { echo "ERROR: Image tag not set correctly"; exit 1; }

          # Package everything
          tar -czf manifests-${{ github.ref_name }}.tgz \
            config/crd/bases \
            manifests-base.yaml \
            manifests-debug.yaml \
            manifests-crds.yaml
      - name: Upload manifests artifact
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: manifests
          path: |
            manifests-${{ github.ref_name }}.tgz
            manifests-base.yaml
            manifests-debug.yaml
            manifests-crds.yaml
      - name: Build bgctl release assets
        run: |
          set -e
          VERSION=${{ github.ref_name }}
          GIT_COMMIT=${{ github.sha }}
          BUILD_DATE=${{ github.event.head_commit.timestamp }}
          mkdir -p dist
          platforms="linux/amd64 linux/arm64 darwin/amd64 darwin/arm64 windows/amd64"
          for platform in $platforms; do
            os=${platform%/*}
            arch=${platform#*/}
            bin=bgctl
            ext=""
            if [ "$os" = "windows" ]; then
              ext=".exe"
            fi
            outdir="dist/bgctl_${os}_${arch}"
            mkdir -p "$outdir"
            GOOS=$os GOARCH=$arch CGO_ENABLED=0 go build -trimpath \
              -ldflags "-s -w -X github.com/telekom/k8s-breakglass/pkg/version.Version=$VERSION -X github.com/telekom/k8s-breakglass/pkg/version.GitCommit=$GIT_COMMIT -X github.com/telekom/k8s-breakglass/pkg/version.BuildDate=$BUILD_DATE" \
              -o "$outdir/$bin$ext" ./cmd/bgctl
            if [ "$os" = "windows" ]; then
              (cd dist && zip -r "bgctl_${os}_${arch}.zip" "bgctl_${os}_${arch}")
              (cd dist && shasum -a 256 "bgctl_${os}_${arch}.zip" > "bgctl_${os}_${arch}.zip.sha256")
            else
              (cd dist && tar -czf "bgctl_${os}_${arch}.tar.gz" "bgctl_${os}_${arch}")
              (cd dist && shasum -a 256 "bgctl_${os}_${arch}.tar.gz" > "bgctl_${os}_${arch}.tar.gz.sha256")
            fi
          done
          # Generate combined checksums file (only archive files, not directories)
          (cd dist && shasum -a 256 *.tar.gz *.zip > "bgctl_${VERSION}_checksums.txt")
      - name: Upload bgctl artifacts
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: bgctl-dist
          path: |
            dist/bgctl_*.tar.gz
            dist/bgctl_*.zip
            dist/bgctl_*.sha256
            dist/bgctl_${{ github.ref_name }}_checksums.txt

  # ---------------------------------------------------------------------------
  # Build per-architecture container images natively (no QEMU emulation)
  # ---------------------------------------------------------------------------
  build-image:
    permissions:
      contents: read
      packages: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: linux/amd64
            runner: ubuntu-latest
          - platform: linux/arm64
            # NOTE: ubuntu-24.04-arm is a GitHub-hosted larger runner with different billing.
            # See: https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners
            runner: ubuntu-24.04-arm
    runs-on: ${{ matrix.runner }}
    steps:
      - uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
      - name: Login to GHCR
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 # v3.7.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Set up Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3.12.0
      - name: Docker meta
        id: meta
        uses: docker/metadata-action@c299e40c65443455700f0fdfc63efafe5b349051 # v5.10.0
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          labels: |
            org.opencontainers.image.title=Kubernetes Breakglass
            org.opencontainers.image.description=Secure, auditable privilege escalation system for Kubernetes clusters with real-time webhook integration and time-bounded access
            org.opencontainers.image.url=https://github.com/telekom/k8s-breakglass
            org.opencontainers.image.documentation=https://github.com/telekom/k8s-breakglass/tree/main/docs
            org.opencontainers.image.source=https://github.com/telekom/k8s-breakglass
            org.opencontainers.image.licenses=Apache-2.0
            org.opencontainers.image.vendor=Deutsche Telekom
            org.opencontainers.image.version=${{ github.ref_name }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp || github.run_started_at }}
            com.github.repo.branch=${{ github.ref_name }}
            com.github.repo.owner=${{ github.repository_owner }}
            com.buildkit.build.ref=${{ github.ref }}
      - name: Build & push single-platform image (by digest)
        id: build
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 # v6.18.0
        with:
          context: .
          push: true
          # Push by digest only — no tag yet; tags are created in the assemble step
          platforms: ${{ matrix.platform }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            VERSION=${{ github.ref_name }}
            GIT_COMMIT=${{ github.sha }}
            BUILD_DATE=${{ github.event.head_commit.timestamp || github.run_started_at }}
          # BUILD_DATE: head_commit.timestamp is set for tag pushes; run_started_at
          # (always available) serves as fallback for workflow_dispatch triggers.
          outputs: type=image,name=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }},push-by-digest=true,name-canonical=true,push=true
      - name: Export digest
        id: set-digest
        run: |
          PLATFORM="${{ matrix.platform }}"
          ARCH_FULL=$(echo "${PLATFORM}" | tr '/' '-')  # e.g., linux-amd64 or linux-arm64
          ARCH_SHORT="${PLATFORM#*/}"  # e.g., amd64 or arm64
          if [ -z "${ARCH_SHORT}" ] || [ "${ARCH_SHORT}" = "${PLATFORM}" ]; then
            echo "Invalid platform format: '${PLATFORM}'. Expected '<os>/<arch>' (e.g., 'linux/amd64')." >&2
            exit 1
          fi
          DIGEST="${{ steps.build.outputs.digest }}"
          if [ -z "${DIGEST}" ]; then
            echo "Error: Build produced no digest for platform '${PLATFORM}' (arch=${ARCH_SHORT})." >&2
            exit 1
          fi
          echo "digest-${ARCH_SHORT}=${DIGEST}" >> "$GITHUB_OUTPUT"
          echo "artifact-name=digest-${ARCH_SHORT}" >> "$GITHUB_OUTPUT"
          echo "arch-full=${ARCH_FULL}" >> "$GITHUB_OUTPUT"
          # Also persist to a file artifact so the assemble job can collect all digests
          mkdir -p /tmp/digests
          echo "${DIGEST}" > "/tmp/digests/${ARCH_FULL}"
      - name: Upload digest
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: ${{ steps.set-digest.outputs.artifact-name }}
          path: /tmp/digests/${{ steps.set-digest.outputs.arch-full }}

  # ---------------------------------------------------------------------------
  # Assemble per-arch images into a single multi-arch manifest and tag it
  # ---------------------------------------------------------------------------
  assemble:
    needs: [build-image]
    permissions:
      packages: write
    runs-on: ubuntu-latest
    outputs:
      digest: ${{ steps.inspect.outputs.digest }}
    steps:
      - name: Download all digests
        uses: actions/download-artifact@95815c38cf2ff2164869cbab79da8d1f422bc89e # v4.2.1
        with:
          pattern: digest-*
          merge-multiple: true
          path: /tmp/digests
      - name: Login to GHCR
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 # v3.7.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Set up Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3.12.0
      - name: Docker meta
        id: meta
        uses: docker/metadata-action@c299e40c65443455700f0fdfc63efafe5b349051 # v5.10.0
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=${{ github.ref_name }}
            type=raw,value=latest,enable=${{ startsWith(github.ref, 'refs/tags/') }}
      - name: Create and push multi-arch manifest
        env:
          REGISTRY: ${{ env.REGISTRY }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
        run: |
          set -euo pipefail

          # Verify digest files exist
          if [ -z "$(ls -A /tmp/digests 2>/dev/null)" ]; then
            echo "Error: No digest files found in /tmp/digests. Artifact download may have failed." >&2
            exit 1
          fi

          # Verify all expected platform digests are present
          for expected in linux-amd64 linux-arm64; do
            if [ ! -f "/tmp/digests/${expected}" ]; then
              echo "Error: Missing digest for platform ${expected}. Cannot assemble incomplete multi-arch manifest." >&2
              exit 1
            fi
          done

          # Display discovered digest files for diagnostics
          echo "Digest files found:"
          ls -la /tmp/digests/

          # Collect per-arch digests into an array
          DIGESTS=()
          for f in /tmp/digests/*; do
            d=$(cat "$f")
            echo "  $(basename "$f"): ${d}"
            DIGESTS+=("${REGISTRY}/${IMAGE_NAME}@${d}")
          done
          echo "Assembling multi-arch manifest from ${#DIGESTS[@]} platform(s): ${DIGESTS[*]}"

          # Build the --tag flags from metadata into an array
          TAGS=()
          while IFS= read -r tag; do
            # Skip empty lines that can result from trailing newlines
            [ -z "${tag}" ] && continue
            TAGS+=("--tag" "$tag")
          done <<< "${{ steps.meta.outputs.tags }}"

          # Ensure we have at least one tag
          if [ ${#TAGS[@]} -eq 0 ]; then
            echo "Error: No tags were generated from docker/metadata-action; aborting multi-arch manifest creation." >&2
            exit 1
          fi

          # Create and push the multi-arch manifest list
          docker buildx imagetools create "${TAGS[@]}" "${DIGESTS[@]}"
      - name: Inspect final image
        id: inspect
        run: |
          set -euo pipefail
          IMG="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.ref_name }}"
          docker buildx imagetools inspect "${IMG}"
          DIGEST=$(docker buildx imagetools inspect "${IMG}" --format '{{.Manifest.Digest}}')
          echo "digest=${DIGEST}" >> "$GITHUB_OUTPUT"
          echo "Multi-arch manifest digest: ${DIGEST}"
      - name: Attest provenance (skipped temporarily)
        # TODO: Re-enable when id-token is available in all runners.
        # When re-enabling:
        #   1. Add `id-token: write` to the assemble job permissions
        #   2. Update docs/release-process.md to note provenance attestation is active
        # Note: docs/release-process.md currently lists provenance as a goal;
        # it is not yet enforced until this step is re-enabled.
        if: ${{ false }}
        uses: actions/attest-build-provenance@96278af6caaf10aea03fd8d33a09a777ca52d62f # v3.2.0
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          subject-digest: ${{ steps.inspect.outputs.digest }}
          push-to-registry: true

  # ---------------------------------------------------------------------------
  # Push multi-arch image to Artifactory OCI mirror
  # ---------------------------------------------------------------------------
  artifactory:
    needs: [assemble]
    permissions:
      packages: read
    runs-on: ubuntu-latest
    steps:
      - name: Login to GHCR
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 # v3.7.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Set up Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3.12.0
      - name: Tag and push image to Artifactory OCI
        env:
          ARTIFACTORY_URL: artifactory.devops.telekom.de
          ARTIFACTORY_REPO: cit-t-caas-oci/images/t-caas
          REGISTRY: ${{ env.REGISTRY }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
        run: |
          set -euo pipefail
          # docker CLI login using environment secrets
          echo "Logging in to Artifactory OCI at ${ARTIFACTORY_URL}"
          echo "${{ secrets.AF_TOKEN }}" | docker login --username ${{ secrets.AF_USER }} --password-stdin https://${ARTIFACTORY_URL}

          # Diagnose Artifactory repo accessibility
          REPO_KEY=$(echo "${ARTIFACTORY_REPO}" | cut -d'/' -f1)
          echo "Checking Artifactory storage API for repo key: ${REPO_KEY}"
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -u "${{ secrets.AF_USER }}:${{ secrets.AF_TOKEN }}" "https://${ARTIFACTORY_URL}/artifactory/api/storage/${REPO_KEY}" ) || true
          echo "Artifactory storage API HTTP status: ${HTTP_STATUS}"
          if [ "${HTTP_STATUS}" != "200" ]; then
            echo "Warning: Artifactory repo ${REPO_KEY} not accessible (HTTP ${HTTP_STATUS}). Ensure AF_USER/AF_TOKEN are valid and have deploy permissions."
          fi

          IMAGE=${{ env.IMAGE_NAME }}
          TAG=${{ github.ref_name }}
          SRC=${REGISTRY}/${IMAGE}:${TAG}
          DST=${ARTIFACTORY_URL}/${ARTIFACTORY_REPO}/${IMAGE}:${TAG}

          echo "Copying multi-arch manifest ${SRC} -> ${DST}"

          # Use buildx imagetools to copy the full multi-arch manifest (all platforms)
          docker buildx imagetools create --tag "${DST}" "${SRC}"

          # Verify the pushed image is indexed in Artifactory (retry with backoff)
          CHECK_PATH=$(echo "${ARTIFACTORY_REPO}/${IMAGE}" | sed 's@//*@/@g')
          echo "Checking storage for path: ${CHECK_PATH}"
          for attempt in 1 2 3; do
            sleep $((attempt * 2))
            HTTP_STATUS_AFTER=$(curl -s -o /dev/null -w "%{http_code}" -u "${{ secrets.AF_USER }}:${{ secrets.AF_TOKEN }}" "https://${ARTIFACTORY_URL}/artifactory/api/storage/${CHECK_PATH}?list" ) || true
            echo "Attempt ${attempt}: HTTP status ${HTTP_STATUS_AFTER}"
            if [ "${HTTP_STATUS_AFTER}" = "200" ]; then
              echo "Artifact path appears present in Artifactory."
              break
            fi
          done
          if [ "${HTTP_STATUS_AFTER}" != "200" ]; then
            echo "Warning: Artifact path not confirmed after retries (HTTP ${HTTP_STATUS_AFTER}). It might be a permission issue or Artifactory indexing delay."
          fi

  # ---------------------------------------------------------------------------
  # Create GitHub Release with manifests, bgctl binaries, and SBOM
  # ---------------------------------------------------------------------------
  release:
    # NOTE: Does not depend on `artifactory` intentionally — Artifactory is a
    # best-effort mirror and should not block GitHub Release creation.
    needs: [prepare, assemble]
    permissions:
      contents: write
      packages: read
    runs-on: ubuntu-latest
    steps:
      - name: Download manifests
        uses: actions/download-artifact@95815c38cf2ff2164869cbab79da8d1f422bc89e # v4.2.1
        with:
          name: manifests
          path: .
      - name: Download bgctl dist
        uses: actions/download-artifact@95815c38cf2ff2164869cbab79da8d1f422bc89e # v4.2.1
        with:
          name: bgctl-dist
          path: dist
      - name: Create GitHub Release
        uses: softprops/action-gh-release@a06a81a03ee405af7f2048a818ed3f03bbf83c7b # v2.5.0
        with:
          files: |
            manifests-${{ github.ref_name }}.tgz
            manifests-base.yaml
            manifests-debug.yaml
            manifests-crds.yaml
            dist/bgctl_*.tar.gz
            dist/bgctl_*.zip
            dist/bgctl_*.sha256
            dist/bgctl_${{ github.ref_name }}_checksums.txt
          generate_release_notes: true
      - name: Generate SBOM (Syft)
        uses: anchore/sbom-action@28d71544de8eaf1b958d335707167c5f783590ad # v0.22.2
        if: ${{ false }}
        with:
          image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.ref_name }}
          format: spdx-json
          artifact-name: sbom-${{ github.ref_name }}.json
      - name: Upload SBOM to Release (if GH_PUBLISH_TOKEN)
        if: ${{ false }}
        run: |
          SBOM_FILE=sbom-${{ github.ref_name }}.json
          if [ -n "${{ secrets.GH_PUBLISH_TOKEN }}" ]; then
            echo "Using GH_PUBLISH_TOKEN to attach SBOM to release"
            RELEASE_JSON=$(curl -s -H "Authorization: token ${{ secrets.GH_PUBLISH_TOKEN }}" "https://api.github.com/repos/${{ github.repository }}/releases/tags/${{ github.ref_name }}")
            RELEASE_ID=$(echo "$RELEASE_JSON" | jq -r .id)
            if [ -z "$RELEASE_ID" ] || [ "$RELEASE_ID" = "null" ]; then
              echo "Release for tag '${{ github.ref_name }}' not found."
              exit 1
            fi
            echo "Uploading $SBOM_FILE to release id $RELEASE_ID"
            curl -s -X POST \
              -H "Authorization: token ${{ secrets.GH_PUBLISH_TOKEN }}" \
              -H "Content-Type: application/json" \
              --data-binary "@$SBOM_FILE" \
              "https://uploads.github.com/repos/${{ github.repository }}/releases/${RELEASE_ID}/assets?name=$(basename $SBOM_FILE)" || true
          else
            echo "GH_PUBLISH_TOKEN not present; uploading SBOM as workflow artifact instead"
            gh_version=$(gh --version 2>/dev/null || true)
            if [ -n "$gh_version" ]; then
              echo "gh CLI found, but we will still upload using actions/upload-artifact in CI as a fallback"
            fi
            # fallback: keep sbom in workspace and rely on release assets uploaded elsewhere
          fi
