/*
Copyright 2026.

Here we can add license
*/

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

// PodSecurityExemptionsApplyConfiguration represents a declarative configuration of the PodSecurityExemptions type for use
// with apply.
//
// PodSecurityExemptions defines pods that should skip security evaluation.
type PodSecurityExemptionsApplyConfiguration struct {
	// namespaces to skip evaluation for.
	// Supports pattern matching (glob-style) and label-based namespace selection.
	// Common exemptions: kube-system, monitoring, logging
	Namespaces *NamespaceFilterApplyConfiguration `json:"namespaces,omitempty"`
	// podLabels: pods with ALL specified labels are exempt.
	// Example: {"breakglass.telekom.com/security-exempt": "true"}
	PodLabels map[string]string `json:"podLabels,omitempty"`
}

// PodSecurityExemptionsApplyConfiguration constructs a declarative configuration of the PodSecurityExemptions type for use with
// apply.
func PodSecurityExemptions() *PodSecurityExemptionsApplyConfiguration {
	return &PodSecurityExemptionsApplyConfiguration{}
}

// WithNamespaces sets the Namespaces field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Namespaces field is set to the value of the last call.
func (b *PodSecurityExemptionsApplyConfiguration) WithNamespaces(value *NamespaceFilterApplyConfiguration) *PodSecurityExemptionsApplyConfiguration {
	b.Namespaces = value
	return b
}

// WithPodLabels puts the entries into the PodLabels field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the PodLabels field,
// overwriting an existing map entries in PodLabels field with the same key.
func (b *PodSecurityExemptionsApplyConfiguration) WithPodLabels(entries map[string]string) *PodSecurityExemptionsApplyConfiguration {
	if b.PodLabels == nil && len(entries) > 0 {
		b.PodLabels = make(map[string]string, len(entries))
	}
	for k, v := range entries {
		b.PodLabels[k] = v
	}
	return b
}
