/*
SPDX-FileCopyrightText: 2025-2026 Deutsche Telekom AG

SPDX-License-Identifier: Apache-2.0
*/

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	v1 "k8s.io/api/core/v1"
)

// SchedulingConstraintsApplyConfiguration represents a declarative configuration of the SchedulingConstraints type for use
// with apply.
//
// SchedulingConstraints defines mandatory scheduling rules for debug pods.
// These constraints are applied AFTER template/user settings and CANNOT be overridden.
type SchedulingConstraintsApplyConfiguration struct {
	// requiredNodeAffinity specifies hard node affinity requirements.
	// Merged with template's affinity using AND logic.
	RequiredNodeAffinity *v1.NodeSelector `json:"requiredNodeAffinity,omitempty"`
	// preferredNodeAffinity specifies soft node affinity preferences.
	// Added to template's preferred affinities.
	PreferredNodeAffinity []v1.PreferredSchedulingTerm `json:"preferredNodeAffinity,omitempty"`
	// requiredPodAntiAffinity specifies hard pod anti-affinity rules.
	// Ensures debug pods don't co-locate inappropriately.
	RequiredPodAntiAffinity []v1.PodAffinityTerm `json:"requiredPodAntiAffinity,omitempty"`
	// preferredPodAntiAffinity specifies soft pod anti-affinity preferences.
	PreferredPodAntiAffinity []v1.WeightedPodAffinityTerm `json:"preferredPodAntiAffinity,omitempty"`
	// nodeSelector adds mandatory node labels for scheduling.
	// Merged with template's nodeSelector (constraints take precedence on conflicts).
	NodeSelector map[string]string `json:"nodeSelector,omitempty"`
	// tolerations adds tolerations for debug pods.
	// Merged with template's tolerations.
	Tolerations []v1.Toleration `json:"tolerations,omitempty"`
	// topologySpreadConstraints controls how debug pods are spread.
	TopologySpreadConstraints []v1.TopologySpreadConstraint `json:"topologySpreadConstraints,omitempty"`
	// deniedNodes is a list of node name patterns that MUST NOT run debug pods.
	// Evaluated as glob patterns.
	DeniedNodes []string `json:"deniedNodes,omitempty"`
	// deniedNodeLabels blocks nodes with any of these labels.
	// Key-value pairs where value can be "*" for any value.
	DeniedNodeLabels map[string]string `json:"deniedNodeLabels,omitempty"`
}

// SchedulingConstraintsApplyConfiguration constructs a declarative configuration of the SchedulingConstraints type for use with
// apply.
func SchedulingConstraints() *SchedulingConstraintsApplyConfiguration {
	return &SchedulingConstraintsApplyConfiguration{}
}

// WithRequiredNodeAffinity sets the RequiredNodeAffinity field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the RequiredNodeAffinity field is set to the value of the last call.
func (b *SchedulingConstraintsApplyConfiguration) WithRequiredNodeAffinity(value v1.NodeSelector) *SchedulingConstraintsApplyConfiguration {
	b.RequiredNodeAffinity = &value
	return b
}

// WithPreferredNodeAffinity adds the given value to the PreferredNodeAffinity field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the PreferredNodeAffinity field.
func (b *SchedulingConstraintsApplyConfiguration) WithPreferredNodeAffinity(values ...v1.PreferredSchedulingTerm) *SchedulingConstraintsApplyConfiguration {
	for i := range values {
		b.PreferredNodeAffinity = append(b.PreferredNodeAffinity, values[i])
	}
	return b
}

// WithRequiredPodAntiAffinity adds the given value to the RequiredPodAntiAffinity field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the RequiredPodAntiAffinity field.
func (b *SchedulingConstraintsApplyConfiguration) WithRequiredPodAntiAffinity(values ...v1.PodAffinityTerm) *SchedulingConstraintsApplyConfiguration {
	for i := range values {
		b.RequiredPodAntiAffinity = append(b.RequiredPodAntiAffinity, values[i])
	}
	return b
}

// WithPreferredPodAntiAffinity adds the given value to the PreferredPodAntiAffinity field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the PreferredPodAntiAffinity field.
func (b *SchedulingConstraintsApplyConfiguration) WithPreferredPodAntiAffinity(values ...v1.WeightedPodAffinityTerm) *SchedulingConstraintsApplyConfiguration {
	for i := range values {
		b.PreferredPodAntiAffinity = append(b.PreferredPodAntiAffinity, values[i])
	}
	return b
}

// WithNodeSelector puts the entries into the NodeSelector field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the NodeSelector field,
// overwriting an existing map entries in NodeSelector field with the same key.
func (b *SchedulingConstraintsApplyConfiguration) WithNodeSelector(entries map[string]string) *SchedulingConstraintsApplyConfiguration {
	if b.NodeSelector == nil && len(entries) > 0 {
		b.NodeSelector = make(map[string]string, len(entries))
	}
	for k, v := range entries {
		b.NodeSelector[k] = v
	}
	return b
}

// WithTolerations adds the given value to the Tolerations field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the Tolerations field.
func (b *SchedulingConstraintsApplyConfiguration) WithTolerations(values ...v1.Toleration) *SchedulingConstraintsApplyConfiguration {
	for i := range values {
		b.Tolerations = append(b.Tolerations, values[i])
	}
	return b
}

// WithTopologySpreadConstraints adds the given value to the TopologySpreadConstraints field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the TopologySpreadConstraints field.
func (b *SchedulingConstraintsApplyConfiguration) WithTopologySpreadConstraints(values ...v1.TopologySpreadConstraint) *SchedulingConstraintsApplyConfiguration {
	for i := range values {
		b.TopologySpreadConstraints = append(b.TopologySpreadConstraints, values[i])
	}
	return b
}

// WithDeniedNodes adds the given value to the DeniedNodes field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the DeniedNodes field.
func (b *SchedulingConstraintsApplyConfiguration) WithDeniedNodes(values ...string) *SchedulingConstraintsApplyConfiguration {
	for i := range values {
		b.DeniedNodes = append(b.DeniedNodes, values[i])
	}
	return b
}

// WithDeniedNodeLabels puts the entries into the DeniedNodeLabels field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the DeniedNodeLabels field,
// overwriting an existing map entries in DeniedNodeLabels field with the same key.
func (b *SchedulingConstraintsApplyConfiguration) WithDeniedNodeLabels(entries map[string]string) *SchedulingConstraintsApplyConfiguration {
	if b.DeniedNodeLabels == nil && len(entries) > 0 {
		b.DeniedNodeLabels = make(map[string]string, len(entries))
	}
	for k, v := range entries {
		b.DeniedNodeLabels[k] = v
	}
	return b
}
