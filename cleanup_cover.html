
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>breakglass: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/telekom/k8s-breakglass/pkg/breakglass/api_metrics.go (0.0%)</option>
				
				<option value="file1">github.com/telekom/k8s-breakglass/pkg/breakglass/auxiliary_resource_manager.go (0.0%)</option>
				
				<option value="file2">github.com/telekom/k8s-breakglass/pkg/breakglass/cleanup_duplicate_sessions.go (87.3%)</option>
				
				<option value="file3">github.com/telekom/k8s-breakglass/pkg/breakglass/cleanup_task.go (4.3%)</option>
				
				<option value="file4">github.com/telekom/k8s-breakglass/pkg/breakglass/cluster_binding_api.go (0.0%)</option>
				
				<option value="file5">github.com/telekom/k8s-breakglass/pkg/breakglass/cluster_config_checker.go (0.0%)</option>
				
				<option value="file6">github.com/telekom/k8s-breakglass/pkg/breakglass/cluster_config_manager.go (0.0%)</option>
				
				<option value="file7">github.com/telekom/k8s-breakglass/pkg/breakglass/clusteruser.go (0.0%)</option>
				
				<option value="file8">github.com/telekom/k8s-breakglass/pkg/breakglass/debug_session_api.go (0.0%)</option>
				
				<option value="file9">github.com/telekom/k8s-breakglass/pkg/breakglass/debug_session_kubectl.go (0.0%)</option>
				
				<option value="file10">github.com/telekom/k8s-breakglass/pkg/breakglass/debug_session_reconciler.go (0.0%)</option>
				
				<option value="file11">github.com/telekom/k8s-breakglass/pkg/breakglass/duration_helpers.go (15.8%)</option>
				
				<option value="file12">github.com/telekom/k8s-breakglass/pkg/breakglass/escalation.go (0.0%)</option>
				
				<option value="file13">github.com/telekom/k8s-breakglass/pkg/breakglass/escalation_controller.go (0.0%)</option>
				
				<option value="file14">github.com/telekom/k8s-breakglass/pkg/breakglass/escalation_manager.go (0.0%)</option>
				
				<option value="file15">github.com/telekom/k8s-breakglass/pkg/breakglass/escalation_status_updater.go (0.0%)</option>
				
				<option value="file16">github.com/telekom/k8s-breakglass/pkg/breakglass/event_recorder.go (0.0%)</option>
				
				<option value="file17">github.com/telekom/k8s-breakglass/pkg/breakglass/expire_approved_sessions.go (0.0%)</option>
				
				<option value="file18">github.com/telekom/k8s-breakglass/pkg/breakglass/expire_pending_sessions.go (0.0%)</option>
				
				<option value="file19">github.com/telekom/k8s-breakglass/pkg/breakglass/group_checker.go (0.0%)</option>
				
				<option value="file20">github.com/telekom/k8s-breakglass/pkg/breakglass/identity_provider.go (0.0%)</option>
				
				<option value="file21">github.com/telekom/k8s-breakglass/pkg/breakglass/scheduled_activation.go (0.0%)</option>
				
				<option value="file22">github.com/telekom/k8s-breakglass/pkg/breakglass/scheme.go (100.0%)</option>
				
				<option value="file23">github.com/telekom/k8s-breakglass/pkg/breakglass/session_approval_timeout.go (0.0%)</option>
				
				<option value="file24">github.com/telekom/k8s-breakglass/pkg/breakglass/session_controller.go (0.0%)</option>
				
				<option value="file25">github.com/telekom/k8s-breakglass/pkg/breakglass/session_manager.go (16.2%)</option>
				
				<option value="file26">github.com/telekom/k8s-breakglass/pkg/breakglass/ssa.go (22.2%)</option>
				
				<option value="file27">github.com/telekom/k8s-breakglass/pkg/breakglass/template_renderer.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package breakglass

import (
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/telekom/k8s-breakglass/pkg/metrics"
)

// instrumentedHandler wraps a gin handler to record API metrics consistently.
// It tracks request counts, latency, and error status codes for the provided endpoint label.
func instrumentedHandler(endpoint string, handler gin.HandlerFunc) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()
                metrics.APIEndpointRequests.WithLabelValues(endpoint).Inc()
                handler(c)
                metrics.APIEndpointDuration.WithLabelValues(endpoint).Observe(time.Since(start).Seconds())
                status := c.Writer.Status()
                if status &gt;= 400 </span><span class="cov0" title="0">{
                        metrics.APIEndpointErrors.WithLabelValues(endpoint, strconv.Itoa(status)).Inc()
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright 2026.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package breakglass

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "strings"
        "text/template"
        "time"

        "github.com/Masterminds/sprig/v3"
        "github.com/telekom/k8s-breakglass/api/v1alpha1"
        "github.com/telekom/k8s-breakglass/pkg/audit"
        "github.com/telekom/k8s-breakglass/pkg/metrics"
        "github.com/telekom/k8s-breakglass/pkg/utils"
        "go.uber.org/zap"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/yaml"
)

// AuxiliaryResourceManager handles rendering, deploying, and cleaning up auxiliary resources.
type AuxiliaryResourceManager struct {
        log              *zap.SugaredLogger
        client           client.Client
        auditManager     *audit.Manager
        readinessChecker *utils.ReadinessChecker
}

// NewAuxiliaryResourceManager creates a new auxiliary resource manager.
func NewAuxiliaryResourceManager(log *zap.SugaredLogger, cli client.Client) *AuxiliaryResourceManager <span class="cov0" title="0">{
        return &amp;AuxiliaryResourceManager{
                log:              log.Named("auxiliary-resources"),
                client:           cli,
                readinessChecker: utils.NewReadinessChecker(log),
        }
}</span>

// SetAuditManager sets the audit manager for emitting audit events.
func (m *AuxiliaryResourceManager) SetAuditManager(am *audit.Manager) <span class="cov0" title="0">{
        m.auditManager = am
}</span>

// DeployAuxiliaryResources deploys all enabled auxiliary resources for a session.
// Returns the list of deployed resource statuses.
func (m *AuxiliaryResourceManager) DeployAuxiliaryResources(
        ctx context.Context,
        session *v1alpha1.DebugSession,
        template *v1alpha1.DebugSessionTemplateSpec,
        binding *v1alpha1.DebugSessionClusterBinding,
        targetClient client.Client,
        targetNamespace string,
) ([]v1alpha1.AuxiliaryResourceStatus, error) <span class="cov0" title="0">{
        if template == nil || len(template.AuxiliaryResources) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">log := m.log.With("session", session.Name, "namespace", session.Namespace)
        log.Info("Deploying auxiliary resources", "count", len(template.AuxiliaryResources))

        // Determine which resources are enabled
        enabledResources := m.filterEnabledResources(template, binding, session.Spec.SelectedAuxiliaryResources)

        // Build context for template rendering (including enabled resources list)
        renderCtx := m.buildRenderContext(session, template, binding, targetNamespace, enabledResources)

        var statuses []v1alpha1.AuxiliaryResourceStatus
        var deployErrors []error

        // Deploy resources that should be created before debug pods
        for _, auxRes := range enabledResources </span><span class="cov0" title="0">{
                if !auxRes.CreateBefore </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">status, err := m.deployResource(ctx, targetClient, targetNamespace, auxRes, renderCtx, session)
                statuses = append(statuses, status)

                if err != nil </span><span class="cov0" title="0">{
                        log.Warnw("Failed to deploy auxiliary resource",
                                "resource", auxRes.Name,
                                "category", auxRes.Category,
                                "error", err)
                        deployErrors = append(deployErrors, err)

                        if auxRes.FailurePolicy == v1alpha1.AuxiliaryResourceFailurePolicyFail </span><span class="cov0" title="0">{
                                metrics.AuxiliaryResourceDeployments.WithLabelValues(session.Spec.Cluster, auxRes.Category, "failure").Inc()
                                return statuses, fmt.Errorf("failed to deploy required auxiliary resource %s: %w", auxRes.Name, err)
                        }</span>
                        <span class="cov0" title="0">metrics.AuxiliaryResourceDeployments.WithLabelValues(session.Spec.Cluster, auxRes.Category, "ignored").Inc()</span>
                } else<span class="cov0" title="0"> {
                        metrics.AuxiliaryResourceDeployments.WithLabelValues(session.Spec.Cluster, auxRes.Category, "success").Inc()
                }</span>
        }

        <span class="cov0" title="0">log.Infow("Auxiliary resources deployed",
                "total", len(enabledResources),
                "deployed", len(statuses),
                "errors", len(deployErrors))

        return statuses, nil</span>
}

// CleanupAuxiliaryResources removes all auxiliary resources created for a session.
func (m *AuxiliaryResourceManager) CleanupAuxiliaryResources(
        ctx context.Context,
        session *v1alpha1.DebugSession,
        targetClient client.Client,
) error <span class="cov0" title="0">{
        if len(session.Status.AuxiliaryResourceStatuses) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">log := m.log.With("session", session.Name, "namespace", session.Namespace)
        log.Info("Cleaning up auxiliary resources", "count", len(session.Status.AuxiliaryResourceStatuses))

        var cleanupErrors []error

        for i, status := range session.Status.AuxiliaryResourceStatuses </span><span class="cov0" title="0">{
                if !status.Created || status.Deleted </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Delete the primary resource
                <span class="cov0" title="0">err := m.deleteResource(ctx, targetClient, status, session)
                if err != nil </span><span class="cov0" title="0">{
                        log.Warnw("Failed to delete auxiliary resource",
                                "resource", status.Name,
                                "resourceName", status.ResourceName,
                                "namespace", status.Namespace,
                                "error", err)
                        cleanupErrors = append(cleanupErrors, err)
                        session.Status.AuxiliaryResourceStatuses[i].Error = err.Error()
                }</span> else<span class="cov0" title="0"> {
                        now := time.Now().UTC().Format(time.RFC3339)
                        session.Status.AuxiliaryResourceStatuses[i].Deleted = true
                        session.Status.AuxiliaryResourceStatuses[i].DeletedAt = &amp;now
                        metrics.AuxiliaryResourceCleanups.WithLabelValues(session.Spec.Cluster, status.Category, "success").Inc()
                }</span>

                // Also delete any additional resources from multi-document YAML templates
                <span class="cov0" title="0">for j, addlRes := range status.AdditionalResources </span><span class="cov0" title="0">{
                        if addlRes.Deleted </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">addlStatus := v1alpha1.AuxiliaryResourceStatus{
                                Name:         status.Name,
                                Category:     status.Category,
                                Kind:         addlRes.Kind,
                                APIVersion:   addlRes.APIVersion,
                                ResourceName: addlRes.ResourceName,
                                Namespace:    addlRes.Namespace,
                        }

                        err := m.deleteResource(ctx, targetClient, addlStatus, session)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Warnw("Failed to delete additional auxiliary resource",
                                        "resource", status.Name,
                                        "kind", addlRes.Kind,
                                        "resourceName", addlRes.ResourceName,
                                        "namespace", addlRes.Namespace,
                                        "error", err)
                                cleanupErrors = append(cleanupErrors, err)
                                session.Status.AuxiliaryResourceStatuses[i].AdditionalResources[j].Error = err.Error()
                        }</span> else<span class="cov0" title="0"> {
                                session.Status.AuxiliaryResourceStatuses[i].AdditionalResources[j].Deleted = true
                                metrics.AuxiliaryResourceCleanups.WithLabelValues(session.Spec.Cluster, status.Category, "success").Inc()
                        }</span>
                }
        }

        <span class="cov0" title="0">if len(cleanupErrors) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup %d auxiliary resources", len(cleanupErrors))
        }</span>

        <span class="cov0" title="0">log.Info("All auxiliary resources cleaned up")
        return nil</span>
}

// filterEnabledResources determines which auxiliary resources should be deployed.
func (m *AuxiliaryResourceManager) filterEnabledResources(
        template *v1alpha1.DebugSessionTemplateSpec,
        binding *v1alpha1.DebugSessionClusterBinding,
        selectedByUser []string,
) []v1alpha1.AuxiliaryResource <span class="cov0" title="0">{
        if template == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Build maps for efficient lookup
        <span class="cov0" title="0">defaultEnabled := make(map[string]bool)
        for name, enabled := range template.AuxiliaryResourceDefaults </span><span class="cov0" title="0">{
                defaultEnabled[name] = enabled
        }</span>

        // Categories that are always required
        <span class="cov0" title="0">requiredCategories := make(map[string]bool)
        for _, cat := range template.RequiredAuxiliaryResourceCategories </span><span class="cov0" title="0">{
                requiredCategories[cat] = true
        }</span>

        // Binding can add required categories but not remove them
        <span class="cov0" title="0">if binding != nil </span><span class="cov0" title="0">{
                for _, cat := range binding.Spec.RequiredAuxiliaryResourceCategories </span><span class="cov0" title="0">{
                        requiredCategories[cat] = true
                }</span>
        }

        // Binding overrides
        <span class="cov0" title="0">bindingOverrides := make(map[string]bool)
        if binding != nil </span><span class="cov0" title="0">{
                for cat, enabled := range binding.Spec.AuxiliaryResourceOverrides </span><span class="cov0" title="0">{
                        // Cannot disable required categories
                        if !enabled &amp;&amp; requiredCategories[cat] </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">bindingOverrides[cat] = enabled</span>
                }
        }

        // User selection
        <span class="cov0" title="0">userSelected := make(map[string]bool)
        for _, name := range selectedByUser </span><span class="cov0" title="0">{
                userSelected[name] = true
        }</span>

        <span class="cov0" title="0">var enabled []v1alpha1.AuxiliaryResource
        for _, res := range template.AuxiliaryResources </span><span class="cov0" title="0">{
                // Check if category is required
                if requiredCategories[res.Category] </span><span class="cov0" title="0">{
                        enabled = append(enabled, res)
                        continue</span>
                }

                // Check binding override
                <span class="cov0" title="0">if override, ok := bindingOverrides[res.Category]; ok </span><span class="cov0" title="0">{
                        if override </span><span class="cov0" title="0">{
                                enabled = append(enabled, res)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // Check if user selected
                <span class="cov0" title="0">if userSelected[res.Name] </span><span class="cov0" title="0">{
                        enabled = append(enabled, res)
                        continue</span>
                }

                // Check default
                <span class="cov0" title="0">if defaultEnabled[res.Name] </span><span class="cov0" title="0">{
                        enabled = append(enabled, res)
                }</span>
        }

        <span class="cov0" title="0">return enabled</span>
}

// buildRenderContext creates the context used for template rendering.
func (m *AuxiliaryResourceManager) buildRenderContext(
        session *v1alpha1.DebugSession,
        template *v1alpha1.DebugSessionTemplateSpec,
        binding *v1alpha1.DebugSessionClusterBinding,
        targetNamespace string,
        enabledResources []v1alpha1.AuxiliaryResource,
) v1alpha1.AuxiliaryResourceContext <span class="cov0" title="0">{
        ctx := v1alpha1.AuxiliaryResourceContext{
                Session: v1alpha1.AuxiliaryResourceSessionContext{
                        Name:        session.Name,
                        Namespace:   session.Namespace,
                        Cluster:     session.Spec.Cluster,
                        RequestedBy: session.Spec.RequestedBy,
                        Reason:      session.Spec.Reason,
                },
                Target: v1alpha1.AuxiliaryResourceTargetContext{
                        Namespace:   targetNamespace,
                        ClusterName: session.Spec.Cluster,
                },
                Labels: map[string]string{
                        "app.kubernetes.io/managed-by":                  "breakglass",
                        "breakglass.t-caas.telekom.com/session":         session.Name,
                        "breakglass.t-caas.telekom.com/session-cluster": session.Spec.Cluster,
                },
                Annotations: map[string]string{
                        "breakglass.t-caas.telekom.com/created-by": session.Spec.RequestedBy,
                },
                Now: time.Now().UTC().Format(time.RFC3339),
        }

        if session.Status.Approval != nil </span><span class="cov0" title="0">{
                ctx.Session.ApprovedBy = session.Status.Approval.ApprovedBy
        }</span>

        <span class="cov0" title="0">if session.Status.ExpiresAt != nil </span><span class="cov0" title="0">{
                ctx.Session.ExpiresAt = session.Status.ExpiresAt.Format(time.RFC3339)
        }</span>

        <span class="cov0" title="0">if template != nil </span><span class="cov0" title="0">{
                ctx.Template = v1alpha1.AuxiliaryResourceTemplateContext{
                        Name:        session.Spec.TemplateRef,
                        DisplayName: template.DisplayName,
                }
        }</span>

        <span class="cov0" title="0">if binding != nil </span><span class="cov0" title="0">{
                ctx.Binding = v1alpha1.AuxiliaryResourceBindingContext{
                        Name:      binding.Name,
                        Namespace: binding.Namespace,
                }
        }</span>

        // Build list of enabled resource names
        <span class="cov0" title="0">ctx.EnabledResources = make([]string, 0, len(enabledResources))
        for _, res := range enabledResources </span><span class="cov0" title="0">{
                ctx.EnabledResources = append(ctx.EnabledResources, res.Name)
        }</span>

        // Populate Vars from session's extraDeployValues
        <span class="cov0" title="0">ctx.Vars = m.buildVarsFromSession(session, template)

        return ctx</span>
}

// buildVarsFromSession extracts user-provided variable values from session spec
// and applies defaults from template definition.
func (m *AuxiliaryResourceManager) buildVarsFromSession(
        session *v1alpha1.DebugSession,
        template *v1alpha1.DebugSessionTemplateSpec,
) map[string]string <span class="cov0" title="0">{
        vars := make(map[string]string)

        // Apply defaults from template variable definitions
        if template != nil </span><span class="cov0" title="0">{
                for _, varDef := range template.ExtraDeployVariables </span><span class="cov0" title="0">{
                        if varDef.Default != nil &amp;&amp; len(varDef.Default.Raw) &gt; 0 </span><span class="cov0" title="0">{
                                // Extract default value from JSON
                                defaultVal := extractJSONValue(varDef.Default.Raw)
                                vars[varDef.Name] = defaultVal
                        }</span>
                }
        }

        // Override with user-provided values from session
        <span class="cov0" title="0">for name, jsonVal := range session.Spec.ExtraDeployValues </span><span class="cov0" title="0">{
                vars[name] = extractJSONValue(jsonVal.Raw)
        }</span>

        <span class="cov0" title="0">return vars</span>
}

// extractJSONValue extracts a string representation from raw JSON.
// Handles strings, numbers, booleans, and arrays.
func extractJSONValue(raw []byte) string <span class="cov0" title="0">{
        if len(raw) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Try to unmarshal as string first (most common case)
        <span class="cov0" title="0">var strVal string
        if err := json.Unmarshal(raw, &amp;strVal); err == nil </span><span class="cov0" title="0">{
                return strVal
        }</span>

        // Try as boolean
        <span class="cov0" title="0">var boolVal bool
        if err := json.Unmarshal(raw, &amp;boolVal); err == nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("%t", boolVal)
        }</span>

        // Try as number (float64)
        <span class="cov0" title="0">var numVal float64
        if err := json.Unmarshal(raw, &amp;numVal); err == nil </span><span class="cov0" title="0">{
                // Format without trailing zeros for integers
                if numVal == float64(int64(numVal)) </span><span class="cov0" title="0">{
                        return fmt.Sprintf("%d", int64(numVal))
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%g", numVal)</span>
        }

        // Try as string array (for multiSelect)
        <span class="cov0" title="0">var arrVal []string
        if err := json.Unmarshal(raw, &amp;arrVal); err == nil </span><span class="cov0" title="0">{
                return strings.Join(arrVal, ",")
        }</span>

        // Fall back to raw string
        <span class="cov0" title="0">return string(raw)</span>
}

// deployResource renders and deploys a single auxiliary resource.
// If templateString is used, it may produce multiple K8s resources (multi-doc YAML).
// Returns statuses for all created resources.
func (m *AuxiliaryResourceManager) deployResource(
        ctx context.Context,
        targetClient client.Client,
        targetNamespace string,
        auxRes v1alpha1.AuxiliaryResource,
        renderCtx v1alpha1.AuxiliaryResourceContext,
        session *v1alpha1.DebugSession,
) (v1alpha1.AuxiliaryResourceStatus, error) <span class="cov0" title="0">{
        status := v1alpha1.AuxiliaryResourceStatus{
                Name:     auxRes.Name,
                Category: auxRes.Category,
        }

        // Determine which template source to use
        var renderedDocuments [][]byte
        var err error

        if auxRes.TemplateString != "" </span><span class="cov0" title="0">{
                // Use templateString with multi-document support
                renderer := NewTemplateRenderer()
                renderedDocuments, err = renderer.RenderMultiDocumentTemplate(auxRes.TemplateString, renderCtx)
                if err != nil </span><span class="cov0" title="0">{
                        status.Error = fmt.Sprintf("template rendering failed: %v", err)
                        return status, fmt.Errorf("failed to render templateString for %s: %w", auxRes.Name, err)
                }</span>
        } else<span class="cov0" title="0"> if len(auxRes.Template.Raw) &gt; 0 </span><span class="cov0" title="0">{
                // Use legacy template field with Raw bytes (single document)
                renderedYAML, err := m.renderTemplate(auxRes.Template.Raw, renderCtx)
                if err != nil </span><span class="cov0" title="0">{
                        status.Error = fmt.Sprintf("template rendering failed: %v", err)
                        return status, fmt.Errorf("failed to render template for %s: %w", auxRes.Name, err)
                }</span>
                <span class="cov0" title="0">renderedDocuments = [][]byte{renderedYAML}</span>
        } else<span class="cov0" title="0"> if auxRes.Template.Object != nil </span><span class="cov0" title="0">{
                // Use legacy template field with Object (serialize to YAML first)
                templateBytes, err := json.Marshal(auxRes.Template.Object)
                if err != nil </span><span class="cov0" title="0">{
                        status.Error = fmt.Sprintf("failed to marshal template object: %v", err)
                        return status, fmt.Errorf("failed to marshal template object for %s: %w", auxRes.Name, err)
                }</span>
                <span class="cov0" title="0">renderedYAML, err := m.renderTemplate(templateBytes, renderCtx)
                if err != nil </span><span class="cov0" title="0">{
                        status.Error = fmt.Sprintf("template rendering failed: %v", err)
                        return status, fmt.Errorf("failed to render template for %s: %w", auxRes.Name, err)
                }</span>
                <span class="cov0" title="0">renderedDocuments = [][]byte{renderedYAML}</span>
        } else<span class="cov0" title="0"> {
                status.Error = "no template defined (neither templateString nor template)"
                return status, fmt.Errorf("auxiliary resource %s has no template defined", auxRes.Name)
        }</span>

        // Filter out empty documents (from conditional rendering)
        <span class="cov0" title="0">var nonEmptyDocs [][]byte
        for _, doc := range renderedDocuments </span><span class="cov0" title="0">{
                trimmed := strings.TrimSpace(string(doc))
                if trimmed != "" </span><span class="cov0" title="0">{
                        nonEmptyDocs = append(nonEmptyDocs, doc)
                }</span>
        }

        // If all documents are empty (conditional rendering excluded everything), return success
        <span class="cov0" title="0">if len(nonEmptyDocs) == 0 </span><span class="cov0" title="0">{
                m.log.Debugw("Auxiliary resource produced no documents (conditional exclusion)",
                        "name", auxRes.Name)
                return status, nil
        }</span>

        // Deploy each document
        <span class="cov0" title="0">var deployedResources []string
        for i, docYAML := range nonEmptyDocs </span><span class="cov0" title="0">{
                obj := &amp;unstructured.Unstructured{}
                if err := yaml.Unmarshal(docYAML, &amp;obj.Object); err != nil </span><span class="cov0" title="0">{
                        status.Error = fmt.Sprintf("YAML parsing failed for document %d: %v", i+1, err)
                        return status, fmt.Errorf("failed to parse rendered YAML for %s (doc %d): %w", auxRes.Name, i+1, err)
                }</span>

                // Set namespace if not specified
                <span class="cov0" title="0">if obj.GetNamespace() == "" </span><span class="cov0" title="0">{
                        obj.SetNamespace(targetNamespace)
                }</span>

                // Apply standard labels
                <span class="cov0" title="0">labels := obj.GetLabels()
                if labels == nil </span><span class="cov0" title="0">{
                        labels = make(map[string]string)
                }</span>
                <span class="cov0" title="0">for k, v := range renderCtx.Labels </span><span class="cov0" title="0">{
                        labels[k] = v
                }</span>
                <span class="cov0" title="0">labels["breakglass.t-caas.telekom.com/auxiliary-resource"] = auxRes.Name
                obj.SetLabels(labels)

                // Apply standard annotations
                annotations := obj.GetAnnotations()
                if annotations == nil </span><span class="cov0" title="0">{
                        annotations = make(map[string]string)
                }</span>
                <span class="cov0" title="0">for k, v := range renderCtx.Annotations </span><span class="cov0" title="0">{
                        annotations[k] = v
                }</span>
                <span class="cov0" title="0">annotations["breakglass.t-caas.telekom.com/source-session"] = fmt.Sprintf("%s/%s", session.Namespace, session.Name)
                obj.SetAnnotations(annotations)

                // Deploy the resource using Server-Side Apply (SSA) for idempotency.
                // SSA will create or update the resource, handling existing resources automatically.
                // Note: We use our own field owner and force ownership to take over any existing resources.
                obj.SetManagedFields(nil)
                if err := utils.ApplyUnstructured(ctx, targetClient, obj); err != nil </span><span class="cov0" title="0">{
                        status.Error = fmt.Sprintf("SSA apply failed for %s/%s: %v", obj.GetKind(), obj.GetName(), err)
                        return status, fmt.Errorf("failed to apply resource %s/%s: %w", obj.GetKind(), obj.GetName(), err)
                }</span>

                <span class="cov0" title="0">deployedResources = append(deployedResources, fmt.Sprintf("%s/%s", obj.GetKind(), obj.GetName()))

                m.log.Infow("Deployed auxiliary resource document",
                        "auxiliaryResource", auxRes.Name,
                        "kind", obj.GetKind(),
                        "name", obj.GetName(),
                        "namespace", obj.GetNamespace())

                // Emit audit event
                if m.auditManager != nil </span><span class="cov0" title="0">{
                        m.auditManager.DebugSessionResourceDeployed(
                                ctx,
                                session.Name,
                                session.Namespace,
                                session.Spec.Cluster,
                                obj.GetKind(),
                                obj.GetName(),
                                obj.GetNamespace(),
                        )
                }</span>

                // Track resource metadata: first document in main fields, additional docs in AdditionalResources
                <span class="cov0" title="0">if i == 0 </span><span class="cov0" title="0">{
                        status.Kind = obj.GetKind()
                        status.APIVersion = obj.GetAPIVersion()
                        status.ResourceName = obj.GetName()
                        status.Namespace = obj.GetNamespace()
                }</span> else<span class="cov0" title="0"> {
                        // Track additional resources from multi-document YAML
                        status.AdditionalResources = append(status.AdditionalResources, v1alpha1.AdditionalResourceRef{
                                Kind:         obj.GetKind(),
                                APIVersion:   obj.GetAPIVersion(),
                                ResourceName: obj.GetName(),
                                Namespace:    obj.GetNamespace(),
                        })
                }</span>
        }

        <span class="cov0" title="0">status.Created = true
        now := time.Now().UTC().Format(time.RFC3339)
        status.CreatedAt = &amp;now

        if len(deployedResources) &gt; 1 </span><span class="cov0" title="0">{
                m.log.Infow("Deployed multiple resources from single auxiliary resource",
                        "name", auxRes.Name,
                        "resources", deployedResources)
        }</span>

        <span class="cov0" title="0">return status, nil</span>
}

// renderTemplate renders a Go template with the given context.
func (m *AuxiliaryResourceManager) renderTemplate(templateBytes []byte, ctx v1alpha1.AuxiliaryResourceContext) ([]byte, error) <span class="cov0" title="0">{
        // Convert context to map for template
        ctxMap, err := toMap(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert context: %w", err)
        }</span>

        // Parse template with sprig functions
        <span class="cov0" title="0">tmpl, err := template.New("auxiliary").Funcs(sprig.FuncMap()).Parse(string(templateBytes))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse template: %w", err)
        }</span>

        // Execute template
        <span class="cov0" title="0">var buf bytes.Buffer
        if err := tmpl.Execute(&amp;buf, ctxMap); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute template: %w", err)
        }</span>

        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

// toMap converts a struct to a map using JSON marshaling.
func toMap(v interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        data, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var result map[string]interface{}
        if err := json.Unmarshal(data, &amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// deleteResource deletes a single auxiliary resource.
func (m *AuxiliaryResourceManager) deleteResource(
        ctx context.Context,
        targetClient client.Client,
        status v1alpha1.AuxiliaryResourceStatus,
        session *v1alpha1.DebugSession,
) error <span class="cov0" title="0">{
        // Create unstructured object for deletion
        obj := &amp;unstructured.Unstructured{}
        obj.SetAPIVersion(status.APIVersion)
        obj.SetKind(status.Kind)
        obj.SetName(status.ResourceName)
        obj.SetNamespace(status.Namespace)

        // Delete the resource
        if err := targetClient.Delete(ctx, obj); err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        // Already deleted, that's fine
                        m.log.Debugw("Auxiliary resource already deleted",
                                "name", status.Name,
                                "resourceName", status.ResourceName)
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to delete %s/%s: %w", status.Kind, status.ResourceName, err)</span>
        }

        <span class="cov0" title="0">m.log.Infow("Deleted auxiliary resource",
                "name", status.Name,
                "kind", status.Kind,
                "resourceName", status.ResourceName,
                "namespace", status.Namespace)

        // Emit audit event for resource cleanup
        if m.auditManager != nil </span><span class="cov0" title="0">{
                m.auditManager.DebugSessionResourceCleanup(
                        ctx,
                        session.Name,
                        session.Namespace,
                        session.Spec.Cluster,
                        status.Kind,
                        status.ResourceName,
                        status.Namespace,
                )
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateAuxiliaryResources validates all auxiliary resources in a template.
func ValidateAuxiliaryResources(resources []v1alpha1.AuxiliaryResource) []error <span class="cov0" title="0">{
        var errs []error
        seenNames := make(map[string]bool)
        seenCategories := make(map[string][]string) // category -&gt; resource names

        for i, res := range resources </span><span class="cov0" title="0">{
                // Check name uniqueness
                if seenNames[res.Name] </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("auxiliaryResources[%d]: duplicate name %q", i, res.Name))
                }</span>
                <span class="cov0" title="0">seenNames[res.Name] = true

                // Track categories
                seenCategories[res.Category] = append(seenCategories[res.Category], res.Name)

                // Validate required fields
                if res.Name == "" </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("auxiliaryResources[%d]: name is required", i))
                }</span>

                // Must have either template or templateString
                // Note: Template can have Raw bytes or Object set (runtime.RawExtension)
                <span class="cov0" title="0">hasTemplate := len(res.Template.Raw) &gt; 0 || res.Template.Object != nil
                hasTemplateString := res.TemplateString != ""

                if !hasTemplate &amp;&amp; !hasTemplateString </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("auxiliaryResources[%d]: either template or templateString is required", i))
                }</span>

                <span class="cov0" title="0">if hasTemplate &amp;&amp; hasTemplateString </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("auxiliaryResources[%d]: template and templateString are mutually exclusive", i))
                }</span>

                // Validate templateString is valid Go template
                <span class="cov0" title="0">if hasTemplateString </span><span class="cov0" title="0">{
                        renderer := NewTemplateRenderer()
                        // Use sample context for validation
                        sampleCtx := v1alpha1.AuxiliaryResourceContext{
                                Session: v1alpha1.AuxiliaryResourceSessionContext{
                                        Name:        "validation-session",
                                        Namespace:   "breakglass-system",
                                        Cluster:     "validation-cluster",
                                        RequestedBy: "validator@example.com",
                                },
                                Target: v1alpha1.AuxiliaryResourceTargetContext{
                                        Namespace:   "breakglass-debug",
                                        ClusterName: "validation-cluster",
                                },
                                Labels:           map[string]string{"app.kubernetes.io/managed-by": "breakglass"},
                                Annotations:      map[string]string{},
                                Vars:             map[string]string{},
                                Now:              time.Now().UTC().Format(time.RFC3339),
                                EnabledResources: []string{},
                        }
                        if err := renderer.ValidateTemplate(res.TemplateString, sampleCtx); err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Errorf("auxiliaryResources[%d]: invalid templateString: %w", i, err))
                        }</span>
                }

                // Validate legacy template is valid YAML
                <span class="cov0" title="0">if hasTemplate </span><span class="cov0" title="0">{
                        var obj map[string]interface{}
                        var templateBytes []byte

                        if len(res.Template.Raw) &gt; 0 </span><span class="cov0" title="0">{
                                templateBytes = res.Template.Raw
                        }</span> else<span class="cov0" title="0"> if res.Template.Object != nil </span><span class="cov0" title="0">{
                                // Marshal Object to get bytes for validation
                                var err error
                                templateBytes, err = json.Marshal(res.Template.Object)
                                if err != nil </span><span class="cov0" title="0">{
                                        errs = append(errs, fmt.Errorf("auxiliaryResources[%d]: failed to marshal template object: %w", i, err))
                                        continue</span>
                                }
                        }

                        <span class="cov0" title="0">if err := yaml.Unmarshal(templateBytes, &amp;obj); err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Errorf("auxiliaryResources[%d]: invalid YAML template: %w", i, err))
                        }</span> else<span class="cov0" title="0"> {
                                // Check for apiVersion and kind
                                if _, ok := obj["apiVersion"]; !ok </span><span class="cov0" title="0">{
                                        errs = append(errs, fmt.Errorf("auxiliaryResources[%d]: template missing apiVersion", i))
                                }</span>
                                <span class="cov0" title="0">if _, ok := obj["kind"]; !ok </span><span class="cov0" title="0">{
                                        errs = append(errs, fmt.Errorf("auxiliaryResources[%d]: template missing kind", i))
                                }</span>
                        }
                }

                // Validate failure policy
                <span class="cov0" title="0">switch res.FailurePolicy </span>{
                case "", v1alpha1.AuxiliaryResourceFailurePolicyFail,
                        v1alpha1.AuxiliaryResourceFailurePolicyIgnore,
                        v1alpha1.AuxiliaryResourceFailurePolicyWarn:<span class="cov0" title="0"></span>
                        // Valid
                default:<span class="cov0" title="0">
                        errs = append(errs, fmt.Errorf("auxiliaryResources[%d]: invalid failurePolicy %q", i, res.FailurePolicy))</span>
                }
        }

        <span class="cov0" title="0">return errs</span>
}

// AddAuxiliaryResourceToDeployedResources tracks an auxiliary resource in the session's deployed resources.
// This includes the primary resource and any additional resources from multi-document YAML templates.
func AddAuxiliaryResourceToDeployedResources(
        session *v1alpha1.DebugSession,
        status v1alpha1.AuxiliaryResourceStatus,
) <span class="cov0" title="0">{
        if !status.Created </span><span class="cov0" title="0">{
                return
        }</span>

        // Helper to add a ref if not already present
        <span class="cov0" title="0">addRef := func(ref v1alpha1.DeployedResourceRef) </span><span class="cov0" title="0">{
                for _, existing := range session.Status.DeployedResources </span><span class="cov0" title="0">{
                        if existing.Kind == ref.Kind &amp;&amp;
                                existing.Name == ref.Name &amp;&amp;
                                existing.Namespace == ref.Namespace </span><span class="cov0" title="0">{
                                return // Already tracked
                        }</span>
                }
                <span class="cov0" title="0">session.Status.DeployedResources = append(session.Status.DeployedResources, ref)</span>
        }

        // Add primary resource
        <span class="cov0" title="0">addRef(v1alpha1.DeployedResourceRef{
                Kind:       status.Kind,
                APIVersion: status.APIVersion,
                Name:       status.ResourceName,
                Namespace:  status.Namespace,
                UID:        "", // UID populated later when we fetch the created resource
                Source:     fmt.Sprintf("auxiliary:%s", status.Name),
        })

        // Add additional resources from multi-document YAML templates
        for _, addlRes := range status.AdditionalResources </span><span class="cov0" title="0">{
                addRef(v1alpha1.DeployedResourceRef{
                        Kind:       addlRes.Kind,
                        APIVersion: addlRes.APIVersion,
                        Name:       addlRes.ResourceName,
                        Namespace:  addlRes.Namespace,
                        UID:        "",
                        Source:     fmt.Sprintf("auxiliary:%s", status.Name),
                })
        }</span>
}

// CheckAuxiliaryResourcesReadiness checks the readiness status of all auxiliary resources
// using kstatus and updates the session status accordingly.
func (m *AuxiliaryResourceManager) CheckAuxiliaryResourcesReadiness(
        ctx context.Context,
        session *v1alpha1.DebugSession,
        targetClient client.Client,
) (allReady bool, err error) <span class="cov0" title="0">{
        if len(session.Status.AuxiliaryResourceStatuses) == 0 </span><span class="cov0" title="0">{
                return true, nil
        }</span>

        <span class="cov0" title="0">log := m.log.With("session", session.Name, "namespace", session.Namespace)

        allReady = true
        for i, status := range session.Status.AuxiliaryResourceStatuses </span><span class="cov0" title="0">{
                // Skip if not created, already ready, or deleted
                if !status.Created || status.Ready || status.Deleted </span><span class="cov0" title="0">{
                        if status.Created &amp;&amp; !status.Ready &amp;&amp; !status.Deleted </span><span class="cov0" title="0">{
                                allReady = false
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // Check primary resource readiness
                <span class="cov0" title="0">primaryReady := m.checkSingleResourceReadiness(ctx, log, targetClient, status.APIVersion, status.Kind, status.ResourceName, status.Namespace)
                session.Status.AuxiliaryResourceStatuses[i].ReadinessStatus = primaryReady.readinessStatus
                if primaryReady.ready </span><span class="cov0" title="0">{
                        session.Status.AuxiliaryResourceStatuses[i].Ready = true
                        now := time.Now().UTC().Format(time.RFC3339)
                        session.Status.AuxiliaryResourceStatuses[i].ReadyAt = &amp;now
                        log.Infow("Auxiliary resource is ready",
                                "resource", status.Name,
                                "kind", status.Kind,
                                "name", status.ResourceName)
                }</span> else<span class="cov0" title="0"> if primaryReady.failed </span><span class="cov0" title="0">{
                        session.Status.AuxiliaryResourceStatuses[i].Error = primaryReady.message
                        log.Warnw("Auxiliary resource failed",
                                "resource", status.Name,
                                "kind", status.Kind,
                                "name", status.ResourceName,
                                "message", primaryReady.message)
                        allReady = false
                }</span> else<span class="cov0" title="0"> {
                        log.Debugw("Auxiliary resource not ready yet",
                                "resource", status.Name,
                                "kind", status.Kind,
                                "name", status.ResourceName,
                                "status", primaryReady.readinessStatus,
                                "message", primaryReady.message)
                        allReady = false
                }</span>

                // Check additional resources from multi-document YAML templates
                <span class="cov0" title="0">for j, addlRes := range status.AdditionalResources </span><span class="cov0" title="0">{
                        if addlRes.Ready || addlRes.Deleted </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">addlReady := m.checkSingleResourceReadiness(ctx, log, targetClient, addlRes.APIVersion, addlRes.Kind, addlRes.ResourceName, addlRes.Namespace)
                        session.Status.AuxiliaryResourceStatuses[i].AdditionalResources[j].ReadinessStatus = addlReady.readinessStatus

                        if addlReady.ready </span><span class="cov0" title="0">{
                                session.Status.AuxiliaryResourceStatuses[i].AdditionalResources[j].Ready = true
                                log.Infow("Additional auxiliary resource is ready",
                                        "resource", status.Name,
                                        "kind", addlRes.Kind,
                                        "name", addlRes.ResourceName)
                        }</span> else<span class="cov0" title="0"> if addlReady.failed </span><span class="cov0" title="0">{
                                session.Status.AuxiliaryResourceStatuses[i].AdditionalResources[j].Error = addlReady.message
                                log.Warnw("Additional auxiliary resource failed",
                                        "resource", status.Name,
                                        "kind", addlRes.Kind,
                                        "name", addlRes.ResourceName,
                                        "message", addlReady.message)
                                allReady = false
                        }</span> else<span class="cov0" title="0"> {
                                log.Debugw("Additional auxiliary resource not ready yet",
                                        "resource", status.Name,
                                        "kind", addlRes.Kind,
                                        "name", addlRes.ResourceName,
                                        "status", addlReady.readinessStatus)
                                allReady = false
                        }</span>
                }
        }

        <span class="cov0" title="0">return allReady, nil</span>
}

// readinessResult holds the result of a single resource readiness check.
type readinessResult struct {
        ready           bool
        failed          bool
        readinessStatus string
        message         string
}

// checkSingleResourceReadiness checks the readiness of a single resource using kstatus.
func (m *AuxiliaryResourceManager) checkSingleResourceReadiness(
        ctx context.Context,
        log *zap.SugaredLogger,
        targetClient client.Client,
        apiVersion, kind, name, namespace string,
) readinessResult <span class="cov0" title="0">{
        gvk, err := parseGVK(apiVersion, kind)
        if err != nil </span><span class="cov0" title="0">{
                log.Warnw("Failed to parse GVK for resource",
                        "apiVersion", apiVersion,
                        "kind", kind,
                        "error", err)
                return readinessResult{failed: true, message: fmt.Sprintf("invalid GVK: %v", err)}
        }</span>

        <span class="cov0" title="0">readiness := m.readinessChecker.CheckResourceReadiness(ctx, targetClient, gvk, name, namespace)

        return readinessResult{
                ready:           readiness.IsReady(),
                failed:          readiness.IsFailed(),
                readinessStatus: string(readiness.Status),
                message:         readiness.Message,
        }</span>
}

// parseGVK parses an apiVersion and kind into a GroupVersionKind.
func parseGVK(apiVersion, kind string) (schema.GroupVersionKind, error) <span class="cov0" title="0">{
        gv, err := schema.ParseGroupVersion(apiVersion)
        if err != nil </span><span class="cov0" title="0">{
                return schema.GroupVersionKind{}, err
        }</span>
        <span class="cov0" title="0">return gv.WithKind(kind), nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// SPDX-FileCopyrightText: 2025 Deutsche Telekom AG
//
// SPDX-License-Identifier: Apache-2.0

package breakglass

import (
        "context"
        "sort"

        v1alpha1 "github.com/telekom/k8s-breakglass/api/v1alpha1"
        "go.uber.org/zap"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// sessionStatePriority returns a numeric priority for a given session state.
// Higher values indicate higher priority when choosing which duplicate to keep.
func sessionStatePriority(state v1alpha1.BreakglassSessionState) int <span class="cov8" title="1">{
        switch state </span>{
        case v1alpha1.SessionStateApproved:<span class="cov8" title="1">
                return 3</span>
        case v1alpha1.SessionStateWaitingForScheduledTime:<span class="cov8" title="1">
                return 2</span>
        case v1alpha1.SessionStatePending:<span class="cov8" title="1">
                return 1</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}

// CleanupDuplicateSessions detects active sessions that share the same
// (cluster, user, grantedGroup) triple  which should be unique  and
// terminates the duplicates, keeping the best candidate alive.
//
// The survivor is chosen by state priority (Approved &gt; WaitingForScheduledTime
// &gt; Pending), then by CreationTimestamp (oldest first), with resource name as
// a deterministic tie-breaker.
//
// Duplicates can occur in multi-replica deployments due to TOCTOU race
// conditions in session creation (the in-flight guard is per-process).
// Running this during the periodic cleanup makes the system eventually
// consistent without hammering the API server.
func CleanupDuplicateSessions(ctx context.Context, log *zap.SugaredLogger, mgr *SessionManager) <span class="cov8" title="1">{
        if mgr == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if log == nil </span><span class="cov8" title="1">{
                log = zap.S()
        }</span>

        // Collect active sessions from all "in-flight" states.
        <span class="cov8" title="1">activeStates := []v1alpha1.BreakglassSessionState{
                v1alpha1.SessionStatePending,
                v1alpha1.SessionStateApproved,
                v1alpha1.SessionStateWaitingForScheduledTime,
        }

        var allActive []v1alpha1.BreakglassSession
        for _, state := range activeStates </span><span class="cov8" title="1">{
                sessions, err := mgr.GetSessionsByState(ctx, state)
                if err != nil </span><span class="cov0" title="0">{
                        log.Warnw("Failed to list sessions for duplicate cleanup", "state", state, "error", err)
                        continue</span>
                }
                <span class="cov8" title="1">allActive = append(allActive, sessions...)</span>
        }

        <span class="cov8" title="1">if len(allActive) &lt; 2 </span><span class="cov8" title="1">{
                return // need at least 2 for a duplicate
        }</span>

        // Group by the unique triple: cluster/user/grantedGroup
        <span class="cov8" title="1">type tripleKey struct {
                Cluster, User, Group string
        }
        groups := make(map[tripleKey][]v1alpha1.BreakglassSession)
        for _, s := range allActive </span><span class="cov8" title="1">{
                key := tripleKey{
                        Cluster: s.Spec.Cluster,
                        User:    s.Spec.User,
                        Group:   s.Spec.GrantedGroup,
                }
                groups[key] = append(groups[key], s)
        }</span>

        <span class="cov8" title="1">for key, sessions := range groups </span><span class="cov8" title="1">{
                if len(sessions) &lt; 2 </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Sort by state priority (Approved &gt; WaitingForScheduledTime &gt; Pending),
                // then by CreationTimestamp ascending (oldest first), and finally by name
                // as a deterministic tie-breaker.
                <span class="cov8" title="1">sort.Slice(sessions, func(i, j int) bool </span><span class="cov8" title="1">{
                        si := sessions[i]
                        sj := sessions[j]

                        pi := sessionStatePriority(si.Status.State)
                        pj := sessionStatePriority(sj.Status.State)
                        if pi != pj </span><span class="cov8" title="1">{
                                return pi &gt; pj
                        }</span>

                        <span class="cov8" title="1">if !si.CreationTimestamp.Equal(&amp;sj.CreationTimestamp) </span><span class="cov8" title="1">{
                                return si.CreationTimestamp.Before(&amp;sj.CreationTimestamp)
                        }</span>

                        <span class="cov0" title="0">return si.Name &lt; sj.Name</span>
                })

                // Keep the best candidate (sessions[0]), terminate the rest.
                <span class="cov8" title="1">log.Warnw("Duplicate active sessions detected  terminating duplicates",
                        "cluster", key.Cluster,
                        "user", key.User,
                        "grantedGroup", key.Group,
                        "keepSession", sessions[0].Name,
                        "duplicateCount", len(sessions)-1,
                )

                for _, dup := range sessions[1:] </span><span class="cov8" title="1">{
                        // Check if the context has been cancelled (e.g., leader election loss, shutdown).
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                log.Infow("Duplicate cleanup interrupted by context cancellation",
                                        "cluster", key.Cluster,
                                        "user", key.User,
                                        "grantedGroup", key.Group,
                                )
                                return</span>
                        default:<span class="cov8" title="1"></span>
                        }

                        <span class="cov8" title="1">log.Infow("Handling duplicate session",
                                "session", dup.Name,
                                "namespace", dup.Namespace,
                                "state", dup.Status.State,
                                "created", dup.CreationTimestamp.Time,
                        )

                        var (
                                targetState      v1alpha1.BreakglassSessionState
                                conditionType    v1alpha1.BreakglassSessionConditionType
                                conditionReason  string
                                conditionMessage string
                                reasonEnded      string
                        )

                        switch dup.Status.State </span>{
                        case v1alpha1.SessionStatePending, v1alpha1.SessionStateWaitingForScheduledTime:<span class="cov8" title="1">
                                // Pending/Waiting sessions must be withdrawn, not expired,
                                // to satisfy the webhook state machine.
                                targetState = v1alpha1.SessionStateWithdrawn
                                conditionType = v1alpha1.SessionConditionTypeCanceled
                                conditionReason = "DuplicateSessionWithdrawn"
                                conditionMessage = "Withdrawn by cleanup routine: duplicate session for the same cluster/user/group triple."
                                reasonEnded = "withdrawn"</span>
                        case v1alpha1.SessionStateApproved:<span class="cov8" title="1">
                                // Approved sessions can be directly expired.
                                targetState = v1alpha1.SessionStateExpired
                                conditionType = v1alpha1.SessionConditionTypeExpired
                                conditionReason = "DuplicateSessionTerminated"
                                conditionMessage = "Terminated by cleanup routine: duplicate session for the same cluster/user/group triple."
                                reasonEnded = "duplicateCleanup"</span>
                        default:<span class="cov0" title="0">
                                // For any other state, skip to avoid invalid state transitions.
                                log.Infow("Skipping duplicate session with non-terminatable state",
                                        "session", dup.Name,
                                        "namespace", dup.Namespace,
                                        "state", dup.Status.State,
                                )
                                continue</span>
                        }

                        // Capture a single "now" for consistent terminal metadata and condition timestamps.
                        <span class="cov8" title="1">now := metav1.Now()

                        // Populate terminal-state timestamps that the rest of the system expects.
                        if targetState == v1alpha1.SessionStateWithdrawn </span><span class="cov8" title="1">{
                                if dup.Status.WithdrawnAt.IsZero() </span><span class="cov8" title="1">{
                                        dup.Status.WithdrawnAt = now
                                }</span>
                        }
                        <span class="cov8" title="1">if targetState == v1alpha1.SessionStateExpired </span><span class="cov8" title="1">{
                                dup.Status.ExpiresAt = now
                        }</span>
                        // Set RetainedUntil so the cleanup routine can later garbage-collect the session.
                        <span class="cov8" title="1">if dup.Status.RetainedUntil.IsZero() </span><span class="cov8" title="1">{
                                retainFor := ParseRetainFor(dup.Spec, log)
                                dup.Status.RetainedUntil = metav1.NewTime(now.Time.Add(retainFor))
                        }</span>

                        <span class="cov8" title="1">dup.Status.State = targetState
                        dup.Status.ReasonEnded = reasonEnded
                        dup.SetCondition(metav1.Condition{
                                Type:               string(conditionType),
                                Status:             metav1.ConditionTrue,
                                LastTransitionTime: now,
                                Reason:             conditionReason,
                                Message:            conditionMessage,
                        })

                        if err := mgr.UpdateBreakglassSessionStatus(ctx, dup); err != nil </span><span class="cov0" title="0">{
                                log.Warnw("Failed to update duplicate session status", "session", dup.Name, "error", err)
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package breakglass

import (
        "context"
        "fmt"
        "os"
        "time"

        telekomv1alpha1 "github.com/telekom/k8s-breakglass/api/v1alpha1"
        "github.com/telekom/k8s-breakglass/pkg/audit"
        "github.com/telekom/k8s-breakglass/pkg/config"
        "github.com/telekom/k8s-breakglass/pkg/mail"
        "github.com/telekom/k8s-breakglass/pkg/metrics"
        "github.com/telekom/k8s-breakglass/pkg/system"
        "go.uber.org/zap"
)

const (
        // DefaultCleanupOperationTimeout is the timeout for cleanup operations to ensure
        // shutdown is predictable and we don't accumulate slow API calls
        DefaultCleanupOperationTimeout = 2 * time.Minute
)

type CleanupRoutine struct {
        Log           *zap.SugaredLogger
        Manager       *SessionManager
        AuditManager  *audit.Manager
        MailService   MailEnqueuer    // Mail service for sending expiration notifications
        BrandingName  string          // Branding name for email templates
        DisableEmail  bool            // Whether to disable email notifications
        LeaderElected &lt;-chan struct{} // Optional: signal when leadership acquired (nil = start immediately for backward compatibility)
}

// CleanupInterval is the interval between cleanup routine runs.
// Can be configured via CLEANUP_INTERVAL environment variable (default: 5m).
// Use shorter intervals for testing (e.g., 10s for E2E tests).
var CleanupInterval = getCleanupInterval()

func getCleanupInterval() time.Duration <span class="cov8" title="1">{
        if envInterval := os.Getenv("CLEANUP_INTERVAL"); envInterval != "" </span><span class="cov0" title="0">{
                if d, err := time.ParseDuration(envInterval); err == nil </span><span class="cov0" title="0">{
                        return d
                }</span>
        }
        <span class="cov8" title="1">return 5 * time.Minute</span>
}

// DebugSessionRetentionPeriod defines how long terminated/expired debug sessions are kept
// for audit purposes before being deleted. This can be configured via environment variable
// DEBUG_SESSION_RETENTION_PERIOD (default: 168h = 7 days)
var DebugSessionRetentionPeriod = getDebugSessionRetentionPeriod()

func getDebugSessionRetentionPeriod() time.Duration <span class="cov8" title="1">{
        const defaultRetention = 168 * time.Hour // 7 days
        if env := os.Getenv("DEBUG_SESSION_RETENTION_PERIOD"); env != "" </span><span class="cov0" title="0">{
                if d, err := time.ParseDuration(env); err == nil </span><span class="cov0" title="0">{
                        return d
                }</span>
        }
        <span class="cov8" title="1">return defaultRetention</span>
}

// DebugSessionApprovalTimeout defines how long a debug session can wait in pending approval
// state before being automatically failed. This can be configured via environment variable
// DEBUG_SESSION_APPROVAL_TIMEOUT (default: 24h)
var DebugSessionApprovalTimeout = getDebugSessionApprovalTimeout()

func getDebugSessionApprovalTimeout() time.Duration <span class="cov8" title="1">{
        const defaultTimeout = 24 * time.Hour
        if env := os.Getenv("DEBUG_SESSION_APPROVAL_TIMEOUT"); env != "" </span><span class="cov0" title="0">{
                if d, err := time.ParseDuration(env); err == nil </span><span class="cov0" title="0">{
                        return d
                }</span>
        }
        <span class="cov8" title="1">return defaultTimeout</span>
}

func (cr CleanupRoutine) CleanupRoutine(ctx context.Context) <span class="cov0" title="0">{
        // Wait for leadership signal if provided (enables multi-replica scaling with leader election)
        if cr.LeaderElected != nil </span><span class="cov0" title="0">{
                cr.Log.Info("Cleanup routine waiting for leadership signal before starting...")
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        cr.Log.Infow("Cert-controller's manager stopping before acquiring leadership (context cancelled)")
                        return</span>
                case &lt;-cr.LeaderElected:<span class="cov0" title="0">
                        cr.Log.Info("Leadership acquired - starting cleanup routine")</span>
                }
        }

        // run initial cleanup
        <span class="cov0" title="0">cr.clean(ctx)

        // Use time.NewTicker instead of time.Tick to avoid memory leak.
        // time.Tick creates a ticker that is never garbage collected.
        ticker := time.NewTicker(CleanupInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        cr.Log.Warnw("cleanup routine stopped (context cancelled)")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        cr.clean(ctx)</span>
                }
        }
}

func (cr CleanupRoutine) clean(ctx context.Context) <span class="cov0" title="0">{
        cr.Log.Info("Running breakglass session cleanup task")
        // Activate scheduled sessions first (before expiry checks)
        if cr.Manager != nil </span><span class="cov0" title="0">{
                activator := NewScheduledSessionActivator(cr.Log, cr.Manager).
                        WithMailService(cr.MailService, cr.BrandingName, cr.DisableEmail)
                activator.ActivateScheduledSessions()

                ctrl := &amp;BreakglassSessionController{
                        log:            cr.Log,
                        sessionManager: cr.Manager,
                        mailService:    cr.MailService,
                        disableEmail:   cr.DisableEmail,
                        config:         config.Config{Frontend: config.Frontend{BrandingName: cr.BrandingName}},
                }
                ctrl.ExpirePendingSessions()
                // Expire approved sessions whose ExpiresAt has passed
                ctrl.ExpireApprovedSessions()
        }</span>

        <span class="cov0" title="0">cleanupCtx := ctx
        if cleanupCtx == nil </span><span class="cov0" title="0">{
                cleanupCtx = context.Background()
        }</span>
        // Bound all cleanup operations under a single timeout so shutdown is
        // predictable and we don't accumulate slow API calls.
        <span class="cov0" title="0">opCtx, cancel := context.WithTimeout(cleanupCtx, DefaultCleanupOperationTimeout)
        defer cancel()

        if cr.Manager != nil </span><span class="cov0" title="0">{
                // Remove duplicate active sessions (same cluster/user/grantedGroup triple).
                // Duplicates can arise from TOCTOU races in multi-replica deployments.
                CleanupDuplicateSessions(opCtx, cr.Log, cr.Manager)
        }</span>

        // markCleanupExpiredSession and cleanupExpiredDebugSessions dereference
        // cr.Manager without a nil check; guard them to avoid a panic when the
        // session manager has not been initialised (e.g. breakglass disabled).
        <span class="cov0" title="0">if cr.Manager != nil </span><span class="cov0" title="0">{
                cr.markCleanupExpiredSession(opCtx)
                // Cleanup expired debug sessions
                cr.cleanupExpiredDebugSessions(opCtx)
        }</span>
        <span class="cov0" title="0">cr.Log.Info("Finished breakglass session cleanup task")</span>
}

// Marks sessions that are expired and removes those that should no longer be stored.
func (routine CleanupRoutine) markCleanupExpiredSession(ctx context.Context) <span class="cov0" title="0">{
        routine.Log.Debug("Starting expired session cleanup")
        var deletedCount int

        // List sessions across all namespaces
        bsl := telekomv1alpha1.BreakglassSessionList{}
        if err := routine.Manager.List(ctx, &amp;bsl); err != nil </span><span class="cov0" title="0">{
                routine.Log.Error("error listing breakglass sessions for cleanup", zap.String("error", err.Error()))
                return
        }</span>
        <span class="cov0" title="0">sessions := bsl.Items

        now := time.Now()
        for _, ses := range sessions </span><span class="cov0" title="0">{
                // Check for context cancellation to allow graceful shutdown
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        routine.Log.Infow("Session cleanup interrupted by context cancellation", "processed", deletedCount)
                        return</span>
                default:<span class="cov0" title="0"></span>
                        // continue processing
                }

                <span class="cov0" title="0">routine.Log.Debugw("Checking session for expiration", system.NamespacedFields(ses.Name, ses.Namespace)...)
                routine.Log.Debugw("Checking session retainedUntil", "retainedUntil", ses.Status.RetainedUntil.Time)
                // Delete sessions that are past their retained-until timestamp
                if !ses.Status.RetainedUntil.IsZero() &amp;&amp; now.After(ses.Status.RetainedUntil.Time) </span><span class="cov0" title="0">{
                        if err := routine.Manager.DeleteBreakglassSession(ctx, &amp;ses); err != nil </span><span class="cov0" title="0">{
                                routine.Log.Errorw("error deleting expired breakglass session", append(system.NamespacedFields(ses.Name, ses.Namespace), "error", err)...)
                                continue</span>
                        }
                        // count expired session (DeleteBreakglassSession also increments deleted; expired counts here)
                        <span class="cov0" title="0">metrics.SessionExpired.WithLabelValues(ses.Spec.Cluster).Inc()
                        deletedCount++
                        routine.Log.Debugw("Deleted expired breakglass session", system.NamespacedFields(ses.Name, ses.Namespace)...)
                        continue</span>
                }

                // Additionally, clean up sessions that do not have an OwnerReference (orphaned/legacy).
                // To avoid removing valid active sessions, only delete orphaned sessions when
                // they have no RetainedUntil set (zero value) and are not pending. Expired
                // sessions are handled above based on RetainedUntil.
                <span class="cov0" title="0">if len(ses.OwnerReferences) == 0 </span><span class="cov0" title="0">{
                        if ses.Status.RetainedUntil.IsZero() &amp;&amp; ses.Status.State != telekomv1alpha1.SessionStatePending </span><span class="cov0" title="0">{
                                routine.Log.Infow("Deleting session without OwnerReferences (orphaned/legacy - no RetainedUntil)", system.NamespacedFields(ses.Name, ses.Namespace)...)
                                if err := routine.Manager.DeleteBreakglassSession(ctx, &amp;ses); err != nil </span><span class="cov0" title="0">{
                                        routine.Log.Errorw("error deleting orphaned breakglass session", append(system.NamespacedFields(ses.Name, ses.Namespace), "error", err)...)
                                        continue</span>
                                }
                                // DeleteBreakglassSession already increments SessionDeleted
                                <span class="cov0" title="0">deletedCount++
                                routine.Log.Debugw("Deleted orphaned breakglass session", system.NamespacedFields(ses.Name, ses.Namespace)...)
                                continue</span>
                        }
                        <span class="cov0" title="0">routine.Log.Debugw("Skipping deletion of session without OwnerReferences (either pending or has RetainedUntil)", system.NamespacedFields(ses.Name, ses.Namespace)...)</span>
                }
        }
        <span class="cov0" title="0">routine.Log.Infow("Expired breakglass sessions deletion completed", "deleted", deletedCount)</span>
}

// cleanupExpiredDebugSessions marks debug sessions as expired when their ExpiresAt timestamp has passed.
// It also deletes terminated/expired debug sessions that are past their retention period.
func (routine CleanupRoutine) cleanupExpiredDebugSessions(ctx context.Context) <span class="cov0" title="0">{
        routine.Log.Debug("Starting expired debug session cleanup")
        var expiredCount, deletedCount int

        // List debug sessions across all namespaces
        dsl := telekomv1alpha1.DebugSessionList{}
        if err := routine.Manager.List(ctx, &amp;dsl); err != nil </span><span class="cov0" title="0">{
                routine.Log.Error("error listing debug sessions for cleanup", zap.String("error", err.Error()))
                return
        }</span>

        <span class="cov0" title="0">now := time.Now()
        for _, ds := range dsl.Items </span><span class="cov0" title="0">{
                // Check for context cancellation to allow graceful shutdown
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        routine.Log.Infow("Debug session cleanup interrupted by context cancellation",
                                "expired", expiredCount, "deleted", deletedCount)
                        return</span>
                default:<span class="cov0" title="0"></span>
                        // continue processing
                }

                <span class="cov0" title="0">routine.Log.Debugw("Checking debug session for expiration",
                        system.NamespacedFields(ds.Name, ds.Namespace)...)

                // Skip sessions that are already in terminal states (Expired, Terminated, Failed)
                if ds.Status.State == telekomv1alpha1.DebugSessionStateExpired ||
                        ds.Status.State == telekomv1alpha1.DebugSessionStateTerminated ||
                        ds.Status.State == telekomv1alpha1.DebugSessionStateFailed </span><span class="cov0" title="0">{
                        // Check if session should be deleted after retention period
                        // Use ExpiresAt or CreationTimestamp to determine retention eligibility
                        retentionStart := ds.CreationTimestamp.Time
                        if ds.Status.ExpiresAt != nil &amp;&amp; !ds.Status.ExpiresAt.IsZero() </span><span class="cov0" title="0">{
                                retentionStart = ds.Status.ExpiresAt.Time
                        }</span>

                        <span class="cov0" title="0">if now.After(retentionStart.Add(DebugSessionRetentionPeriod)) </span><span class="cov0" title="0">{
                                routine.Log.Infow("Deleting debug session past retention period",
                                        append(system.NamespacedFields(ds.Name, ds.Namespace),
                                                "state", ds.Status.State,
                                                "retentionPeriod", DebugSessionRetentionPeriod.String())...)

                                if err := routine.Manager.Delete(ctx, &amp;ds); err != nil </span><span class="cov0" title="0">{
                                        routine.Log.Errorw("error deleting debug session past retention",
                                                append(system.NamespacedFields(ds.Name, ds.Namespace), "error", err)...)
                                        continue</span>
                                }
                                <span class="cov0" title="0">deletedCount++
                                continue</span>
                        }

                        <span class="cov0" title="0">routine.Log.Debugw("Skipping terminal debug session (within retention period)",
                                system.NamespacedFields(ds.Name, ds.Namespace)...)
                        continue</span>
                }

                // Check if active session has expired
                <span class="cov0" title="0">if ds.Status.State == telekomv1alpha1.DebugSessionStateActive </span><span class="cov0" title="0">{
                        if ds.Status.ExpiresAt != nil &amp;&amp; now.After(ds.Status.ExpiresAt.Time) </span><span class="cov0" title="0">{
                                routine.Log.Infow("Debug session expired, marking as Expired",
                                        append(system.NamespacedFields(ds.Name, ds.Namespace),
                                                "cluster", ds.Spec.Cluster,
                                                "template", ds.Spec.TemplateRef,
                                                "requestedBy", ds.Spec.RequestedBy,
                                                "startsAt", ds.Status.StartsAt,
                                                "expiresAt", ds.Status.ExpiresAt,
                                        )...)

                                ds.Status.State = telekomv1alpha1.DebugSessionStateExpired
                                ds.Status.Message = "Session expired (cleanup routine)"

                                if err := applyDebugSessionStatus(ctx, routine.Manager, &amp;ds); err != nil </span><span class="cov0" title="0">{
                                        routine.Log.Errorw("error updating expired debug session status",
                                                append(system.NamespacedFields(ds.Name, ds.Namespace), "error", err)...)
                                        continue</span>
                                }

                                // Emit audit event for expired debug session
                                <span class="cov0" title="0">if routine.AuditManager != nil </span><span class="cov0" title="0">{
                                        routine.AuditManager.DebugSessionExpired(ctx, ds.Name, ds.Namespace, ds.Spec.Cluster)
                                }</span>

                                // Send expiration email notification
                                <span class="cov0" title="0">routine.sendDebugSessionExpiredEmail(ds)

                                expiredCount++
                                metrics.DebugSessionsExpired.WithLabelValues(ds.Spec.Cluster, ds.Spec.TemplateRef).Inc()</span>
                        }
                }

                // Check pending approval sessions that have timed out
                <span class="cov0" title="0">if ds.Status.State == telekomv1alpha1.DebugSessionStatePendingApproval </span><span class="cov0" title="0">{
                        // If approval times out, mark as failed
                        if ds.Status.Approval != nil &amp;&amp; ds.CreationTimestamp.Add(DebugSessionApprovalTimeout).Before(now) </span><span class="cov0" title="0">{
                                routine.Log.Infow("Debug session approval timed out, marking as Failed",
                                        append(system.NamespacedFields(ds.Name, ds.Namespace),
                                                "cluster", ds.Spec.Cluster,
                                                "template", ds.Spec.TemplateRef,
                                                "requestedBy", ds.Spec.RequestedBy,
                                                "createdAt", ds.CreationTimestamp,
                                                "approvalTimeout", DebugSessionApprovalTimeout.String(),
                                        )...)

                                ds.Status.State = telekomv1alpha1.DebugSessionStateFailed
                                ds.Status.Message = fmt.Sprintf("Approval timed out after %s", DebugSessionApprovalTimeout)

                                if err := applyDebugSessionStatus(ctx, routine.Manager, &amp;ds); err != nil </span><span class="cov0" title="0">{
                                        routine.Log.Errorw("error updating timed-out debug session status",
                                                append(system.NamespacedFields(ds.Name, ds.Namespace), "error", err)...)
                                        continue</span>
                                }

                                // Emit audit event for approval timeout
                                <span class="cov0" title="0">if routine.AuditManager != nil </span><span class="cov0" title="0">{
                                        routine.AuditManager.DebugSessionApprovalTimeout(ctx, ds.Name, ds.Namespace, ds.Spec.Cluster)
                                }</span>

                                <span class="cov0" title="0">deletedCount++
                                metrics.DebugSessionsFailed.WithLabelValues(ds.Spec.Cluster, ds.Spec.TemplateRef).Inc()</span>
                        }
                }
        }

        <span class="cov0" title="0">routine.Log.Infow("Debug session cleanup completed",
                "expired", expiredCount,
                "timedOut", deletedCount)</span>
}

// sendDebugSessionExpiredEmail sends a notification when a debug session expires
func (routine CleanupRoutine) sendDebugSessionExpiredEmail(ds telekomv1alpha1.DebugSession) <span class="cov0" title="0">{
        if routine.DisableEmail || routine.MailService == nil || !routine.MailService.IsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if ds.Status.ResolvedTemplate != nil &amp;&amp; ds.Status.ResolvedTemplate.Notification != nil </span><span class="cov0" title="0">{
                cfg := ds.Status.ResolvedTemplate.Notification
                if !cfg.Enabled || !cfg.NotifyOnExpiry </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov0" title="0">startedAt := ""
        if ds.Status.StartsAt != nil </span><span class="cov0" title="0">{
                startedAt = ds.Status.StartsAt.Time.Format("2006-01-02 15:04:05 UTC")
        }</span>

        <span class="cov0" title="0">var duration string
        if ds.Status.StartsAt != nil &amp;&amp; ds.Status.ExpiresAt != nil </span><span class="cov0" title="0">{
                duration = ds.Status.ExpiresAt.Time.Sub(ds.Status.StartsAt.Time).String()
        }</span>

        <span class="cov0" title="0">params := mail.DebugSessionExpiredMailParams{
                RequesterEmail: ds.Spec.RequestedBy,
                SessionID:      ds.Name,
                Cluster:        ds.Spec.Cluster,
                TemplateName:   ds.Spec.TemplateRef,
                Namespace:      ds.Namespace,
                StartedAt:      startedAt,
                ExpiredAt:      time.Now().Format("2006-01-02 15:04:05 UTC"),
                Duration:       duration,
                BrandingName:   routine.BrandingName,
        }

        body, err := mail.RenderDebugSessionExpired(params)
        if err != nil </span><span class="cov0" title="0">{
                routine.Log.Errorw("failed to render debug session expired email",
                        append(system.NamespacedFields(ds.Name, ds.Namespace), "error", err)...)
                return
        }</span>

        <span class="cov0" title="0">subject := fmt.Sprintf("[%s] Debug Session Expired: %s", routine.BrandingName, ds.Name)
        recipients := buildDebugSessionNotificationRecipients(ds)
        if len(recipients) == 0 </span><span class="cov0" title="0">{
                routine.Log.Debugw("Skipping debug session expired email: no recipients",
                        append(system.NamespacedFields(ds.Name, ds.Namespace), "cluster", ds.Spec.Cluster)...)
                return
        }</span>
        <span class="cov0" title="0">if err := routine.MailService.Enqueue(ds.Name, recipients, subject, body); err != nil </span><span class="cov0" title="0">{
                routine.Log.Errorw("failed to enqueue debug session expired email",
                        append(system.NamespacedFields(ds.Name, ds.Namespace), "error", err)...)
        }</span>
}

func buildDebugSessionNotificationRecipients(ds telekomv1alpha1.DebugSession) []string <span class="cov0" title="0">{
        base := []string{ds.Spec.RequestedBy}
        if ds.Spec.RequestedByEmail != "" </span><span class="cov0" title="0">{
                base = []string{ds.Spec.RequestedByEmail}
        }</span>

        <span class="cov0" title="0">cfg := (*telekomv1alpha1.DebugSessionNotificationConfig)(nil)
        if ds.Status.ResolvedTemplate != nil </span><span class="cov0" title="0">{
                cfg = ds.Status.ResolvedTemplate.Notification
        }</span>
        <span class="cov0" title="0">if cfg == nil </span><span class="cov0" title="0">{
                return base
        }</span>

        <span class="cov0" title="0">seen := make(map[string]struct{}, len(base))
        var recipients []string
        add := func(addr string) </span><span class="cov0" title="0">{
                if addr == "" </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">if _, ok := seen[addr]; ok </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">seen[addr] = struct{}{}
                recipients = append(recipients, addr)</span>
        }
        <span class="cov0" title="0">for _, addr := range base </span><span class="cov0" title="0">{
                add(addr)
        }</span>
        <span class="cov0" title="0">for _, addr := range cfg.AdditionalRecipients </span><span class="cov0" title="0">{
                add(addr)
        }</span>
        <span class="cov0" title="0">if cfg.ExcludedRecipients != nil &amp;&amp; len(cfg.ExcludedRecipients.Users) &gt; 0 </span><span class="cov0" title="0">{
                excluded := make(map[string]struct{}, len(cfg.ExcludedRecipients.Users))
                for _, u := range cfg.ExcludedRecipients.Users </span><span class="cov0" title="0">{
                        excluded[u] = struct{}{}
                }</span>
                <span class="cov0" title="0">filtered := recipients[:0]
                for _, addr := range recipients </span><span class="cov0" title="0">{
                        if _, blocked := excluded[addr]; blocked </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">filtered = append(filtered, addr)</span>
                }
                <span class="cov0" title="0">recipients = filtered</span>
        }
        <span class="cov0" title="0">return recipients</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
Copyright 2026.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package breakglass

import (
        "context"
        "fmt"
        "net/http"
        "sort"

        "github.com/gin-gonic/gin"
        "github.com/telekom/k8s-breakglass/api/v1alpha1"
        apiresponses "github.com/telekom/k8s-breakglass/pkg/apiresponses"
        "github.com/telekom/k8s-breakglass/pkg/cluster"
        "go.uber.org/zap"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/labels"
        ctrlclient "sigs.k8s.io/controller-runtime/pkg/client"
)

// ClusterBindingAPIController provides REST API endpoints for debug session cluster bindings
type ClusterBindingAPIController struct {
        log        *zap.SugaredLogger
        client     ctrlclient.Client
        ccProvider *cluster.ClientProvider
        middleware gin.HandlerFunc
}

// NewClusterBindingAPIController creates a new cluster binding API controller
func NewClusterBindingAPIController(log *zap.SugaredLogger, client ctrlclient.Client, ccProvider *cluster.ClientProvider, middleware gin.HandlerFunc) *ClusterBindingAPIController <span class="cov0" title="0">{
        return &amp;ClusterBindingAPIController{
                log:        log,
                client:     client,
                ccProvider: ccProvider,
                middleware: middleware,
        }
}</span>

// BasePath returns the base path for cluster binding routes
func (c *ClusterBindingAPIController) BasePath() string <span class="cov0" title="0">{
        return "clusterBindings"
}</span>

// Handlers returns middleware to apply to all routes
func (c *ClusterBindingAPIController) Handlers() []gin.HandlerFunc <span class="cov0" title="0">{
        if c.middleware != nil </span><span class="cov0" title="0">{
                return []gin.HandlerFunc{c.middleware}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Register registers the cluster binding routes
func (c *ClusterBindingAPIController) Register(rg *gin.RouterGroup) error <span class="cov0" title="0">{
        rg.GET("", instrumentedHandler("handleListClusterBindings", c.handleListClusterBindings))
        rg.GET(":namespace/:name", instrumentedHandler("handleGetClusterBinding", c.handleGetClusterBinding))
        rg.GET("forCluster/:cluster", instrumentedHandler("handleListBindingsForCluster", c.handleListBindingsForCluster))
        return nil
}</span>

// ClusterBindingResponse is the API response for a single cluster binding
type ClusterBindingResponse struct {
        Name               string                 `json:"name"`
        Namespace          string                 `json:"namespace"`
        DisplayName        string                 `json:"displayName,omitempty"`
        Description        string                 `json:"description,omitempty"`
        TemplateRef        *TemplateRefResponse   `json:"templateRef,omitempty"`
        TemplateSelector   map[string]string      `json:"templateSelector,omitempty"`
        Clusters           []string               `json:"clusters,omitempty"`
        ClusterSelector    map[string]string      `json:"clusterSelector,omitempty"`
        Disabled           bool                   `json:"disabled"`
        Hidden             bool                   `json:"hidden"`
        IsActive           bool                   `json:"isActive"`
        ExpiresAt          *metav1.Time           `json:"expiresAt,omitempty"`
        EffectiveFrom      *metav1.Time           `json:"effectiveFrom,omitempty"`
        Priority           *int32                 `json:"priority,omitempty"`
        Ready              bool                   `json:"ready"`
        ResolvedTemplates  []ResolvedTemplateInfo `json:"resolvedTemplates,omitempty"`
        ResolvedClusters   []ResolvedClusterInfo  `json:"resolvedClusters,omitempty"`
        ActiveSessionCount int32                  `json:"activeSessionCount"`
        CreatedAt          metav1.Time            `json:"createdAt"`
}

// TemplateRefResponse represents a template reference in the API
type TemplateRefResponse struct {
        Name string `json:"name"`
}

// ResolvedTemplateInfo represents a resolved template in the API response
type ResolvedTemplateInfo struct {
        Name        string `json:"name"`
        DisplayName string `json:"displayName,omitempty"`
        Ready       bool   `json:"ready"`
}

// ResolvedClusterInfo represents a resolved cluster in the API response
type ResolvedClusterInfo struct {
        Name      string `json:"name"`
        Ready     bool   `json:"ready"`
        MatchedBy string `json:"matchedBy,omitempty"`
}

// handleListClusterBindings returns a list of all cluster bindings
func (c *ClusterBindingAPIController) handleListClusterBindings(ctx *gin.Context) <span class="cov0" title="0">{
        bindingList := &amp;v1alpha1.DebugSessionClusterBindingList{}
        if err := c.client.List(ctx, bindingList); err != nil </span><span class="cov0" title="0">{
                c.log.Errorw("Failed to list cluster bindings", "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to list cluster bindings")
                return
        }</span>

        // Check for filtering options
        <span class="cov0" title="0">includeHidden := ctx.Query("includeHidden") == "true"
        activeOnly := ctx.Query("activeOnly") == "true"

        // Convert to API responses
        responses := make([]ClusterBindingResponse, 0, len(bindingList.Items))
        for i := range bindingList.Items </span><span class="cov0" title="0">{
                binding := &amp;bindingList.Items[i]

                // Skip hidden bindings unless explicitly requested
                if !includeHidden &amp;&amp; binding.Spec.Hidden </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Skip inactive bindings if only active requested
                <span class="cov0" title="0">if activeOnly &amp;&amp; !IsBindingActive(binding) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">responses = append(responses, c.bindingToResponse(binding))</span>
        }

        // Sort by priority (if set), then namespace, then name
        <span class="cov0" title="0">sort.Slice(responses, func(i, j int) bool </span><span class="cov0" title="0">{
                // Higher priority comes first
                pi := int32(0)
                pj := int32(0)
                if responses[i].Priority != nil </span><span class="cov0" title="0">{
                        pi = *responses[i].Priority
                }</span>
                <span class="cov0" title="0">if responses[j].Priority != nil </span><span class="cov0" title="0">{
                        pj = *responses[j].Priority
                }</span>
                <span class="cov0" title="0">if pi != pj </span><span class="cov0" title="0">{
                        return pi &gt; pj
                }</span>
                <span class="cov0" title="0">if responses[i].Namespace != responses[j].Namespace </span><span class="cov0" title="0">{
                        return responses[i].Namespace &lt; responses[j].Namespace
                }</span>
                <span class="cov0" title="0">return responses[i].Name &lt; responses[j].Name</span>
        })

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, responses)</span>
}

// handleGetClusterBinding returns a single cluster binding by namespace and name
func (c *ClusterBindingAPIController) handleGetClusterBinding(ctx *gin.Context) <span class="cov0" title="0">{
        namespace := ctx.Param("namespace")
        name := ctx.Param("name")

        if namespace == "" || name == "" </span><span class="cov0" title="0">{
                apiresponses.RespondBadRequest(ctx, "namespace and name are required")
                return
        }</span>

        <span class="cov0" title="0">binding := &amp;v1alpha1.DebugSessionClusterBinding{}
        if err := c.client.Get(ctx, ctrlclient.ObjectKey{Namespace: namespace, Name: name}, binding); err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        apiresponses.RespondNotFoundSimple(ctx, fmt.Sprintf("cluster binding %s/%s not found", namespace, name))
                        return
                }</span>
                <span class="cov0" title="0">c.log.Errorw("Failed to get cluster binding", "namespace", namespace, "name", name, "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to get cluster binding")
                return</span>
        }

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, c.bindingToResponse(binding))</span>
}

// handleListBindingsForCluster returns all bindings that apply to a specific cluster
func (c *ClusterBindingAPIController) handleListBindingsForCluster(ctx *gin.Context) <span class="cov0" title="0">{
        clusterName := ctx.Param("cluster")
        if clusterName == "" </span><span class="cov0" title="0">{
                apiresponses.RespondBadRequest(ctx, "cluster name is required")
                return
        }</span>

        // First get the ClusterConfig to access its labels
        <span class="cov0" title="0">clusterConfig := &amp;v1alpha1.ClusterConfig{}
        if err := c.client.Get(ctx, ctrlclient.ObjectKey{Name: clusterName}, clusterConfig); err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        apiresponses.RespondNotFoundSimple(ctx, fmt.Sprintf("cluster %s not found", clusterName))
                        return
                }</span>
                <span class="cov0" title="0">c.log.Errorw("Failed to get cluster config", "cluster", clusterName, "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to get cluster")
                return</span>
        }

        // List all bindings
        <span class="cov0" title="0">bindingList := &amp;v1alpha1.DebugSessionClusterBindingList{}
        if err := c.client.List(ctx, bindingList); err != nil </span><span class="cov0" title="0">{
                c.log.Errorw("Failed to list cluster bindings", "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to list cluster bindings")
                return
        }</span>

        // Filter bindings that match this cluster
        <span class="cov0" title="0">matchingBindings := make([]ClusterBindingResponse, 0)
        for _, binding := range bindingList.Items </span><span class="cov0" title="0">{
                if c.bindingMatchesCluster(&amp;binding, clusterName, clusterConfig) </span><span class="cov0" title="0">{
                        matchingBindings = append(matchingBindings, c.bindingToResponse(&amp;binding))
                }</span>
        }

        // Sort by namespace then name
        <span class="cov0" title="0">sort.Slice(matchingBindings, func(i, j int) bool </span><span class="cov0" title="0">{
                if matchingBindings[i].Namespace != matchingBindings[j].Namespace </span><span class="cov0" title="0">{
                        return matchingBindings[i].Namespace &lt; matchingBindings[j].Namespace
                }</span>
                <span class="cov0" title="0">return matchingBindings[i].Name &lt; matchingBindings[j].Name</span>
        })

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, matchingBindings)</span>
}

// bindingMatchesCluster checks if a binding applies to the given cluster
func (c *ClusterBindingAPIController) bindingMatchesCluster(binding *v1alpha1.DebugSessionClusterBinding, clusterName string, clusterConfig *v1alpha1.ClusterConfig) bool <span class="cov0" title="0">{
        // Check explicit cluster list
        for _, cluster := range binding.Spec.Clusters </span><span class="cov0" title="0">{
                if cluster == clusterName </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        // Check cluster selector
        <span class="cov0" title="0">if binding.Spec.ClusterSelector != nil </span><span class="cov0" title="0">{
                selector, err := metav1.LabelSelectorAsSelector(binding.Spec.ClusterSelector)
                if err != nil </span><span class="cov0" title="0">{
                        c.log.Warnw("Invalid cluster selector in binding", "binding", binding.Name, "namespace", binding.Namespace, "error", err)
                        return false
                }</span>
                <span class="cov0" title="0">if selector.Matches(labels.Set(clusterConfig.Labels)) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// bindingToResponse converts a DebugSessionClusterBinding to API response
func (c *ClusterBindingAPIController) bindingToResponse(binding *v1alpha1.DebugSessionClusterBinding) ClusterBindingResponse <span class="cov0" title="0">{
        resp := ClusterBindingResponse{
                Name:               binding.Name,
                Namespace:          binding.Namespace,
                DisplayName:        binding.Spec.DisplayName,
                Description:        binding.Spec.Description,
                Clusters:           binding.Spec.Clusters,
                Disabled:           binding.Spec.Disabled,
                Hidden:             binding.Spec.Hidden,
                IsActive:           IsBindingActive(binding),
                ExpiresAt:          binding.Spec.ExpiresAt,
                EffectiveFrom:      binding.Spec.EffectiveFrom,
                Priority:           binding.Spec.Priority,
                Ready:              binding.IsReady(),
                ActiveSessionCount: binding.Status.ActiveSessionCount,
                CreatedAt:          binding.CreationTimestamp,
        }

        if binding.Spec.TemplateRef != nil </span><span class="cov0" title="0">{
                resp.TemplateRef = &amp;TemplateRefResponse{
                        Name: binding.Spec.TemplateRef.Name,
                }
        }</span>

        <span class="cov0" title="0">if binding.Spec.TemplateSelector != nil </span><span class="cov0" title="0">{
                resp.TemplateSelector = binding.Spec.TemplateSelector.MatchLabels
        }</span>

        <span class="cov0" title="0">if binding.Spec.ClusterSelector != nil </span><span class="cov0" title="0">{
                resp.ClusterSelector = binding.Spec.ClusterSelector.MatchLabels
        }</span>

        // Convert resolved templates
        <span class="cov0" title="0">for _, rt := range binding.Status.ResolvedTemplates </span><span class="cov0" title="0">{
                resp.ResolvedTemplates = append(resp.ResolvedTemplates, ResolvedTemplateInfo{
                        Name:        rt.Name,
                        DisplayName: rt.DisplayName,
                        Ready:       rt.Ready,
                })
        }</span>

        // Convert resolved clusters
        <span class="cov0" title="0">for _, rc := range binding.Status.ResolvedClusters </span><span class="cov0" title="0">{
                resp.ResolvedClusters = append(resp.ResolvedClusters, ResolvedClusterInfo{
                        Name:      rc.Name,
                        Ready:     rc.Ready,
                        MatchedBy: rc.MatchedBy,
                })
        }</span>

        <span class="cov0" title="0">return resp</span>
}

// GetBindingsForCluster returns all bindings that apply to a specific cluster
// This is a helper method for internal use
func (c *ClusterBindingAPIController) GetBindingsForCluster(ctx context.Context, clusterName string) ([]v1alpha1.DebugSessionClusterBinding, error) <span class="cov0" title="0">{
        // Get the ClusterConfig
        clusterConfig := &amp;v1alpha1.ClusterConfig{}
        if err := c.client.Get(ctx, ctrlclient.ObjectKey{Name: clusterName}, clusterConfig); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get cluster config: %w", err)
        }</span>

        // List all bindings
        <span class="cov0" title="0">bindingList := &amp;v1alpha1.DebugSessionClusterBindingList{}
        if err := c.client.List(ctx, bindingList); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list cluster bindings: %w", err)
        }</span>

        // Filter matching bindings
        <span class="cov0" title="0">var matching []v1alpha1.DebugSessionClusterBinding
        for _, binding := range bindingList.Items </span><span class="cov0" title="0">{
                if c.bindingMatchesCluster(&amp;binding, clusterName, clusterConfig) </span><span class="cov0" title="0">{
                        matching = append(matching, binding)
                }</span>
        }

        <span class="cov0" title="0">return matching, nil</span>
}

// IsBindingActive checks if a binding is currently active.
// A binding is active if:
// - It is not disabled
// - It has not expired (expiresAt is nil or in the future)
// - It is effective (effectiveFrom is nil or in the past)
func IsBindingActive(binding *v1alpha1.DebugSessionClusterBinding) bool <span class="cov0" title="0">{
        if binding.Spec.Disabled </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">now := metav1.Now()

        // Check if binding has expired
        if binding.Spec.ExpiresAt != nil &amp;&amp; binding.Spec.ExpiresAt.Before(&amp;now) </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if binding is not yet effective
        <span class="cov0" title="0">if binding.Spec.EffectiveFrom != nil &amp;&amp; now.Before(binding.Spec.EffectiveFrom) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package breakglass

import (
        "context"
        "errors"
        "fmt"
        "strings"
        "time"

        telekomv1alpha1 "github.com/telekom/k8s-breakglass/api/v1alpha1"
        "github.com/telekom/k8s-breakglass/api/v1alpha1/applyconfiguration/ssa"
        "github.com/telekom/k8s-breakglass/pkg/cluster"
        "github.com/telekom/k8s-breakglass/pkg/metrics"
        "github.com/telekom/k8s-breakglass/pkg/utils"
        "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        apimeta "k8s.io/apimachinery/pkg/api/meta"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/discovery"
        "k8s.io/client-go/rest"
        "k8s.io/client-go/tools/clientcmd"
        "k8s.io/client-go/tools/events"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// ClusterConfigChecker periodically validates that ClusterConfig resources reference
// a secret containing the expected `kubeconfig` key. It logs Info when configs are valid
// and Warn when a secret or the key is missing so operators can remediate.
type ClusterConfigChecker struct {
        Log           *zap.SugaredLogger
        Client        client.Client
        Interval      time.Duration
        Recorder      events.EventRecorder
        LeaderElected &lt;-chan struct{} // Optional: signal when leadership acquired (nil = start immediately for backward compatibility)
}

const ClusterConfigCheckInterval = 10 * time.Minute

func (ccc ClusterConfigChecker) Start(ctx context.Context) <span class="cov0" title="0">{
        // Ensure we always have a logger to avoid nil deref
        lg := ccc.Log
        interval := ccc.Interval

        // Wait for leadership signal if provided (enables multi-replica scaling with leader election)
        if ccc.LeaderElected != nil </span><span class="cov0" title="0">{
                lg.Info("Cluster config checker waiting for leadership signal before starting...")
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        lg.Info("Cluster config checker stopping before acquiring leadership (context cancelled)")
                        return</span>
                case &lt;-ccc.LeaderElected:<span class="cov0" title="0">
                        lg.Info("Leadership acquired - starting cluster config checker")</span>
                }
        }

        <span class="cov0" title="0">if interval == 0 </span><span class="cov0" title="0">{
                interval = ClusterConfigCheckInterval
        }</span>
        <span class="cov0" title="0">ticker := time.NewTicker(interval)
        defer ticker.Stop()
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        lg.Info("ClusterConfigChecker stopping (context canceled)")
                        return</span>
                default:<span class="cov0" title="0"></span>
                }
                <span class="cov0" title="0">ccc.runOnce(ctx, lg)
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        lg.Info("ClusterConfigChecker stopping (context canceled)")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0"></span>
                }
        }
}

func (ccc ClusterConfigChecker) runOnce(ctx context.Context, lg *zap.SugaredLogger) <span class="cov0" title="0">{
        lg.Debug("Running ClusterConfig validation check")
        list := telekomv1alpha1.ClusterConfigList{}
        if err := ccc.Client.List(ctx, &amp;list); err != nil </span><span class="cov0" title="0">{
                lg.With("error", err).Error("Failed to list ClusterConfig resources for validation")
                return
        }</span>
        <span class="cov0" title="0">for _, item := range list.Items </span><span class="cov0" title="0">{
                // take address of local copy to avoid pointer-to-loop-variable issue
                cc := item
                // metric: one check attempted (label by cluster name)
                metrics.ClusterConfigsChecked.WithLabelValues(cc.Name).Inc()

                // Perform structural validation using shared validation function.
                // This catches malformed resources that somehow bypassed the admission webhook.
                validationResult := telekomv1alpha1.ValidateClusterConfig(&amp;cc)
                if !validationResult.IsValid() </span><span class="cov0" title="0">{
                        msg := "ClusterConfig failed structural validation: " + validationResult.ErrorMessage()
                        lg.Warnw(msg, "cluster", cc.Name)
                        if err2 := ccc.setStatusAndEvent(ctx, &amp;cc, telekomv1alpha1.ConditionTypeFailed, msg, corev1.EventTypeWarning, lg); err2 != nil </span><span class="cov0" title="0">{
                                lg.Warnw("failed to persist status/event for ClusterConfig", "cluster", cc.Name, "error", err2)
                        }</span>
                        <span class="cov0" title="0">metrics.ClusterConfigsFailed.WithLabelValues(cc.Name).Inc()
                        continue</span>
                }

                // Determine auth type and validate accordingly
                <span class="cov0" title="0">authType := cc.Spec.AuthType
                if authType == "" </span><span class="cov0" title="0">{
                        // Default to kubeconfig for backward compatibility
                        authType = telekomv1alpha1.ClusterAuthTypeKubeconfig
                }</span>

                <span class="cov0" title="0">var restCfg *rest.Config
                var authValidationErr error
                var successMsg string

                switch authType </span>{
                case telekomv1alpha1.ClusterAuthTypeOIDC:<span class="cov0" title="0">
                        restCfg, authValidationErr = ccc.validateOIDCAuth(ctx, &amp;cc, lg)
                        successMsg = "OIDC auth validated and cluster reachable"</span>
                default:<span class="cov0" title="0">
                        restCfg, authValidationErr = ccc.validateKubeconfigAuth(ctx, &amp;cc, lg)
                        successMsg = "Kubeconfig validated and cluster reachable"</span>
                }

                <span class="cov0" title="0">if authValidationErr != nil </span><span class="cov0" title="0">{
                        // Error already logged and status updated in validation function
                        metrics.ClusterConfigsFailed.WithLabelValues(cc.Name).Inc()
                        continue</span>
                }

                // discovery client to attempt server version call
                <span class="cov0" title="0">if err := CheckClusterReachable(restCfg); err != nil </span><span class="cov0" title="0">{
                        msg := "cluster unreachable: " + err.Error()
                        lg.Warnw(msg, "cluster", cc.Name)
                        if err2 := ccc.setStatusAndEvent(ctx, &amp;cc, telekomv1alpha1.ConditionTypeFailed, msg, corev1.EventTypeWarning, lg); err2 != nil </span><span class="cov0" title="0">{
                                lg.Warnw("failed to persist status/event for ClusterConfig", "cluster", cc.Name, "error", err2)
                        }</span>
                        <span class="cov0" title="0">metrics.ClusterConfigsFailed.WithLabelValues(cc.Name).Inc()
                        continue</span>
                }

                // Success: update status Ready and emit Normal event
                <span class="cov0" title="0">if err2 := ccc.setStatusAndEvent(ctx, &amp;cc, telekomv1alpha1.ConditionTypeReady, successMsg, corev1.EventTypeNormal, lg); err2 != nil </span><span class="cov0" title="0">{
                        lg.Warnw("failed to persist status/event for ClusterConfig", "cluster", cc.Name, "error", err2)
                }</span>
        }
        <span class="cov0" title="0">lg.Debug("ClusterConfig validation check completed")</span>
}

// validateKubeconfigAuth validates kubeconfig-based authentication and returns a rest.Config
func (ccc ClusterConfigChecker) validateKubeconfigAuth(ctx context.Context, cc *telekomv1alpha1.ClusterConfig, lg *zap.SugaredLogger) (*rest.Config, error) <span class="cov0" title="0">{
        ref := cc.Spec.KubeconfigSecretRef
        if ref == nil || ref.Name == "" || ref.Namespace == "" </span><span class="cov0" title="0">{
                msg := "ClusterConfig has no kubeconfigSecretRef configured"
                lg.Warnw(msg,
                        "cluster", cc.Name,
                        "namespace", cc.Namespace)
                if err := ccc.setStatusAndEvent(ctx, cc, telekomv1alpha1.ConditionTypeFailed, msg, corev1.EventTypeWarning, lg); err != nil </span><span class="cov0" title="0">{
                        lg.Warnw("failed to persist status/event for ClusterConfig", "cluster", cc.Name, "error", err)
                }</span>
                <span class="cov0" title="0">return nil, errors.New(msg)</span>
        }
        // fetch secret
        <span class="cov0" title="0">key := client.ObjectKey{Namespace: ref.Namespace, Name: ref.Name}
        sec := corev1.Secret{}
        if err := ccc.Client.Get(ctx, key, &amp;sec); err != nil </span><span class="cov0" title="0">{
                msg := "Referenced kubeconfig secret missing or unreadable"
                lg.Warnw(msg,
                        "cluster", cc.Name,
                        "secret", ref.Name,
                        "secretNamespace", ref.Namespace,
                        "error", err)
                // update status and emit event
                if err2 := ccc.setStatusAndEvent(ctx, cc, telekomv1alpha1.ConditionTypeFailed, msg+": "+err.Error(), corev1.EventTypeWarning, lg); err2 != nil </span><span class="cov0" title="0">{
                        lg.Warnw("failed to persist status/event for ClusterConfig", "cluster", cc.Name, "error", err2)
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        // check for kubeconfig key (cluster-api provides key 'value')
        <span class="cov0" title="0">keyName := "value"
        if ref.Key != "" </span><span class="cov0" title="0">{
                keyName = ref.Key
        }</span>
        <span class="cov0" title="0">if _, ok := sec.Data[keyName]; !ok </span><span class="cov0" title="0">{
                // If secret exists but missing key, warn with metadata
                msg := "Referenced kubeconfig secret missing key: " + keyName
                lg.Warnw(msg,
                        "cluster", cc.Name,
                        "secret", ref.Name,
                        "secretNamespace", ref.Namespace,
                        "secretCreation", sec.CreationTimestamp.Time.Format(time.RFC3339))
                if err := ccc.setStatusAndEvent(ctx, cc, telekomv1alpha1.ConditionTypeFailed, msg, corev1.EventTypeWarning, lg); err != nil </span><span class="cov0" title="0">{
                        lg.Warnw("failed to persist status/event for ClusterConfig", "cluster", cc.Name, "error", err)
                }</span>
                <span class="cov0" title="0">return nil, errors.New(msg)</span>
        }
        // Good: secret exists and has key
        <span class="cov0" title="0">lg.Debugw("ClusterConfig kubeconfig validated",
                "cluster", cc.Name,
                "secret", ref.Name,
                "secretNamespace", ref.Namespace)

        // Try to parse kubeconfig and attempt a simple discovery to verify reachability
        kubecfgBytes := sec.Data[keyName]
        // Build rest.Config from kubeconfig bytes via overridable function for testing
        restCfg, err := RestConfigFromKubeConfig(kubecfgBytes)
        if err != nil </span><span class="cov0" title="0">{
                msg := "kubeconfig parse failed: " + err.Error()
                lg.Warnw(msg, "cluster", cc.Name)
                if err2 := ccc.setStatusAndEvent(ctx, cc, telekomv1alpha1.ConditionTypeFailed, msg, corev1.EventTypeWarning, lg); err2 != nil </span><span class="cov0" title="0">{
                        lg.Warnw("failed to persist status/event for ClusterConfig", "cluster", cc.Name, "error", err2)
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return restCfg, nil</span>
}

// validateOIDCAuth validates OIDC-based authentication and returns a rest.Config.
// It supports both direct oidcAuth configuration and oidcFromIdentityProvider references.
func (ccc ClusterConfigChecker) validateOIDCAuth(ctx context.Context, cc *telekomv1alpha1.ClusterConfig, lg *zap.SugaredLogger) (*rest.Config, error) <span class="cov0" title="0">{
        // Check if we have either oidcAuth or oidcFromIdentityProvider
        hasOIDCAuth := cc.Spec.OIDCAuth != nil
        hasOIDCFromIDP := cc.Spec.OIDCFromIdentityProvider != nil

        if !hasOIDCAuth &amp;&amp; !hasOIDCFromIDP </span><span class="cov0" title="0">{
                msg := "ClusterConfig has authType=oidc but neither oidcAuth nor oidcFromIdentityProvider configured"
                lg.Warnw(msg,
                        "cluster", cc.Name,
                        "namespace", cc.Namespace)
                if err := ccc.setStatusAndEvent(ctx, cc, telekomv1alpha1.ConditionTypeFailed, msg, corev1.EventTypeWarning, lg); err != nil </span><span class="cov0" title="0">{
                        lg.Warnw("failed to persist status/event for ClusterConfig", "cluster", cc.Name, "error", err)
                }</span>
                <span class="cov0" title="0">return nil, errors.New(msg)</span>
        }

        // Validate based on which config type is used
        <span class="cov0" title="0">if hasOIDCFromIDP </span><span class="cov0" title="0">{
                return ccc.validateOIDCFromIdentityProvider(ctx, cc, lg)
        }</span>

        <span class="cov0" title="0">return ccc.validateDirectOIDCAuth(ctx, cc, lg)</span>
}

// validateOIDCFromIdentityProvider validates OIDC config that references an IdentityProvider
func (ccc ClusterConfigChecker) validateOIDCFromIdentityProvider(ctx context.Context, cc *telekomv1alpha1.ClusterConfig, lg *zap.SugaredLogger) (*rest.Config, error) <span class="cov0" title="0">{
        ref := cc.Spec.OIDCFromIdentityProvider

        // Validate required fields
        if ref.Name == "" || ref.Server == "" </span><span class="cov0" title="0">{
                msg := "oidcFromIdentityProvider missing required fields (name or server)"
                lg.Warnw(msg,
                        "cluster", cc.Name,
                        "identityProviderRef", ref.Name,
                        "server", ref.Server)
                if err := ccc.setStatusAndEvent(ctx, cc, telekomv1alpha1.ConditionTypeFailed, msg, corev1.EventTypeWarning, lg); err != nil </span><span class="cov0" title="0">{
                        lg.Warnw("failed to persist status/event for ClusterConfig", "cluster", cc.Name, "error", err)
                }</span>
                <span class="cov0" title="0">return nil, errors.New(msg)</span>
        }

        // Fetch and validate the referenced IdentityProvider
        <span class="cov0" title="0">idp := &amp;telekomv1alpha1.IdentityProvider{}
        if err := ccc.Client.Get(ctx, client.ObjectKey{Name: ref.Name}, idp); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("Referenced IdentityProvider %q not found or unreadable", ref.Name)
                lg.Warnw(msg,
                        "cluster", cc.Name,
                        "identityProvider", ref.Name,
                        "error", err)
                if err2 := ccc.setStatusAndEvent(ctx, cc, telekomv1alpha1.ConditionTypeFailed, msg, corev1.EventTypeWarning, lg); err2 != nil </span><span class="cov0" title="0">{
                        lg.Warnw("failed to persist status/event for ClusterConfig", "cluster", cc.Name, "error", err2)
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // Check if IdentityProvider is disabled
        <span class="cov0" title="0">if idp.Spec.Disabled </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("Referenced IdentityProvider %q is disabled", ref.Name)
                lg.Warnw(msg, "cluster", cc.Name, "identityProvider", ref.Name)
                if err := ccc.setStatusAndEvent(ctx, cc, telekomv1alpha1.ConditionTypeFailed, msg, corev1.EventTypeWarning, lg); err != nil </span><span class="cov0" title="0">{
                        lg.Warnw("failed to persist status/event for ClusterConfig", "cluster", cc.Name, "error", err)
                }</span>
                <span class="cov0" title="0">return nil, errors.New(msg)</span>
        }

        // Determine which client secret to use
        <span class="cov0" title="0">secretRef := ref.ClientSecretRef
        if secretRef == nil &amp;&amp; idp.Spec.Keycloak != nil </span><span class="cov0" title="0">{
                // Use Keycloak service account credentials if no explicit secret provided
                secretRef = &amp;idp.Spec.Keycloak.ClientSecretRef
        }</span>
        <span class="cov0" title="0">if secretRef == nil </span><span class="cov0" title="0">{
                msg := "oidcFromIdentityProvider requires clientSecretRef or IdentityProvider must have Keycloak service account configured"
                lg.Warnw(msg, "cluster", cc.Name, "identityProvider", ref.Name)
                if err := ccc.setStatusAndEvent(ctx, cc, telekomv1alpha1.ConditionTypeFailed, msg, corev1.EventTypeWarning, lg); err != nil </span><span class="cov0" title="0">{
                        lg.Warnw("failed to persist status/event for ClusterConfig", "cluster", cc.Name, "error", err)
                }</span>
                <span class="cov0" title="0">return nil, errors.New(msg)</span>
        }

        // Validate client secret exists
        <span class="cov0" title="0">key := client.ObjectKey{Namespace: secretRef.Namespace, Name: secretRef.Name}
        sec := corev1.Secret{}
        if err := ccc.Client.Get(ctx, key, &amp;sec); err != nil </span><span class="cov0" title="0">{
                msg := "Referenced OIDC client secret missing or unreadable"
                lg.Warnw(msg,
                        "cluster", cc.Name,
                        "secret", secretRef.Name,
                        "secretNamespace", secretRef.Namespace,
                        "error", err)
                if err2 := ccc.setStatusAndEvent(ctx, cc, telekomv1alpha1.ConditionTypeFailed, msg+": "+err.Error(), corev1.EventTypeWarning, lg); err2 != nil </span><span class="cov0" title="0">{
                        lg.Warnw("failed to persist status/event for ClusterConfig", "cluster", cc.Name, "error", err2)
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // Check for secret key
        <span class="cov0" title="0">keyName := secretRef.Key
        if keyName == "" </span><span class="cov0" title="0">{
                keyName = "client-secret"
        }</span>
        <span class="cov0" title="0">if _, ok := sec.Data[keyName]; !ok </span><span class="cov0" title="0">{
                msg := "Referenced OIDC client secret missing key: " + keyName
                lg.Warnw(msg,
                        "cluster", cc.Name,
                        "secret", secretRef.Name,
                        "secretNamespace", secretRef.Namespace)
                if err := ccc.setStatusAndEvent(ctx, cc, telekomv1alpha1.ConditionTypeFailed, msg, corev1.EventTypeWarning, lg); err != nil </span><span class="cov0" title="0">{
                        lg.Warnw("failed to persist status/event for ClusterConfig", "cluster", cc.Name, "error", err)
                }</span>
                <span class="cov0" title="0">return nil, errors.New(msg)</span>
        }

        // Check cluster CA secret exists if configured
        // NOTE: We don't fail if the CA key is missing - the OIDCTokenProvider supports TOFU
        // (Trust On First Use) which will auto-discover the CA and persist it to the secret
        <span class="cov0" title="0">if ref.CASecretRef != nil </span><span class="cov0" title="0">{
                caKey := client.ObjectKey{Namespace: ref.CASecretRef.Namespace, Name: ref.CASecretRef.Name}
                caSec := corev1.Secret{}
                if err := ccc.Client.Get(ctx, caKey, &amp;caSec); err != nil </span><span class="cov0" title="0">{
                        // Secret doesn't exist at all - this is an error (we need a place to persist TOFU CA)
                        msg := "Referenced cluster CA secret missing or unreadable"
                        lg.Warnw(msg,
                                "cluster", cc.Name,
                                "secret", ref.CASecretRef.Name,
                                "secretNamespace", ref.CASecretRef.Namespace,
                                "error", err)
                        if err2 := ccc.setStatusAndEvent(ctx, cc, telekomv1alpha1.ConditionTypeFailed, msg+": "+err.Error(), corev1.EventTypeWarning, lg); err2 != nil </span><span class="cov0" title="0">{
                                lg.Warnw("failed to persist status/event for ClusterConfig", "cluster", cc.Name, "error", err2)
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }
                // Note: We intentionally don't check if the CA key exists in the secret.
                // If the secret exists but the key is missing, TOFU will discover the CA
                // and persist it to this secret. See pkg/cluster/oidc.go configureTLS().
                <span class="cov0" title="0">caKeyName := ref.CASecretRef.Key
                if caKeyName == "" </span><span class="cov0" title="0">{
                        caKeyName = "ca.crt"
                }</span>
                <span class="cov0" title="0">if _, ok := caSec.Data[caKeyName]; !ok </span><span class="cov0" title="0">{
                        lg.Infow("CA key not found in secret, TOFU will attempt to discover and persist",
                                "cluster", cc.Name,
                                "secret", ref.CASecretRef.Name,
                                "secretNamespace", ref.CASecretRef.Namespace,
                                "key", caKeyName)
                }</span>
        }

        <span class="cov0" title="0">lg.Debugw("ClusterConfig OIDC from IdentityProvider validated",
                "cluster", cc.Name,
                "identityProvider", ref.Name,
                "server", ref.Server)

        // Use the OIDCTokenProvider to get a rest.Config - it handles resolving the IdentityProvider
        tokenProvider := cluster.NewOIDCTokenProvider(ccc.Client, lg)
        restCfg, err := tokenProvider.GetRESTConfig(ctx, cc)
        if err != nil </span><span class="cov0" title="0">{
                msg := "Failed to build OIDC rest config: " + err.Error()
                lg.Warnw(msg, "cluster", cc.Name)
                if err2 := ccc.setStatusAndEvent(ctx, cc, telekomv1alpha1.ConditionTypeFailed, msg, corev1.EventTypeWarning, lg); err2 != nil </span><span class="cov0" title="0">{
                        lg.Warnw("failed to persist status/event for ClusterConfig", "cluster", cc.Name, "error", err2)
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return restCfg, nil</span>
}

// validateDirectOIDCAuth validates direct oidcAuth configuration
func (ccc ClusterConfigChecker) validateDirectOIDCAuth(ctx context.Context, cc *telekomv1alpha1.ClusterConfig, lg *zap.SugaredLogger) (*rest.Config, error) <span class="cov0" title="0">{
        oidcConfig := cc.Spec.OIDCAuth

        // Validate required fields
        if oidcConfig.IssuerURL == "" || oidcConfig.ClientID == "" || oidcConfig.Server == "" </span><span class="cov0" title="0">{
                msg := "OIDC config missing required fields (issuerURL, clientID, or server)"
                lg.Warnw(msg,
                        "cluster", cc.Name,
                        "issuerURL", oidcConfig.IssuerURL,
                        "clientID", oidcConfig.ClientID,
                        "server", oidcConfig.Server)
                if err := ccc.setStatusAndEvent(ctx, cc, telekomv1alpha1.ConditionTypeFailed, msg, corev1.EventTypeWarning, lg); err != nil </span><span class="cov0" title="0">{
                        lg.Warnw("failed to persist status/event for ClusterConfig", "cluster", cc.Name, "error", err)
                }</span>
                <span class="cov0" title="0">return nil, errors.New(msg)</span>
        }

        // Fetch client secret if configured (required for client credentials flow)
        <span class="cov0" title="0">if oidcConfig.ClientSecretRef == nil </span><span class="cov0" title="0">{
                msg := "OIDC config missing clientSecretRef (required for client credentials flow)"
                lg.Warnw(msg, "cluster", cc.Name)
                if err := ccc.setStatusAndEvent(ctx, cc, telekomv1alpha1.ConditionTypeFailed, msg, corev1.EventTypeWarning, lg); err != nil </span><span class="cov0" title="0">{
                        lg.Warnw("failed to persist status/event for ClusterConfig", "cluster", cc.Name, "error", err)
                }</span>
                <span class="cov0" title="0">return nil, errors.New(msg)</span>
        }

        <span class="cov0" title="0">secretRef := oidcConfig.ClientSecretRef
        key := client.ObjectKey{Namespace: secretRef.Namespace, Name: secretRef.Name}
        sec := corev1.Secret{}
        if err := ccc.Client.Get(ctx, key, &amp;sec); err != nil </span><span class="cov0" title="0">{
                msg := "Referenced OIDC client secret missing or unreadable"
                lg.Warnw(msg,
                        "cluster", cc.Name,
                        "secret", secretRef.Name,
                        "secretNamespace", secretRef.Namespace,
                        "error", err)
                if err2 := ccc.setStatusAndEvent(ctx, cc, telekomv1alpha1.ConditionTypeFailed, msg+": "+err.Error(), corev1.EventTypeWarning, lg); err2 != nil </span><span class="cov0" title="0">{
                        lg.Warnw("failed to persist status/event for ClusterConfig", "cluster", cc.Name, "error", err2)
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // Check for secret key
        <span class="cov0" title="0">keyName := secretRef.Key
        if keyName == "" </span><span class="cov0" title="0">{
                keyName = "client-secret"
        }</span>
        <span class="cov0" title="0">if _, ok := sec.Data[keyName]; !ok </span><span class="cov0" title="0">{
                msg := "Referenced OIDC client secret missing key: " + keyName
                lg.Warnw(msg,
                        "cluster", cc.Name,
                        "secret", secretRef.Name,
                        "secretNamespace", secretRef.Namespace)
                if err := ccc.setStatusAndEvent(ctx, cc, telekomv1alpha1.ConditionTypeFailed, msg, corev1.EventTypeWarning, lg); err != nil </span><span class="cov0" title="0">{
                        lg.Warnw("failed to persist status/event for ClusterConfig", "cluster", cc.Name, "error", err)
                }</span>
                <span class="cov0" title="0">return nil, errors.New(msg)</span>
        }

        // Check CA certificate secret exists if configured
        // NOTE: We don't fail if the CA key is missing - the OIDCTokenProvider supports TOFU
        // (Trust On First Use) which will auto-discover the CA and persist it to the secret
        <span class="cov0" title="0">if oidcConfig.CASecretRef != nil </span><span class="cov0" title="0">{
                caKey := client.ObjectKey{Namespace: oidcConfig.CASecretRef.Namespace, Name: oidcConfig.CASecretRef.Name}
                caSec := corev1.Secret{}
                if err := ccc.Client.Get(ctx, caKey, &amp;caSec); err != nil </span><span class="cov0" title="0">{
                        // Secret doesn't exist at all - this is an error (we need a place to persist TOFU CA)
                        msg := "Referenced cluster CA secret missing or unreadable"
                        lg.Warnw(msg,
                                "cluster", cc.Name,
                                "secret", oidcConfig.CASecretRef.Name,
                                "secretNamespace", oidcConfig.CASecretRef.Namespace,
                                "error", err)
                        if err2 := ccc.setStatusAndEvent(ctx, cc, telekomv1alpha1.ConditionTypeFailed, msg+": "+err.Error(), corev1.EventTypeWarning, lg); err2 != nil </span><span class="cov0" title="0">{
                                lg.Warnw("failed to persist status/event for ClusterConfig", "cluster", cc.Name, "error", err2)
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }
                // Note: We intentionally don't check if the CA key exists in the secret.
                // If the secret exists but the key is missing, TOFU will discover the CA
                // and persist it to this secret. See pkg/cluster/oidc.go configureTLS().
                <span class="cov0" title="0">caKeyName := oidcConfig.CASecretRef.Key
                if caKeyName == "" </span><span class="cov0" title="0">{
                        caKeyName = "ca.crt"
                }</span>
                <span class="cov0" title="0">if _, ok := caSec.Data[caKeyName]; !ok </span><span class="cov0" title="0">{
                        lg.Infow("CA key not found in secret, TOFU will attempt to discover and persist",
                                "cluster", cc.Name,
                                "secret", oidcConfig.CASecretRef.Name,
                                "secretNamespace", oidcConfig.CASecretRef.Namespace,
                                "key", caKeyName)
                }</span>
        }

        <span class="cov0" title="0">lg.Debugw("ClusterConfig OIDC config validated",
                "cluster", cc.Name,
                "issuerURL", oidcConfig.IssuerURL,
                "clientID", oidcConfig.ClientID,
                "server", oidcConfig.Server)

        // Use the OIDCTokenProvider to get a rest.Config and validate we can get a token
        tokenProvider := cluster.NewOIDCTokenProvider(ccc.Client, lg)
        restCfg, err := tokenProvider.GetRESTConfig(ctx, cc)
        if err != nil </span><span class="cov0" title="0">{
                msg := "Failed to build OIDC rest config: " + err.Error()
                lg.Warnw(msg, "cluster", cc.Name)
                if err2 := ccc.setStatusAndEvent(ctx, cc, telekomv1alpha1.ConditionTypeFailed, msg, corev1.EventTypeWarning, lg); err2 != nil </span><span class="cov0" title="0">{
                        lg.Warnw("failed to persist status/event for ClusterConfig", "cluster", cc.Name, "error", err2)
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return restCfg, nil</span>
}

func (ccc ClusterConfigChecker) setStatusAndEvent(ctx context.Context, cc *telekomv1alpha1.ClusterConfig, phase, message, eventType string, lg *zap.SugaredLogger) error <span class="cov0" title="0">{
        // Determine condition status and reason first for skip check
        isSuccess := phase == telekomv1alpha1.ConditionTypeReady
        failureType := ""
        if !isSuccess </span><span class="cov0" title="0">{
                failureType = determineClusterConfigFailureType(message)
        }</span>

        // Determine if this is OIDC auth
        <span class="cov0" title="0">authType := cc.Spec.AuthType
        isOIDC := authType == telekomv1alpha1.ClusterAuthTypeOIDC

        // Determine condition status and reason
        var conditionStatus metav1.ConditionStatus
        var conditionReason telekomv1alpha1.ClusterConfigConditionReason

        if isSuccess </span><span class="cov0" title="0">{
                conditionStatus = metav1.ConditionTrue
                if isOIDC </span><span class="cov0" title="0">{
                        conditionReason = telekomv1alpha1.ClusterConfigReasonOIDCValidated
                }</span> else<span class="cov0" title="0"> {
                        conditionReason = telekomv1alpha1.ClusterConfigReasonKubeconfigValidated
                }</span>
        } else<span class="cov0" title="0"> {
                conditionStatus = metav1.ConditionFalse
                switch failureType </span>{
                // OIDC-specific reasons
                case "oidc_discovery":<span class="cov0" title="0">
                        conditionReason = telekomv1alpha1.ClusterConfigReasonOIDCDiscoveryFailed</span>
                case "oidc_token":<span class="cov0" title="0">
                        conditionReason = telekomv1alpha1.ClusterConfigReasonOIDCTokenFailed</span>
                case "oidc_refresh":<span class="cov0" title="0">
                        conditionReason = telekomv1alpha1.ClusterConfigReasonOIDCRefreshFailed</span>
                case "oidc_config":<span class="cov0" title="0">
                        conditionReason = telekomv1alpha1.ClusterConfigReasonOIDCConfigMissing</span>
                case "oidc_ca_missing":<span class="cov0" title="0">
                        conditionReason = telekomv1alpha1.ClusterConfigReasonOIDCCAMissing</span>
                case "tofu":<span class="cov0" title="0">
                        conditionReason = telekomv1alpha1.ClusterConfigReasonTOFUFailed</span>
                // Kubeconfig-specific reasons
                case "secret_missing":<span class="cov0" title="0">
                        conditionReason = telekomv1alpha1.ClusterConfigReasonSecretMissing</span>
                case "secret_key_missing":<span class="cov0" title="0">
                        conditionReason = telekomv1alpha1.ClusterConfigReasonSecretKeyMissing</span>
                case "parse":<span class="cov0" title="0">
                        conditionReason = telekomv1alpha1.ClusterConfigReasonKubeconfigInvalid</span>
                case "connection":<span class="cov0" title="0">
                        conditionReason = telekomv1alpha1.ClusterConfigReasonClusterUnreachable</span>
                default:<span class="cov0" title="0">
                        conditionReason = telekomv1alpha1.ClusterConfigReasonValidationFailed</span>
                }
        }

        // Re-fetch the object to get the latest version and check if we should skip
        <span class="cov0" title="0">var latest telekomv1alpha1.ClusterConfig
        if err := ccc.Client.Get(ctx, client.ObjectKeyFromObject(cc), &amp;latest); err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        lg.Debugw("ClusterConfig deleted before status update, skipping", "cluster", cc.Name)
                        return nil
                }</span>
                <span class="cov0" title="0">lg.Warnw("Failed to re-fetch ClusterConfig for status update", "cluster", cc.Name, "error", err)
                return err</span>
        }

        // Use StatusCoordinator to check if we should skip the status update
        <span class="cov0" title="0">coordinator := utils.NewStatusCoordinator()
        skipInfo := coordinator.ShouldSkipStatusUpdateDetailed(
                latest.Status.Conditions,
                string(telekomv1alpha1.ClusterConfigConditionReady),
                conditionStatus,
                string(conditionReason),
        )
        if skipInfo.Skipped </span><span class="cov0" title="0">{
                lg.Debugw("ClusterConfig status recently updated, skipping",
                        "cluster", cc.Name,
                        "skipReason", skipInfo.Reason,
                        "lastUpdateAge", skipInfo.LastUpdateAge,
                )
                if ccc.Recorder != nil </span><span class="cov0" title="0">{
                        ccc.Recorder.Eventf(&amp;latest, nil, corev1.EventTypeNormal, "StatusUpdateSkipped", "StatusUpdateSkipped",
                                "Skipped status update: %s (last update %v ago)", skipInfo.Reason, skipInfo.LastUpdateAge.Truncate(time.Second))
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // update status with conditions
        <span class="cov0" title="0">now := metav1.Now()

        // Update condition with typed constant
        condition := metav1.Condition{
                Type:               string(telekomv1alpha1.ClusterConfigConditionReady),
                Status:             conditionStatus,
                ObservedGeneration: latest.Generation,
                Reason:             string(conditionReason),
                Message:            message,
                LastTransitionTime: now,
        }
        apimeta.SetStatusCondition(&amp;latest.Status.Conditions, condition)
        latest.Status.ObservedGeneration = latest.Generation

        // Persist status using SSA against the status subresource.
        if err := ccc.applyStatus(ctx, &amp;latest); err != nil </span><span class="cov0" title="0">{
                if apierrors.IsConflict(err) </span><span class="cov0" title="0">{
                        lg.Debugw("Conflict updating ClusterConfig status, another controller likely handled it", "cluster", cc.Name)
                        return nil
                }</span>
                <span class="cov0" title="0">lg.Warnw("failed to update ClusterConfig status", "cluster", cc.Name, "error", err)
                return err</span>
        }
        <span class="cov0" title="0">lg.Debugw("ClusterConfig status updated successfully", "cluster", cc.Name, "ready", isSuccess)
        // emit event if recorder present
        if ccc.Recorder != nil </span><span class="cov0" title="0">{
                eventReason := "ClusterConfigValidationFailed"
                if isSuccess </span><span class="cov0" title="0">{
                        eventReason = "ClusterConfigValidationSucceeded"
                        lg.Debugw("Emitting Normal event for ClusterConfig", "cluster", cc.Name, "message", message)
                }</span> else<span class="cov0" title="0"> {
                        lg.Debugw("Emitting Warning event for ClusterConfig", "cluster", cc.Name, "message", message)
                }</span>
                <span class="cov0" title="0">ccc.Recorder.Eventf(&amp;latest, nil, eventType, eventReason, eventReason, "%s", message)</span>
        } else<span class="cov0" title="0"> {
                lg.Warnw("No Event recorder configured; skipping Kubernetes Event emission", "cluster", cc.Name)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (ccc *ClusterConfigChecker) applyStatus(ctx context.Context, config *telekomv1alpha1.ClusterConfig) error <span class="cov0" title="0">{
        return ssa.ApplyClusterConfigStatus(ctx, ccc.Client, config)
}</span>

// checkClusterReachable tries to perform a simple discovery (server version) to ensure the cluster is reachable
func checkClusterReachable(cfg *rest.Config) error <span class="cov0" title="0">{
        d, err := discovery.NewDiscoveryClientForConfig(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">_, err = d.ServerVersion()
        return err</span>
}

// StatusUpdateHelper provides methods to update ClusterConfig status with complete state exposure
type StatusUpdateHelper struct {
        message   string
        eventType string // "Normal" or "Warning"
        phase     string // "Ready" or "Failed"
}

// NewStatusUpdateHelper creates a new helper for standardized status updates
func NewStatusUpdateHelper(phase, message, eventType string) *StatusUpdateHelper <span class="cov0" title="0">{
        return &amp;StatusUpdateHelper{
                phase:     phase,
                message:   message,
                eventType: eventType,
        }
}</span>

// DescribeFailure provides a human-readable description of what failed and why
func DescribeFailure(failureType, message string) (failureCategory, advice string) <span class="cov0" title="0">{
        switch failureType </span>{
        // OIDC-specific failures
        case "oidc_discovery":<span class="cov0" title="0">
                return "oidc_discovery_failed", fmt.Sprintf("OIDC discovery failed. Check issuer URL is correct and reachable. Error: %s", message)</span>
        case "oidc_token":<span class="cov0" title="0">
                return "oidc_token_failed", fmt.Sprintf("Failed to obtain OIDC token. Check client ID/secret and issuer configuration. Error: %s", message)</span>
        case "oidc_refresh":<span class="cov0" title="0">
                return "oidc_refresh_failed", fmt.Sprintf("Failed to refresh OIDC token. Token may have been revoked. Error: %s", message)</span>
        case "oidc_config":<span class="cov0" title="0">
                return "oidc_config_missing", "OIDC configuration is incomplete. Ensure issuerURL, clientID, and server are set."</span>
        case "oidc_ca_missing":<span class="cov0" title="0">
                return "oidc_ca_secret_missing", "Referenced cluster CA secret doesn't exist or is inaccessible. Check caSecretRef."</span>
        case "tofu":<span class="cov0" title="0">
                return "tofu_failed", fmt.Sprintf("TOFU (Trust On First Use) failed. Could not fetch API server certificate. Error: %s", message)</span>
        // Kubeconfig-specific failures
        case "connection":<span class="cov0" title="0">
                return "connection_failed", fmt.Sprintf("Cluster is unreachable. Check network connectivity and cluster status. Error: %s", message)</span>
        case "parse":<span class="cov0" title="0">
                return "kubeconfig_parse_error", fmt.Sprintf("Kubeconfig is invalid or malformed. Verify the secret data. Error: %s", message)</span>
        case "secret_missing":<span class="cov0" title="0">
                return "secret_not_found", "Referenced kubeconfig secret doesn't exist or is inaccessible. Check secret name and namespace."</span>
        case "secret_key_missing":<span class="cov0" title="0">
                return "secret_key_missing", "Kubeconfig secret exists but is missing the required key. Check secret data keys."</span>
        case "not_configured":<span class="cov0" title="0">
                return "not_configured", "ClusterConfig.spec.kubeconfigSecretRef is not configured. Configure the secret reference."</span>
        default:<span class="cov0" title="0">
                return "validation_failed", fmt.Sprintf("Configuration validation failed: %s", message)</span>
        }
}

// determineClusterConfigFailureType categorizes the failure message to populate appropriate status fields
func determineClusterConfigFailureType(message string) string <span class="cov0" title="0">{
        lowerMsg := strings.ToLower(message)
        switch </span>{
        // OIDC-specific failures
        case strings.Contains(lowerMsg, "oidc") &amp;&amp; strings.Contains(lowerMsg, "discovery"):<span class="cov0" title="0">
                return "oidc_discovery"</span>
        case strings.Contains(lowerMsg, "oidc") &amp;&amp; strings.Contains(lowerMsg, "token"):<span class="cov0" title="0">
                return "oidc_token"</span>
        case strings.Contains(lowerMsg, "refresh"):<span class="cov0" title="0">
                return "oidc_refresh"</span>
        case strings.Contains(lowerMsg, "tofu"):<span class="cov0" title="0">
                return "tofu"</span>
        case strings.Contains(lowerMsg, "oidc") &amp;&amp; strings.Contains(lowerMsg, "config"):<span class="cov0" title="0">
                return "oidc_config"</span>
        case strings.Contains(lowerMsg, "ca secret") || (strings.Contains(lowerMsg, "ca") &amp;&amp; strings.Contains(lowerMsg, "missing")):<span class="cov0" title="0">
                return "oidc_ca_missing"</span>
        // Kubeconfig-specific failures
        case strings.Contains(message, "secret missing") || strings.Contains(message, "not found"):<span class="cov0" title="0">
                return "secret_missing"</span>
        case strings.Contains(message, "missing key"):<span class="cov0" title="0">
                return "secret_key_missing"</span>
        case strings.Contains(message, "parse failed"):<span class="cov0" title="0">
                return "parse"</span>
        case strings.Contains(message, "unreachable") || strings.Contains(message, "dial"):<span class="cov0" title="0">
                return "connection"</span>
        default:<span class="cov0" title="0">
                return "validation"</span>
        }
}

// overridable function variables for unit testing
var RestConfigFromKubeConfig = clientcmd.RESTConfigFromKubeConfig
var CheckClusterReachable = func(cfg *rest.Config) error <span class="cov0" title="0">{ return checkClusterReachable(cfg) }</span>

// Fallback: attempt to build rest.Config via clientcmd
</pre>
		
		<pre class="file" id="file6" style="display: none">package breakglass

import (
        "context"
        "fmt"
        "strings"

        telekomv1alpha1 "github.com/telekom/k8s-breakglass/api/v1alpha1"
        "go.uber.org/zap"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// ClusterConfigManager provides access to ClusterConfig CRs by name.
type ClusterConfigManager struct {
        client client.Client
        log    *zap.SugaredLogger
}

// ClusterConfigManagerOption configures a ClusterConfigManager during construction.
type ClusterConfigManagerOption func(*ClusterConfigManager)

// WithClusterConfigLogger sets a custom logger for the ClusterConfigManager.
// If not provided, the global zap.S() logger is used as fallback.
// Passing nil is a no-op (the existing logger is retained).
func WithClusterConfigLogger(log *zap.SugaredLogger) ClusterConfigManagerOption <span class="cov0" title="0">{
        return func(ccm *ClusterConfigManager) </span><span class="cov0" title="0">{
                if log != nil </span><span class="cov0" title="0">{
                        ccm.log = log
                }</span>
        }
}

// getLogger returns the injected logger or falls back to the global logger.
func (ccm *ClusterConfigManager) getLogger() *zap.SugaredLogger <span class="cov0" title="0">{
        if ccm.log != nil </span><span class="cov0" title="0">{
                return ccm.log
        }</span>
        <span class="cov0" title="0">return zap.S()</span>
}

// NewClusterConfigManager creates a ClusterConfigManager backed by the provided client.
// Configuration is applied via functional options (WithClusterConfigLogger).
func NewClusterConfigManager(c client.Client, opts ...ClusterConfigManagerOption) *ClusterConfigManager <span class="cov0" title="0">{
        ccm := &amp;ClusterConfigManager{client: c}
        for _, opt := range opts </span><span class="cov0" title="0">{
                if opt != nil </span><span class="cov0" title="0">{
                        opt(ccm)
                }</span>
        }
        <span class="cov0" title="0">return ccm</span>
}

// GetClusterConfigByName fetches the ClusterConfig CR by metadata.name (which is usually the cluster name/ID)
func (ccm *ClusterConfigManager) GetClusterConfigByName(ctx context.Context, name string) (*telekomv1alpha1.ClusterConfig, error) <span class="cov0" title="0">{
        // Try to use a field index (metadata.name) if available via the client's cache.
        list := telekomv1alpha1.ClusterConfigList{}
        // Try to use a field index (metadata.name) via MatchingFields if available.
        if err := ccm.client.List(ctx, &amp;list, client.MatchingFields{"metadata.name": name}); err == nil </span><span class="cov0" title="0">{
                matching := make([]*telekomv1alpha1.ClusterConfig, 0, len(list.Items))
                for i := range list.Items </span><span class="cov0" title="0">{
                        if list.Items[i].Name == name </span><span class="cov0" title="0">{
                                matching = append(matching, &amp;list.Items[i])
                        }</span>
                }
                <span class="cov0" title="0">switch len(matching) </span>{
                case 0:<span class="cov0" title="0"></span>
                        // continue to fallback for legacy behavior
                case 1:<span class="cov0" title="0">
                        return matching[0], nil</span>
                default:<span class="cov0" title="0">
                        namespaces := make([]string, 0, len(matching))
                        for _, cfg := range matching </span><span class="cov0" title="0">{
                                namespaces = append(namespaces, cfg.Namespace)
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("clusterconfig name %q is not unique; found in namespaces: %s", name, strings.Join(namespaces, ","))</span>
                }
        }

        // Fallback: do a full list scan (should be rare) - maintain original behavior for safety.
        <span class="cov0" title="0">list2 := telekomv1alpha1.ClusterConfigList{}
        if err := ccm.client.List(ctx, &amp;list2); err != nil </span><span class="cov0" title="0">{
                ccm.getLogger().Errorw("Failed to list ClusterConfig resources", "error", err)
                return nil, fmt.Errorf("failed to list ClusterConfig resources: %w", err)
        }</span>
        <span class="cov0" title="0">matching := make([]*telekomv1alpha1.ClusterConfig, 0, len(list2.Items))
        for i := range list2.Items </span><span class="cov0" title="0">{
                if list2.Items[i].Name == name </span><span class="cov0" title="0">{
                        matching = append(matching, &amp;list2.Items[i])
                }</span>
        }
        <span class="cov0" title="0">switch len(matching) </span>{
        case 0:<span class="cov0" title="0">
                return nil, fmt.Errorf("failed to get ClusterConfig by name %q: not found", name)</span>
        case 1:<span class="cov0" title="0">
                return matching[0], nil</span>
        default:<span class="cov0" title="0">
                namespaces := make([]string, 0, len(matching))
                for _, cfg := range matching </span><span class="cov0" title="0">{
                        namespaces = append(namespaces, cfg.Namespace)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("clusterconfig name %q is not unique; found in namespaces: %s", name, strings.Join(namespaces, ","))</span>
        }
}

// GetClusterConfigInNamespace fetches the ClusterConfig resource by name within the provided namespace.
// This avoids cross-namespace listing when the caller knows the escalation or resource namespace.
func (ccm *ClusterConfigManager) GetClusterConfigInNamespace(ctx context.Context, namespace, name string) (*telekomv1alpha1.ClusterConfig, error) <span class="cov0" title="0">{
        got := &amp;telekomv1alpha1.ClusterConfig{}
        if err := ccm.client.Get(ctx, client.ObjectKey{Namespace: namespace, Name: name}, got); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return got, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package breakglass

import (
        "errors"
        "fmt"
        "strings"
        "unicode/utf8"
)

type ClusterUserGroup struct {
        Clustername string `json:"cluster,omitempty"`
        Username    string `json:"user,omitempty"`
        // NOTE: previously json tag was `clustergroup` which did not match request body key `groupname`
        // causing empty GroupName and 422 on session requests. Aligning tag with request payload.
        // API now expects key `group` instead of `groupname`.
        GroupName string `json:"group,omitempty"`
}

// BreakglassSessionRequest is the expected payload when requesting a session via the API.
type BreakglassSessionRequest struct {
        Clustername string `json:"cluster,omitempty"`
        Username    string `json:"user,omitempty"`
        GroupName   string `json:"group,omitempty"`
        // Reason is an optional free-text field supplied by the requester. Its requirement and description
        // are driven by the escalation's RequestReason configuration.
        // Max 1024 characters, sanitized on server-side to prevent injection attacks.
        Reason string `json:"reason,omitempty"`
        // Duration is the requested duration in seconds. Must not exceed the escalation's maxValidFor.
        // Optional; if not provided, uses escalation's maxValidFor.
        Duration int64 `json:"duration,omitempty"`
        // ScheduledStartTime is an optional ISO 8601 datetime for scheduling the request for a future time.
        ScheduledStartTime string `json:"scheduledStartTime,omitempty"`
}

const MaxReasonLength = 1024

// SanitizeReason sanitizes the reason field to prevent injection attacks.
// Trims whitespace and removes dangerous HTML/JS/TS patterns while preserving safe content.
func (r *BreakglassSessionRequest) SanitizeReason() error <span class="cov0" title="0">{
        sanitized, err := SanitizeReasonText(r.Reason)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if utf8.RuneCountInString(sanitized) &gt; MaxReasonLength </span><span class="cov0" title="0">{
                return fmt.Errorf("reason must be at most %d characters", MaxReasonLength)
        }</span>
        <span class="cov0" title="0">r.Reason = sanitized
        return nil</span>
}

// dangerousPatterns contains patterns that could be used for injection attacks.
var dangerousPatterns = []string{
        "&lt;script", "&lt;/script",
        "&lt;iframe", "&lt;/iframe",
        "javascript:", "data:text/html",
        "onerror=", "onload=", "onclick=", "onmouseover=",
        "&lt;svg", "&lt;/svg",
        "&lt;object", "&lt;/object",
        "&lt;embed", "&lt;/embed",
        "&lt;link", "&lt;/link",
        "&lt;style", "&lt;/style",
        "&lt;img", "&lt;/img",
        "&lt;frame", "&lt;/frame",
        "&lt;frameset", "&lt;/frameset",
        "&lt;base",
        "&lt;form", "&lt;/form",
        "&lt;input", "&lt;/input",
        "&lt;button", "&lt;/button",
        "&lt;textarea", "&lt;/textarea",
        "&lt;select", "&lt;/select",
        "&lt;option", "&lt;/option",
        "&lt;label",
        "&lt;legend",
        "&lt;fieldset",
        "eval(", "expression(", "vbscript:",
        "&lt;!--", "--&gt;", // HTML comments can hide malicious content
        "&lt;?php", "&lt;?=", "?&gt;", // PHP injection
        "&lt;%", "%&gt;", // ASP injection
}

// SanitizeReasonText sanitizes a reason string to prevent injection attacks.
// Trims whitespace and removes dangerous HTML/JS/TS patterns while preserving safe content.
// This is a standalone function that can be used for any reason field.
func SanitizeReasonText(reason string) (string, error) <span class="cov0" title="0">{
        // Trim whitespace
        reason = strings.TrimSpace(reason)

        // Check each pattern in a case-insensitive manner
        // We iterate multiple times until no more patterns are found to handle nested cases
        for </span><span class="cov0" title="0">{
                foundPattern := false
                for _, pattern := range dangerousPatterns </span><span class="cov0" title="0">{
                        // Find pattern case-insensitively by searching in the original string
                        // We need to find the byte position in the original string, not the lowercased one
                        idx := indexCaseInsensitive(reason, pattern)
                        if idx &gt;= 0 </span><span class="cov0" title="0">{
                                // Strip out the dangerous pattern and everything after it
                                reason = reason[:idx]
                                reason = strings.TrimSpace(reason)
                                foundPattern = true
                                break</span> // Restart the loop with the modified string
                        }
                }
                <span class="cov0" title="0">if !foundPattern </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">return reason, nil</span>
}

// indexCaseInsensitive finds the byte index of pattern in s using case-insensitive matching.
// Returns -1 if not found. This returns the index in the ORIGINAL string s, which is required
// for safe slicing.
//
// IMPORTANT: We cannot use strings.Index(strings.ToLower(s), strings.ToLower(pattern)) because
// ToLower can change byte lengths for certain Unicode characters (e.g., some multi-byte chars).
// Using an index from the lowercased string to slice the original would cause panics or
// incorrect results. This was discovered via fuzz testing.
func indexCaseInsensitive(s, pattern string) int <span class="cov0" title="0">{
        if len(pattern) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if len(s) &lt; len(pattern) </span><span class="cov0" title="0">{
                return -1
        }</span>

        // Iterate through each possible starting position using range to ensure
        // we start at valid UTF-8 character boundaries.
        // strings.EqualFold handles Unicode case folding correctly.
        <span class="cov0" title="0">for i := range s </span><span class="cov0" title="0">{
                if i+len(pattern) &gt; len(s) </span><span class="cov0" title="0">{
                        break</span> // No room for pattern to fit, exit early
                }
                <span class="cov0" title="0">if strings.EqualFold(s[i:i+len(pattern)], pattern) </span><span class="cov0" title="0">{
                        return i
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}

// ValidateDuration validates that the requested duration is within acceptable bounds.
// maxAllowed is the maximum allowed duration in seconds (from the escalation config).
func (r *BreakglassSessionRequest) ValidateDuration(maxAllowed int64) error <span class="cov0" title="0">{
        // If duration is 0 or not specified, it will use the default (maxAllowed) from escalation
        if r.Duration == 0 </span><span class="cov0" title="0">{
                return nil // Will use default
        }</span>

        // Duration must be positive
        <span class="cov0" title="0">if r.Duration &lt; 60 </span><span class="cov0" title="0">{
                return errors.New("duration must be at least 60 seconds (1 minute)")
        }</span>

        // Duration must not exceed maximum allowed
        <span class="cov0" title="0">if r.Duration &gt; maxAllowed </span><span class="cov0" title="0">{
                return fmt.Errorf("requested duration %d seconds exceeds maximum allowed %d seconds", r.Duration, maxAllowed)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
Copyright 2026.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package breakglass

import (
        "context"
        "fmt"
        "net/http"
        "path/filepath"
        "sort"
        "strings"
        "sync"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/telekom/k8s-breakglass/api/v1alpha1"
        apiresponses "github.com/telekom/k8s-breakglass/pkg/apiresponses"
        "github.com/telekom/k8s-breakglass/pkg/audit"
        "github.com/telekom/k8s-breakglass/pkg/cluster"
        "github.com/telekom/k8s-breakglass/pkg/mail"
        "github.com/telekom/k8s-breakglass/pkg/metrics"
        "github.com/telekom/k8s-breakglass/pkg/naming"
        "github.com/telekom/k8s-breakglass/pkg/system"
        "github.com/telekom/k8s-breakglass/pkg/utils"
        "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/util/validation/field"
        ctrlclient "sigs.k8s.io/controller-runtime/pkg/client"
)

// DebugSessionAPIController provides REST API endpoints for debug sessions
type DebugSessionAPIController struct {
        log          *zap.SugaredLogger
        client       ctrlclient.Client
        apiReader    ctrlclient.Reader // Uncached reader for consistent reads
        ccProvider   *cluster.ClientProvider
        middleware   gin.HandlerFunc
        mailService  MailEnqueuer
        auditService AuditEmitter
        disableEmail bool
        brandingName string
        baseURL      string
}

// NewDebugSessionAPIController creates a new debug session API controller
func NewDebugSessionAPIController(log *zap.SugaredLogger, client ctrlclient.Client, ccProvider *cluster.ClientProvider, middleware gin.HandlerFunc) *DebugSessionAPIController <span class="cov0" title="0">{
        return &amp;DebugSessionAPIController{
                log:        log,
                client:     client,
                ccProvider: ccProvider,
                middleware: middleware,
        }
}</span>

// WithMailService sets the mail service for sending email notifications
func (c *DebugSessionAPIController) WithMailService(mailService MailEnqueuer, brandingName, baseURL string) *DebugSessionAPIController <span class="cov0" title="0">{
        c.mailService = mailService
        c.brandingName = brandingName
        c.baseURL = baseURL
        return c
}</span>

// WithAuditService sets the audit service for emitting audit events
func (c *DebugSessionAPIController) WithAuditService(auditService AuditEmitter) *DebugSessionAPIController <span class="cov0" title="0">{
        c.auditService = auditService
        return c
}</span>

// WithDisableEmail disables email notifications
func (c *DebugSessionAPIController) WithDisableEmail(disable bool) *DebugSessionAPIController <span class="cov0" title="0">{
        c.disableEmail = disable
        return c
}</span>

// WithAPIReader sets an uncached reader for consistent reads after writes.
// If not set, the controller falls back to the cached client for reads.
func (c *DebugSessionAPIController) WithAPIReader(reader ctrlclient.Reader) *DebugSessionAPIController <span class="cov0" title="0">{
        c.apiReader = reader
        return c
}</span>

// reader returns the appropriate reader - apiReader if set, otherwise the cached client.
func (c *DebugSessionAPIController) reader() ctrlclient.Reader <span class="cov0" title="0">{
        if c.apiReader != nil </span><span class="cov0" title="0">{
                return c.apiReader
        }</span>
        <span class="cov0" title="0">return c.client</span>
}

// BasePath returns the base path for debug session routes
func (c *DebugSessionAPIController) BasePath() string <span class="cov0" title="0">{
        return "debugSessions"
}</span>

// Handlers returns middleware to apply to all routes
func (c *DebugSessionAPIController) Handlers() []gin.HandlerFunc <span class="cov0" title="0">{
        if c.middleware != nil </span><span class="cov0" title="0">{
                return []gin.HandlerFunc{c.middleware}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Register registers the debug session routes
func (c *DebugSessionAPIController) Register(rg *gin.RouterGroup) error <span class="cov0" title="0">{
        // Session endpoints
        rg.GET("", instrumentedHandler("handleListDebugSessions", c.handleListDebugSessions))
        rg.GET(":name", instrumentedHandler("handleGetDebugSession", c.handleGetDebugSession))
        rg.POST("", instrumentedHandler("handleCreateDebugSession", c.handleCreateDebugSession))
        rg.POST(":name/join", instrumentedHandler("handleJoinDebugSession", c.handleJoinDebugSession))
        rg.POST(":name/leave", instrumentedHandler("handleLeaveDebugSession", c.handleLeaveDebugSession))
        rg.POST(":name/renew", instrumentedHandler("handleRenewDebugSession", c.handleRenewDebugSession))
        rg.POST(":name/terminate", instrumentedHandler("handleTerminateDebugSession", c.handleTerminateDebugSession))
        rg.POST(":name/approve", instrumentedHandler("handleApproveDebugSession", c.handleApproveDebugSession))
        rg.POST(":name/reject", instrumentedHandler("handleRejectDebugSession", c.handleRejectDebugSession))

        // Kubectl-debug mode endpoints
        rg.POST(":name/injectEphemeralContainer", instrumentedHandler("handleInjectEphemeralContainer", c.handleInjectEphemeralContainer))
        rg.POST(":name/createPodCopy", instrumentedHandler("handleCreatePodCopy", c.handleCreatePodCopy))
        rg.POST(":name/createNodeDebugPod", instrumentedHandler("handleCreateNodeDebugPod", c.handleCreateNodeDebugPod))

        // Template endpoints
        rg.GET("templates", instrumentedHandler("handleListTemplates", c.handleListTemplates))
        rg.GET("templates/:name", instrumentedHandler("handleGetTemplate", c.handleGetTemplate))
        rg.GET("templates/:name/clusters", instrumentedHandler("handleGetTemplateClusters", c.handleGetTemplateClusters))
        rg.GET("podTemplates", instrumentedHandler("handleListPodTemplates", c.handleListPodTemplates))
        rg.GET("podTemplates/:name", instrumentedHandler("handleGetPodTemplate", c.handleGetPodTemplate))
        return nil
}</span>

// getDebugSessionByName finds a debug session by name across all namespaces
// or optionally in a specific namespace if provided via query param.
// Uses the uncached apiReader if configured, for consistent reads after writes.
func (c *DebugSessionAPIController) getDebugSessionByName(ctx context.Context, name, namespaceHint string) (*v1alpha1.DebugSession, error) <span class="cov0" title="0">{
        reader := c.reader()
        // If namespace hint provided, try that first
        if namespaceHint != "" </span><span class="cov0" title="0">{
                session := &amp;v1alpha1.DebugSession{}
                if err := reader.Get(ctx, ctrlclient.ObjectKey{Name: name, Namespace: namespaceHint}, session); err == nil </span><span class="cov0" title="0">{
                        return session, nil
                }</span>
        }

        // Search across all namespaces using label selector
        <span class="cov0" title="0">sessionList := &amp;v1alpha1.DebugSessionList{}
        if err := reader.List(ctx, sessionList, ctrlclient.MatchingLabels{DebugSessionLabelKey: name}); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(sessionList.Items) == 0 </span><span class="cov0" title="0">{
                // Fallback: try default namespace
                session := &amp;v1alpha1.DebugSession{}
                if err := reader.Get(ctx, ctrlclient.ObjectKey{Name: name, Namespace: "default"}, session); err != nil </span><span class="cov0" title="0">{
                        return nil, apierrors.NewNotFound(schema.GroupResource{Group: "breakglass.t-caas.telekom.com", Resource: "debugsessions"}, name)
                }</span>
                <span class="cov0" title="0">return session, nil</span>
        }

        <span class="cov0" title="0">return &amp;sessionList.Items[0], nil</span>
}

// CreateDebugSessionRequest represents the request body for creating a debug session
type CreateDebugSessionRequest struct {
        TemplateRef              string                          `json:"templateRef" binding:"required"`
        Cluster                  string                          `json:"cluster" binding:"required"`
        BindingRef               string                          `json:"bindingRef,omitempty"` // Optional: explicit binding selection as "namespace/name" (when multiple match)
        RequestedDuration        string                          `json:"requestedDuration,omitempty"`
        NodeSelector             map[string]string               `json:"nodeSelector,omitempty"`
        Namespace                string                          `json:"namespace,omitempty"`
        Reason                   string                          `json:"reason,omitempty"`
        InvitedParticipants      []string                        `json:"invitedParticipants,omitempty"`
        TargetNamespace          string                          `json:"targetNamespace,omitempty"`          // User-selected namespace (if allowed by template)
        SelectedSchedulingOption string                          `json:"selectedSchedulingOption,omitempty"` // User-selected scheduling option
        ExtraDeployValues        map[string]apiextensionsv1.JSON `json:"extraDeployValues,omitempty"`        // User-provided values for template variables
}

// JoinDebugSessionRequest represents the request to join an existing debug session
type JoinDebugSessionRequest struct {
        Role string `json:"role,omitempty"` // "viewer" or "participant"
}

// RenewDebugSessionRequest represents the request to extend session duration
type RenewDebugSessionRequest struct {
        ExtendBy string `json:"extendBy" binding:"required"` // Duration like "1h", "30m"
}

// ApprovalRequest represents the request body for approve/reject actions
type ApprovalRequest struct {
        Reason string `json:"reason,omitempty"`
}

// InjectEphemeralContainerRequest represents the request to inject an ephemeral container
type InjectEphemeralContainerRequest struct {
        Namespace       string                  `json:"namespace" binding:"required"`
        PodName         string                  `json:"podName" binding:"required"`
        ContainerName   string                  `json:"containerName" binding:"required"`
        Image           string                  `json:"image" binding:"required"`
        Command         []string                `json:"command,omitempty"`
        SecurityContext *corev1.SecurityContext `json:"securityContext,omitempty"`
}

// CreatePodCopyRequest represents the request to create a debug copy of a pod
type CreatePodCopyRequest struct {
        Namespace  string `json:"namespace" binding:"required"`
        PodName    string `json:"podName" binding:"required"`
        DebugImage string `json:"debugImage,omitempty"` // Optional debug container image
}

// CreateNodeDebugPodRequest represents the request to create a node debug pod
type CreateNodeDebugPodRequest struct {
        NodeName string `json:"nodeName" binding:"required"`
}

// DebugSessionListResponse represents the response for listing debug sessions
type DebugSessionListResponse struct {
        Sessions []DebugSessionSummary `json:"sessions"`
        Total    int                   `json:"total"`
}

// DebugSessionSummary represents a summarized debug session for list responses
type DebugSessionSummary struct {
        Name                   string                         `json:"name"`
        TemplateRef            string                         `json:"templateRef"`
        Cluster                string                         `json:"cluster"`
        RequestedBy            string                         `json:"requestedBy"`
        RequestedByDisplayName string                         `json:"requestedByDisplayName,omitempty"`
        State                  v1alpha1.DebugSessionState     `json:"state"`
        StatusMessage          string                         `json:"statusMessage,omitempty"`
        StartsAt               *metav1.Time                   `json:"startsAt,omitempty"`
        ExpiresAt              *metav1.Time                   `json:"expiresAt,omitempty"`
        Participants           int                            `json:"participants"`
        IsParticipant          bool                           `json:"isParticipant"`
        AllowedPods            int                            `json:"allowedPods"`
        AllowedPodOperations   *v1alpha1.AllowedPodOperations `json:"allowedPodOperations,omitempty"`
}

// DebugSessionDetailResponse represents the detailed debug session response
type DebugSessionDetailResponse struct {
        v1alpha1.DebugSession
        // Warnings contains non-critical issues or notes about defaults that were applied
        Warnings []string `json:"warnings,omitempty"`
}

// handleListDebugSessions returns a list of debug sessions
func (c *DebugSessionAPIController) handleListDebugSessions(ctx *gin.Context) <span class="cov0" title="0">{
        reqLog := system.GetReqLogger(ctx, c.log)

        // Get query parameters for filtering
        cluster := ctx.Query("cluster")
        state := ctx.Query("state")
        user := ctx.Query("user")
        mine := ctx.Query("mine") == "true"

        // Get current user from context with safe type assertion
        currentUserStr := ""
        if currentUser, exists := ctx.Get("username"); exists &amp;&amp; currentUser != nil </span><span class="cov0" title="0">{
                if userStr, ok := currentUser.(string); ok </span><span class="cov0" title="0">{
                        currentUserStr = userStr
                }</span>
        }

        <span class="cov0" title="0">sessionList := &amp;v1alpha1.DebugSessionList{}
        listOpts := []ctrlclient.ListOption{}

        // Note: cluster/state/user filters are applied client-side after fetching
        // Field selectors would require additional indexer setup

        apiCtx, cancel := context.WithTimeout(ctx.Request.Context(), APIContextTimeout)
        defer cancel()

        if err := c.reader().List(apiCtx, sessionList, listOpts...); err != nil </span><span class="cov0" title="0">{
                reqLog.Errorw("Failed to list debug sessions", "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to list debug sessions")
                return
        }</span>

        // Apply filters
        <span class="cov0" title="0">var filtered []v1alpha1.DebugSession
        for _, s := range sessionList.Items </span><span class="cov0" title="0">{
                // Cluster filter
                if cluster != "" &amp;&amp; s.Spec.Cluster != cluster </span><span class="cov0" title="0">{
                        continue</span>
                }
                // State filter
                <span class="cov0" title="0">if state != "" &amp;&amp; string(s.Status.State) != state </span><span class="cov0" title="0">{
                        continue</span>
                }
                // User filter
                <span class="cov0" title="0">if user != "" &amp;&amp; s.Spec.RequestedBy != user </span><span class="cov0" title="0">{
                        continue</span>
                }
                // Mine filter
                <span class="cov0" title="0">if mine &amp;&amp; s.Spec.RequestedBy != currentUserStr </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">filtered = append(filtered, s)</span>
        }

        // Build response summaries
        <span class="cov0" title="0">summaries := make([]DebugSessionSummary, 0, len(filtered))
        for _, s := range filtered </span><span class="cov0" title="0">{
                // Compute isParticipant and activeParticipants in a single pass
                isParticipant := false
                activeParticipants := 0
                for _, p := range s.Status.Participants </span><span class="cov0" title="0">{
                        if p.LeftAt == nil </span><span class="cov0" title="0">{
                                activeParticipants++
                                if !isParticipant &amp;&amp; (p.User == currentUserStr || p.Email == currentUserStr) </span><span class="cov0" title="0">{
                                        isParticipant = true
                                }</span>
                        }
                }
                <span class="cov0" title="0">summaries = append(summaries, DebugSessionSummary{
                        Name:                   s.Name,
                        TemplateRef:            s.Spec.TemplateRef,
                        Cluster:                s.Spec.Cluster,
                        RequestedBy:            s.Spec.RequestedBy,
                        RequestedByDisplayName: s.Spec.RequestedByDisplayName,
                        State:                  s.Status.State,
                        StatusMessage:          s.Status.Message,
                        StartsAt:               s.Status.StartsAt,
                        ExpiresAt:              s.Status.ExpiresAt,
                        Participants:           activeParticipants,
                        IsParticipant:          isParticipant,
                        AllowedPods:            len(s.Status.AllowedPods),
                        AllowedPodOperations:   s.Status.AllowedPodOperations,
                })</span>
        }

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, DebugSessionListResponse{
                Sessions: summaries,
                Total:    len(summaries),
        })</span>
}

// handleGetDebugSession returns details for a specific debug session
func (c *DebugSessionAPIController) handleGetDebugSession(ctx *gin.Context) <span class="cov0" title="0">{
        reqLog := system.GetReqLogger(ctx, c.log)
        name := ctx.Param("name")
        namespaceHint := ctx.Query("namespace")

        if name == "" </span><span class="cov0" title="0">{
                apiresponses.RespondBadRequest(ctx, "session name is required")
                return
        }</span>

        <span class="cov0" title="0">apiCtx, cancel := context.WithTimeout(ctx.Request.Context(), APIContextTimeout)
        defer cancel()

        session, err := c.getDebugSessionByName(apiCtx, name, namespaceHint)
        if err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        apiresponses.RespondNotFoundSimple(ctx, "debug session not found")
                        return
                }</span>
                <span class="cov0" title="0">reqLog.Errorw("Failed to get debug session", "name", name, "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to get debug session")
                return</span>
        }

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, DebugSessionDetailResponse{DebugSession: *session})</span>
}

// handleCreateDebugSession creates a new debug session
func (c *DebugSessionAPIController) handleCreateDebugSession(ctx *gin.Context) <span class="cov0" title="0">{
        reqLog := system.GetReqLogger(ctx, c.log)

        var req CreateDebugSessionRequest
        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                reqLog.Warnw("Failed to parse CreateDebugSession request", "error", err)
                apiresponses.RespondBadRequest(ctx, err.Error())
                return
        }</span>

        <span class="cov0" title="0">reqLog.Debugw("Received CreateDebugSession request",
                "templateRef", req.TemplateRef,
                "cluster", req.Cluster,
                "bindingRef", req.BindingRef,
                "targetNamespace", req.TargetNamespace,
                "selectedSchedulingOption", req.SelectedSchedulingOption,
                "requestedDuration", req.RequestedDuration,
        )

        // Sanitize reason to prevent injection attacks
        if req.Reason != "" </span><span class="cov0" title="0">{
                sanitized, err := SanitizeReasonText(req.Reason)
                if err != nil </span><span class="cov0" title="0">{
                        reqLog.Warnw("Failed to sanitize reason, using empty string", "error", err)
                        req.Reason = "" // Use empty string as safe fallback
                }</span> else<span class="cov0" title="0"> {
                        req.Reason = sanitized
                }</span>
        }

        // Validate template exists
        <span class="cov0" title="0">template := &amp;v1alpha1.DebugSessionTemplate{}
        apiCtx, cancel := context.WithTimeout(ctx.Request.Context(), APIContextTimeout)
        defer cancel()

        if err := c.client.Get(apiCtx, ctrlclient.ObjectKey{Name: req.TemplateRef}, template); err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        reqLog.Warnw("Template not found", "templateRef", req.TemplateRef)
                        apiresponses.RespondBadRequest(ctx, fmt.Sprintf("template '%s' not found", req.TemplateRef))
                        return
                }</span>
                <span class="cov0" title="0">reqLog.Errorw("Failed to get template", "template", req.TemplateRef, "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to validate template")
                return</span>
        }

        // Fetch bindings and cluster configs to check if cluster is allowed via template or binding
        <span class="cov0" title="0">var bindingList v1alpha1.DebugSessionClusterBindingList
        var clusterConfigList v1alpha1.ClusterConfigList
        if err := c.client.List(apiCtx, &amp;bindingList); err != nil </span><span class="cov0" title="0">{
                reqLog.Errorw("Failed to list bindings for cluster validation", "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to validate cluster access")
                return
        }</span>
        <span class="cov0" title="0">if err := c.client.List(apiCtx, &amp;clusterConfigList); err != nil </span><span class="cov0" title="0">{
                reqLog.Errorw("Failed to list cluster configs for cluster validation", "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to validate cluster access")
                return
        }</span>

        // Build cluster name -&gt; ClusterConfig map for binding resolution
        <span class="cov0" title="0">clusterMap := make(map[string]*v1alpha1.ClusterConfig, len(clusterConfigList.Items))
        for i := range clusterConfigList.Items </span><span class="cov0" title="0">{
                cc := &amp;clusterConfigList.Items[i]
                clusterMap[cc.Name] = cc
        }</span>

        // Check if cluster is allowed by template or any binding
        <span class="cov0" title="0">allowedResult := c.isClusterAllowedByTemplateOrBinding(template, req.Cluster, bindingList.Items, clusterMap)
        if !allowedResult.Allowed </span><span class="cov0" title="0">{
                var errDetails string
                if template.Spec.Allowed != nil &amp;&amp; len(template.Spec.Allowed.Clusters) &gt; 0 </span><span class="cov0" title="0">{
                        errDetails = fmt.Sprintf("cluster '%s' is not allowed by template '%s'. Template cluster patterns: %v. No bindings grant access to this cluster.",
                                req.Cluster, req.TemplateRef, template.Spec.Allowed.Clusters)
                }</span> else<span class="cov0" title="0"> {
                        errDetails = fmt.Sprintf("cluster '%s' is not allowed. Template '%s' has no allowed cluster patterns and no bindings grant access to this cluster.",
                                req.Cluster, req.TemplateRef)
                }</span>
                <span class="cov0" title="0">reqLog.Warnw("Cluster not allowed by template or binding",
                        "templateRef", req.TemplateRef,
                        "requestedCluster", req.Cluster,
                        "templateAllowedClusters", func() []string </span><span class="cov0" title="0">{
                                if template.Spec.Allowed != nil </span><span class="cov0" title="0">{
                                        return template.Spec.Allowed.Clusters
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        }(),
                        "bindingsChecked", len(bindingList.Items),
                )
                <span class="cov0" title="0">apiresponses.RespondForbidden(ctx, errDetails)
                return</span>
        }
        <span class="cov0" title="0">reqLog.Debugw("Cluster access validated",
                "requestedCluster", req.Cluster,
                "allowedBySource", allowedResult.AllowedBySource,
        )

        // Track warnings for defaults that were applied
        var warnings []string

        // Validate and resolve target namespace (pass binding for constraint override)
        targetNamespace, err := c.resolveTargetNamespace(template, req.TargetNamespace, allowedResult.MatchingBinding)
        if err != nil </span><span class="cov0" title="0">{
                // Provide more context about namespace constraints when validation fails
                var effectiveAllowUserNs bool
                var effectiveDefault string
                if allowedResult.MatchingBinding != nil &amp;&amp; allowedResult.MatchingBinding.Spec.NamespaceConstraints != nil </span><span class="cov0" title="0">{
                        effectiveAllowUserNs = allowedResult.MatchingBinding.Spec.NamespaceConstraints.AllowUserNamespace
                        effectiveDefault = allowedResult.MatchingBinding.Spec.NamespaceConstraints.DefaultNamespace
                }</span> else<span class="cov0" title="0"> if template.Spec.NamespaceConstraints != nil </span><span class="cov0" title="0">{
                        effectiveAllowUserNs = template.Spec.NamespaceConstraints.AllowUserNamespace
                        effectiveDefault = template.Spec.NamespaceConstraints.DefaultNamespace
                }</span>
                <span class="cov0" title="0">reqLog.Warnw("Target namespace validation failed",
                        "templateRef", req.TemplateRef,
                        "requestedNamespace", req.TargetNamespace,
                        "allowUserNamespace", effectiveAllowUserNs,
                        "defaultNamespace", effectiveDefault,
                        "bindingUsed", allowedResult.MatchingBinding != nil,
                        "error", err,
                )
                apiresponses.RespondBadRequest(ctx, err.Error())
                return</span>
        }
        // Track warning if namespace was defaulted
        <span class="cov0" title="0">if req.TargetNamespace == "" &amp;&amp; targetNamespace != "" </span><span class="cov0" title="0">{
                warnings = append(warnings, fmt.Sprintf("Target namespace defaulted to '%s'", targetNamespace))
                reqLog.Debugw("Namespace defaulted", "defaultedTo", targetNamespace)
        }</span>

        // Validate and resolve scheduling option
        <span class="cov0" title="0">resolvedScheduling, selectedOption, err := c.resolveSchedulingConstraints(template, req.SelectedSchedulingOption, allowedResult.MatchingBinding)
        if err != nil </span><span class="cov0" title="0">{
                reqLog.Warnw("Scheduling option validation failed",
                        "templateRef", req.TemplateRef,
                        "selectedSchedulingOption", req.SelectedSchedulingOption,
                        "error", err,
                )
                apiresponses.RespondBadRequest(ctx, err.Error())
                return
        }</span>
        // Track warning if scheduling option was defaulted
        <span class="cov0" title="0">if req.SelectedSchedulingOption == "" &amp;&amp; selectedOption != "" </span><span class="cov0" title="0">{
                warnings = append(warnings, fmt.Sprintf("Scheduling option defaulted to '%s'", selectedOption))
                reqLog.Debugw("Scheduling option defaulted", "defaultedTo", selectedOption)
        }</span>
        // Track warning if scheduling option was ignored (no options in template or binding but client sent one)
        <span class="cov0" title="0">if req.SelectedSchedulingOption != "" &amp;&amp; selectedOption == "" </span><span class="cov0" title="0">{
                // Determine if any scheduling options exist (template or binding)
                hasOptions := (template.Spec.SchedulingOptions != nil &amp;&amp; len(template.Spec.SchedulingOptions.Options) &gt; 0) ||
                        (allowedResult.MatchingBinding != nil &amp;&amp; allowedResult.MatchingBinding.Spec.SchedulingOptions != nil &amp;&amp; len(allowedResult.MatchingBinding.Spec.SchedulingOptions.Options) &gt; 0)
                if !hasOptions </span><span class="cov0" title="0">{
                        warnings = append(warnings, fmt.Sprintf("Scheduling option '%s' was ignored (template has no scheduling options)", req.SelectedSchedulingOption))
                        reqLog.Debugw("Scheduling option ignored", "ignoredOption", req.SelectedSchedulingOption)
                }</span>
        }

        // Get current user from context
        <span class="cov0" title="0">currentUser, exists := ctx.Get("username")
        if !exists || currentUser == nil </span><span class="cov0" title="0">{
                apiresponses.RespondUnauthorized(ctx)
                return
        }</span>

        // Get email from context (set by auth middleware from "email" claim)
        <span class="cov0" title="0">userEmail := ""
        if email, exists := ctx.Get("email"); exists &amp;&amp; email != nil </span><span class="cov0" title="0">{
                if emailStr, ok := email.(string); ok </span><span class="cov0" title="0">{
                        userEmail = emailStr
                }</span>
        }

        // Get display name from context (set by auth middleware from "name" claim)
        <span class="cov0" title="0">displayName := ""
        if dn, exists := ctx.Get("displayName"); exists &amp;&amp; dn != nil </span><span class="cov0" title="0">{
                if dnStr, ok := dn.(string); ok </span><span class="cov0" title="0">{
                        displayName = dnStr
                }</span>
        }

        // Get user groups from context for authorization and auto-approval logic
        <span class="cov0" title="0">var userGroups []string
        if groups, exists := ctx.Get("groups"); exists &amp;&amp; groups != nil </span><span class="cov0" title="0">{
                if g, ok := groups.([]string); ok </span><span class="cov0" title="0">{
                        userGroups = g
                }</span>
        }

        // Coerce extraDeployValues types based on template variable definitions.
        // HTML form inputs and YAML defaults can produce string-encoded numbers/booleans
        // (e.g., "5" instead of 5). Normalize them before validation and storage so
        // templates render correct YAML (e.g., `storage: 5Gi` not `storage: "5"Gi`).
        <span class="cov0" title="0">if len(req.ExtraDeployValues) &gt; 0 </span><span class="cov0" title="0">{
                req.ExtraDeployValues = v1alpha1.CoerceExtraDeployValues(req.ExtraDeployValues, template.Spec.ExtraDeployVariables)
        }</span>

        // Validate extraDeployValues against template's extraDeployVariables
        // This includes checking allowedGroups on variables and options
        <span class="cov0" title="0">if len(req.ExtraDeployValues) &gt; 0 || len(template.Spec.ExtraDeployVariables) &gt; 0 </span><span class="cov0" title="0">{
                valErrs := v1alpha1.ValidateExtraDeployValuesWithGroups(
                        req.ExtraDeployValues,
                        template.Spec.ExtraDeployVariables,
                        userGroups,
                        field.NewPath("extraDeployValues"),
                )
                if len(valErrs) &gt; 0 </span><span class="cov0" title="0">{
                        // Format validation errors for API response
                        errMessages := make([]string, 0, len(valErrs))
                        for _, e := range valErrs </span><span class="cov0" title="0">{
                                errMessages = append(errMessages, e.Error())
                        }</span>
                        <span class="cov0" title="0">reqLog.Warnw("ExtraDeployValues validation failed",
                                "templateRef", req.TemplateRef,
                                "userGroups", userGroups,
                                "errors", errMessages,
                        )
                        ctx.JSON(http.StatusBadRequest, gin.H{
                                "error":  "extraDeployValues validation failed",
                                "errors": errMessages,
                        })
                        return</span>
                }
        }

        // Generate session name - use safe type assertion
        <span class="cov0" title="0">currentUserStr, ok := currentUser.(string)
        if !ok </span><span class="cov0" title="0">{
                apiresponses.RespondInternalErrorSimple(ctx, "invalid user context type")
                return
        }</span>
        <span class="cov0" title="0">sessionName := fmt.Sprintf("debug-%s-%s-%d", naming.ToRFC1123Subdomain(currentUserStr), naming.ToRFC1123Subdomain(req.Cluster), time.Now().Unix())

        // Determine namespace from ClusterConfig for the requested cluster
        // DebugSessions should be in the same namespace as the ClusterConfig
        namespace := req.Namespace
        if namespace == "" </span><span class="cov0" title="0">{
                // Find ClusterConfig by cluster name to get its namespace
                clusterConfigs := &amp;v1alpha1.ClusterConfigList{}
                if err := c.client.List(apiCtx, clusterConfigs); err == nil </span><span class="cov0" title="0">{
                        for _, cc := range clusterConfigs.Items </span><span class="cov0" title="0">{
                                if cc.Name == req.Cluster || cc.Spec.Tenant == req.Cluster </span><span class="cov0" title="0">{
                                        namespace = cc.Namespace
                                        break</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">if namespace == "" </span><span class="cov0" title="0">{
                namespace = "default"
        }</span>

        // Create the debug session
        <span class="cov0" title="0">session := &amp;v1alpha1.DebugSession{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      sessionName,
                        Namespace: namespace,
                        Labels: map[string]string{
                                DebugSessionLabelKey:  sessionName,
                                DebugTemplateLabelKey: req.TemplateRef,
                                DebugClusterLabelKey:  req.Cluster,
                        },
                },
                Spec: v1alpha1.DebugSessionSpec{
                        TemplateRef:                   req.TemplateRef,
                        Cluster:                       req.Cluster,
                        RequestedBy:                   currentUserStr,
                        RequestedByEmail:              userEmail,
                        RequestedByDisplayName:        displayName,
                        UserGroups:                    userGroups,
                        RequestedDuration:             req.RequestedDuration,
                        NodeSelector:                  req.NodeSelector,
                        Reason:                        req.Reason,
                        InvitedParticipants:           req.InvitedParticipants,
                        TargetNamespace:               targetNamespace,
                        SelectedSchedulingOption:      selectedOption,
                        ResolvedSchedulingConstraints: resolvedScheduling,
                        ExtraDeployValues:             req.ExtraDeployValues,
                },
        }

        // Copy reason configurations as snapshots so session is self-contained
        // This avoids needing to look up the template later
        if template.Spec.RequestReason != nil </span><span class="cov0" title="0">{
                session.Spec.RequestReasonConfig = template.Spec.RequestReason.DeepCopy()
        }</span>
        <span class="cov0" title="0">if template.Spec.ApprovalReason != nil </span><span class="cov0" title="0">{
                session.Spec.ApprovalReasonConfig = template.Spec.ApprovalReason.DeepCopy()
        }</span>

        // Set explicit binding reference if provided (format: "namespace/name")
        <span class="cov0" title="0">var resolvedBinding *v1alpha1.DebugSessionClusterBinding
        if req.BindingRef != "" </span><span class="cov0" title="0">{
                parts := strings.SplitN(req.BindingRef, "/", 2)
                if len(parts) == 2 </span><span class="cov0" title="0">{
                        session.Spec.BindingRef = &amp;v1alpha1.BindingReference{
                                Name:      parts[1],
                                Namespace: parts[0],
                        }
                        // Fetch the binding for limit checking
                        resolvedBinding = &amp;v1alpha1.DebugSessionClusterBinding{}
                        if err := c.client.Get(apiCtx, ctrlclient.ObjectKey{Name: parts[1], Namespace: parts[0]}, resolvedBinding); err != nil </span><span class="cov0" title="0">{
                                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                                        reqLog.Warnw("Binding not found", "bindingRef", req.BindingRef)
                                        apiresponses.RespondBadRequest(ctx, fmt.Sprintf("binding '%s' not found", req.BindingRef))
                                        return
                                }</span>
                                <span class="cov0" title="0">reqLog.Errorw("Failed to get binding", "binding", req.BindingRef, "error", err)
                                apiresponses.RespondInternalErrorSimple(ctx, "failed to validate binding")
                                return</span>
                        }

                        // Check if binding is active
                        <span class="cov0" title="0">if !IsBindingActive(resolvedBinding) </span><span class="cov0" title="0">{
                                reqLog.Warnw("Binding is not active",
                                        "bindingRef", req.BindingRef,
                                        "disabled", resolvedBinding.Spec.Disabled,
                                        "effectiveFrom", resolvedBinding.Spec.EffectiveFrom,
                                        "expiresAt", resolvedBinding.Spec.ExpiresAt,
                                )
                                apiresponses.RespondForbidden(ctx, "binding is not active (disabled, expired, or not yet effective)")
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        reqLog.Warnw("Invalid bindingRef format, expected namespace/name", "bindingRef", req.BindingRef)
                }</span>
        }

        // Check binding session limits if a binding is resolved
        <span class="cov0" title="0">if resolvedBinding != nil </span><span class="cov0" title="0">{
                if err := c.checkBindingSessionLimits(apiCtx, resolvedBinding, userEmail); err != nil </span><span class="cov0" title="0">{
                        reqLog.Warnw("Binding session limits exceeded",
                                "bindingRef", req.BindingRef,
                                "userEmail", userEmail,
                                "error", err,
                        )
                        apiresponses.RespondForbidden(ctx, err.Error())
                        return
                }</span>

                // Apply binding labels to the session
                <span class="cov0" title="0">if len(resolvedBinding.Spec.Labels) &gt; 0 </span><span class="cov0" title="0">{
                        for k, v := range resolvedBinding.Spec.Labels </span><span class="cov0" title="0">{
                                session.Labels[k] = v
                        }</span>
                }

                // Apply binding annotations to the session
                <span class="cov0" title="0">if len(resolvedBinding.Spec.Annotations) &gt; 0 </span><span class="cov0" title="0">{
                        if session.Annotations == nil </span><span class="cov0" title="0">{
                                session.Annotations = make(map[string]string)
                        }</span>
                        <span class="cov0" title="0">for k, v := range resolvedBinding.Spec.Annotations </span><span class="cov0" title="0">{
                                session.Annotations[k] = v
                        }</span>
                }
        }

        // Design Decision (#382): Using Create() instead of SSA for DebugSession creation.
        //
        // We evaluated replacing Create() with a pre-check Get() + SSA Apply pattern for
        // consistency with the reconciler's SSA approach. The decision is to keep Create()
        // because:
        //
        // 1. Native conflict detection  Create() returns AlreadyExists natively, giving us
        //    HTTP 409 Conflict without an extra round-trip. A pre-check Get() would add
        //    latency and introduce a small race window between Get and Apply.
        //
        // 2. Semantic correctness  SSA Apply is designed for idempotent reconciliation
        //    (create-or-update). Debug session creation is intentionally a one-shot operation;
        //    silently updating an existing session would violate the expected API contract.
        //
        // 3. No multi-owner benefit  SSA's field ownership tracking adds value when multiple
        //    controllers manage the same object. Debug sessions are created by the API server
        //    and then managed exclusively by the reconciler. There is no ownership conflict.
        //
        // 4. Simplicity  The current code is straightforward and well-tested. Adding a
        //    pre-check Get() increases complexity without a concrete benefit.
        //
        // The reconciler continues to use SSA for status updates and lifecycle management,
        // which is the correct boundary: Create() for API-driven creation, SSA for
        // controller-driven reconciliation.
        <span class="cov0" title="0">if err := c.client.Create(apiCtx, session); err != nil </span><span class="cov0" title="0">{
                if apierrors.IsAlreadyExists(err) </span><span class="cov0" title="0">{
                        apiresponses.RespondConflict(ctx, "session already exists")
                        return
                }</span>
                <span class="cov0" title="0">reqLog.Errorw("Failed to create debug session", "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to create debug session")
                return</span>
        }

        // Send request email to approvers
        <span class="cov0" title="0">c.sendDebugSessionRequestEmail(apiCtx, session, template, resolvedBinding)

        // Send confirmation email to requester
        c.sendDebugSessionCreatedEmail(apiCtx, session, template, resolvedBinding)

        // Emit audit event for session creation
        c.emitDebugSessionAuditEvent(apiCtx, audit.EventDebugSessionCreated, session, currentUser.(string), "Debug session created")

        reqLog.Infow("Debug session created",
                "name", sessionName,
                "cluster", req.Cluster,
                "template", req.TemplateRef,
                "user", currentUser)

        metrics.DebugSessionsCreated.WithLabelValues(req.Cluster, req.TemplateRef).Inc()

        response := DebugSessionDetailResponse{DebugSession: *session}
        if len(warnings) &gt; 0 </span><span class="cov0" title="0">{
                response.Warnings = warnings
                reqLog.Infow("Session created with warnings", "warnings", warnings)
        }</span>
        <span class="cov0" title="0">ctx.JSON(http.StatusCreated, response)</span>
}

// handleJoinDebugSession allows a user to join an existing debug session
func (c *DebugSessionAPIController) handleJoinDebugSession(ctx *gin.Context) <span class="cov0" title="0">{
        reqLog := system.GetReqLogger(ctx, c.log)
        name := ctx.Param("name")
        namespaceHint := ctx.Query("namespace")

        var req JoinDebugSessionRequest
        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                // Default to viewer role if not specified
                req.Role = string(v1alpha1.ParticipantRoleViewer)
        }</span>
        <span class="cov0" title="0">if req.Role == "" </span><span class="cov0" title="0">{
                req.Role = string(v1alpha1.ParticipantRoleViewer)
        }</span>

        // Get current user
        <span class="cov0" title="0">currentUser, exists := ctx.Get("username")
        if !exists || currentUser == nil </span><span class="cov0" title="0">{
                apiresponses.RespondUnauthorized(ctx)
                return
        }</span>

        <span class="cov0" title="0">apiCtx, cancel := context.WithTimeout(ctx.Request.Context(), APIContextTimeout)
        defer cancel()

        session, err := c.getDebugSessionByName(apiCtx, name, namespaceHint)
        if err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        apiresponses.RespondNotFoundSimple(ctx, "debug session not found")
                        return
                }</span>
                <span class="cov0" title="0">reqLog.Errorw("Failed to get debug session", "name", name, "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to get debug session")
                return</span>
        }

        // Check session is active
        <span class="cov0" title="0">if session.Status.State != v1alpha1.DebugSessionStateActive </span><span class="cov0" title="0">{
                apiresponses.RespondBadRequest(ctx, fmt.Sprintf("cannot join session in state '%s'", session.Status.State))
                return
        }</span>

        // Check if user already joined
        <span class="cov0" title="0">username := currentUser.(string)
        for _, p := range session.Status.Participants </span><span class="cov0" title="0">{
                if p.User == username </span><span class="cov0" title="0">{
                        apiresponses.RespondConflict(ctx, "user already joined this session")
                        return
                }</span>
        }

        // Check max participants if configured
        <span class="cov0" title="0">if session.Status.ResolvedTemplate != nil &amp;&amp;
                session.Status.ResolvedTemplate.TerminalSharing != nil &amp;&amp;
                session.Status.ResolvedTemplate.TerminalSharing.MaxParticipants &gt; 0 </span><span class="cov0" title="0">{
                if int32(len(session.Status.Participants)) &gt;= session.Status.ResolvedTemplate.TerminalSharing.MaxParticipants </span><span class="cov0" title="0">{
                        apiresponses.RespondForbidden(ctx, "maximum participants reached")
                        return
                }</span>
        }

        // Determine role
        <span class="cov0" title="0">role := v1alpha1.ParticipantRoleViewer
        if req.Role == string(v1alpha1.ParticipantRoleParticipant) </span><span class="cov0" title="0">{
                role = v1alpha1.ParticipantRoleParticipant
        }</span>

        // Get display name from context (set by auth middleware from "name" claim)
        <span class="cov0" title="0">displayName := ""
        if dn, exists := ctx.Get("displayName"); exists &amp;&amp; dn != nil </span><span class="cov0" title="0">{
                if dnStr, ok := dn.(string); ok </span><span class="cov0" title="0">{
                        displayName = dnStr
                }</span>
        }

        // Get email from context (set by auth middleware from "email" claim)
        <span class="cov0" title="0">userEmail := ""
        if email, exists := ctx.Get("email"); exists &amp;&amp; email != nil </span><span class="cov0" title="0">{
                if emailStr, ok := email.(string); ok </span><span class="cov0" title="0">{
                        userEmail = emailStr
                }</span>
        }

        // Add participant
        <span class="cov0" title="0">now := metav1.Now()
        session.Status.Participants = append(session.Status.Participants, v1alpha1.DebugSessionParticipant{
                User:        username,
                Email:       userEmail,
                DisplayName: displayName,
                Role:        role,
                JoinedAt:    now,
        })

        if err := applyDebugSessionStatus(apiCtx, c.client, session); err != nil </span><span class="cov0" title="0">{
                reqLog.Errorw("Failed to add participant", "session", name, "user", username, "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to join session")
                return
        }</span>

        <span class="cov0" title="0">reqLog.Infow("User joined debug session", "session", name, "user", username, "role", role)
        metrics.DebugSessionParticipants.WithLabelValues(session.Spec.Cluster, name).Set(float64(len(session.Status.Participants)))

        ctx.JSON(http.StatusOK, gin.H{"message": "successfully joined session", "role": role})</span>
}

// handleRenewDebugSession extends the session duration
func (c *DebugSessionAPIController) handleRenewDebugSession(ctx *gin.Context) <span class="cov0" title="0">{
        reqLog := system.GetReqLogger(ctx, c.log)
        name := ctx.Param("name")
        namespaceHint := ctx.Query("namespace")

        // Get current user for authorization check
        currentUser, exists := ctx.Get("username")
        if !exists || currentUser == nil </span><span class="cov0" title="0">{
                apiresponses.RespondUnauthorized(ctx)
                return
        }</span>
        <span class="cov0" title="0">username := currentUser.(string)

        var req RenewDebugSessionRequest
        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                apiresponses.RespondBadRequest(ctx, err.Error())
                return
        }</span>

        // Parse extension duration (supports day units like "1d")
        <span class="cov0" title="0">extendBy, err := v1alpha1.ParseDuration(req.ExtendBy)
        if err != nil </span><span class="cov0" title="0">{
                apiresponses.RespondBadRequest(ctx, "invalid duration format")
                return
        }</span>

        // Validate duration is positive
        <span class="cov0" title="0">if extendBy &lt;= 0 </span><span class="cov0" title="0">{
                apiresponses.RespondBadRequest(ctx, "extension duration must be positive")
                return
        }</span>

        <span class="cov0" title="0">apiCtx, cancel := context.WithTimeout(ctx.Request.Context(), APIContextTimeout)
        defer cancel()

        session, err := c.getDebugSessionByName(apiCtx, name, namespaceHint)
        if err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        apiresponses.RespondNotFoundSimple(ctx, "debug session not found")
                        return
                }</span>
                <span class="cov0" title="0">reqLog.Errorw("Failed to get debug session", "name", name, "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to get debug session")
                return</span>
        }

        // Check if user is owner or participant
        <span class="cov0" title="0">isOwnerOrParticipant := session.Spec.RequestedBy == username
        if !isOwnerOrParticipant </span><span class="cov0" title="0">{
                for _, p := range session.Status.Participants </span><span class="cov0" title="0">{
                        if p.User == username </span><span class="cov0" title="0">{
                                isOwnerOrParticipant = true
                                break</span>
                        }
                }
        }
        <span class="cov0" title="0">if !isOwnerOrParticipant </span><span class="cov0" title="0">{
                apiresponses.RespondForbidden(ctx, "only session owner or participants can renew")
                return
        }</span>

        // Check session is active
        <span class="cov0" title="0">if session.Status.State != v1alpha1.DebugSessionStateActive </span><span class="cov0" title="0">{
                apiresponses.RespondBadRequest(ctx, fmt.Sprintf("cannot renew session in state '%s'", session.Status.State))
                return
        }</span>

        // Check renewal constraints
        <span class="cov0" title="0">if session.Status.ResolvedTemplate != nil &amp;&amp; session.Status.ResolvedTemplate.Constraints != nil </span><span class="cov0" title="0">{
                constraints := session.Status.ResolvedTemplate.Constraints

                // Check if renewals are allowed (defaults to true if not set)
                if constraints.AllowRenewal != nil &amp;&amp; !*constraints.AllowRenewal </span><span class="cov0" title="0">{
                        apiresponses.RespondForbidden(ctx, "session renewals are not allowed by template")
                        return
                }</span>

                // Check max renewals (nil means use default of 3, 0 means no renewals allowed)
                <span class="cov0" title="0">if constraints.MaxRenewals != nil </span><span class="cov0" title="0">{
                        maxRenewals := *constraints.MaxRenewals
                        if maxRenewals == 0 || session.Status.RenewalCount &gt;= maxRenewals </span><span class="cov0" title="0">{
                                apiresponses.RespondForbidden(ctx, fmt.Sprintf("maximum renewals (%d) reached", maxRenewals))
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Default max renewals is 3
                        if session.Status.RenewalCount &gt;= 3 </span><span class="cov0" title="0">{
                                apiresponses.RespondForbidden(ctx, "maximum renewals (3) reached")
                                return
                        }</span>
                }

                // Check total duration would not exceed max
                <span class="cov0" title="0">if constraints.MaxDuration != "" </span><span class="cov0" title="0">{
                        maxDur, err := v1alpha1.ParseDuration(constraints.MaxDuration)
                        if err == nil &amp;&amp; session.Status.StartsAt != nil </span><span class="cov0" title="0">{
                                currentDuration := time.Since(session.Status.StartsAt.Time)
                                if currentDuration+extendBy &gt; maxDur </span><span class="cov0" title="0">{
                                        apiresponses.RespondForbidden(ctx, fmt.Sprintf("extension would exceed maximum duration of %s", constraints.MaxDuration))
                                        return
                                }</span>
                        }
                }
        }

        // Extend the expiration
        <span class="cov0" title="0">if session.Status.ExpiresAt == nil </span><span class="cov0" title="0">{
                apiresponses.RespondBadRequest(ctx, "session has no expiration time")
                return
        }</span>

        <span class="cov0" title="0">newExpiry := metav1.NewTime(session.Status.ExpiresAt.Add(extendBy))
        session.Status.ExpiresAt = &amp;newExpiry
        session.Status.RenewalCount++

        if err := applyDebugSessionStatus(apiCtx, c.client, session); err != nil </span><span class="cov0" title="0">{
                reqLog.Errorw("Failed to renew session", "session", name, "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to renew session")
                return
        }</span>

        <span class="cov0" title="0">reqLog.Infow("Debug session renewed",
                "session", name,
                "extendBy", extendBy,
                "newExpiry", newExpiry.Time,
                "renewalCount", session.Status.RenewalCount)

        ctx.JSON(http.StatusOK, gin.H{
                "message":      "session renewed successfully",
                "newExpiresAt": newExpiry.Time,
                "renewalCount": session.Status.RenewalCount,
        })</span>
}

// handleTerminateDebugSession terminates a debug session early
func (c *DebugSessionAPIController) handleTerminateDebugSession(ctx *gin.Context) <span class="cov0" title="0">{
        reqLog := system.GetReqLogger(ctx, c.log)
        name := ctx.Param("name")
        namespaceHint := ctx.Query("namespace")

        // Get current user
        currentUser, exists := ctx.Get("username")
        if !exists || currentUser == nil </span><span class="cov0" title="0">{
                apiresponses.RespondUnauthorized(ctx)
                return
        }</span>

        <span class="cov0" title="0">apiCtx, cancel := context.WithTimeout(ctx.Request.Context(), APIContextTimeout)
        defer cancel()

        session, err := c.getDebugSessionByName(apiCtx, name, namespaceHint)
        if err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        apiresponses.RespondNotFoundSimple(ctx, "debug session not found")
                        return
                }</span>
                <span class="cov0" title="0">reqLog.Errorw("Failed to get debug session", "name", name, "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to get debug session")
                return</span>
        }

        // Check if user is allowed to terminate (owner or admin)
        // For now, only the owner can terminate
        <span class="cov0" title="0">if session.Spec.RequestedBy != currentUser.(string) </span><span class="cov0" title="0">{
                apiresponses.RespondForbidden(ctx, "only the session owner can terminate")
                return
        }</span>

        // Check session can be terminated
        <span class="cov0" title="0">if session.Status.State == v1alpha1.DebugSessionStateTerminated ||
                session.Status.State == v1alpha1.DebugSessionStateExpired ||
                session.Status.State == v1alpha1.DebugSessionStateFailed </span><span class="cov0" title="0">{
                apiresponses.RespondBadRequest(ctx, fmt.Sprintf("session is already in terminal state '%s'", session.Status.State))
                return
        }</span>

        // Mark as terminated
        <span class="cov0" title="0">session.Status.State = v1alpha1.DebugSessionStateTerminated
        session.Status.Message = fmt.Sprintf("Terminated by %s", currentUser)

        if err := applyDebugSessionStatus(apiCtx, c.client, session); err != nil </span><span class="cov0" title="0">{
                reqLog.Errorw("Failed to terminate session", "session", name, "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to terminate session")
                return
        }</span>

        // Emit audit event for session termination
        <span class="cov0" title="0">c.emitDebugSessionAuditEvent(apiCtx, audit.EventDebugSessionTerminated, session, currentUser.(string), "Debug session terminated by user")

        reqLog.Infow("Debug session terminated", "session", name, "user", currentUser)
        metrics.DebugSessionsTerminated.WithLabelValues(session.Spec.Cluster, "user_terminated").Inc()

        // Return updated session - client expects the session object, not just a message
        ctx.JSON(http.StatusOK, session)</span>
}

// handleApproveDebugSession approves a pending debug session
func (c *DebugSessionAPIController) handleApproveDebugSession(ctx *gin.Context) <span class="cov0" title="0">{
        reqLog := system.GetReqLogger(ctx, c.log)
        name := ctx.Param("name")
        namespaceHint := ctx.Query("namespace")

        var req ApprovalRequest
        _ = ctx.ShouldBindJSON(&amp;req) // Optional body

        // Get current user
        currentUser, exists := ctx.Get("username")
        if !exists || currentUser == nil </span><span class="cov0" title="0">{
                apiresponses.RespondUnauthorized(ctx)
                return
        }</span>

        <span class="cov0" title="0">apiCtx, cancel := context.WithTimeout(ctx.Request.Context(), APIContextTimeout)
        defer cancel()

        session, err := c.getDebugSessionByName(apiCtx, name, namespaceHint)
        if err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        apiresponses.RespondNotFoundSimple(ctx, "debug session not found")
                        return
                }</span>
                <span class="cov0" title="0">reqLog.Errorw("Failed to get debug session", "name", name, "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to get debug session")
                return</span>
        }

        // Check session is pending approval
        <span class="cov0" title="0">if session.Status.State != v1alpha1.DebugSessionStatePendingApproval </span><span class="cov0" title="0">{
                apiresponses.RespondBadRequest(ctx, fmt.Sprintf("session is not pending approval (state: %s)", session.Status.State))
                return
        }</span>

        // Check if user is authorized to approve (in allowed approver groups)
        <span class="cov0" title="0">userGroups, _ := ctx.Get("groups")
        if !c.isUserAuthorizedToApprove(apiCtx, session, currentUser.(string), userGroups) </span><span class="cov0" title="0">{
                apiresponses.RespondForbidden(ctx, "user is not authorized to approve this session")
                return
        }</span>

        // Mark as approved
        <span class="cov0" title="0">now := metav1.Now()
        if session.Status.Approval == nil </span><span class="cov0" title="0">{
                session.Status.Approval = &amp;v1alpha1.DebugSessionApproval{}
        }</span>
        <span class="cov0" title="0">session.Status.Approval.ApprovedBy = currentUser.(string)
        session.Status.Approval.ApprovedAt = &amp;now
        // Sanitize approval reason to prevent injection attacks
        if req.Reason != "" </span><span class="cov0" title="0">{
                sanitized, err := SanitizeReasonText(req.Reason)
                if err != nil </span><span class="cov0" title="0">{
                        reqLog.Warnw("Failed to sanitize approval reason, using empty string", "error", err)
                        session.Status.Approval.Reason = "" // Use empty string as safe fallback
                }</span> else<span class="cov0" title="0"> {
                        session.Status.Approval.Reason = sanitized
                }</span>
        } else<span class="cov0" title="0"> {
                session.Status.Approval.Reason = req.Reason
        }</span>

        <span class="cov0" title="0">if err := applyDebugSessionStatus(apiCtx, c.client, session); err != nil </span><span class="cov0" title="0">{
                reqLog.Errorw("Failed to approve session", "session", name, "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to approve session")
                return
        }</span>

        // Send approval email to requester
        <span class="cov0" title="0">c.sendDebugSessionApprovalEmail(apiCtx, session)

        // Emit audit event for session approval
        c.emitDebugSessionAuditEvent(apiCtx, audit.EventDebugSessionStarted, session, currentUser.(string), "Debug session approved")

        reqLog.Infow("Debug session approved", "session", name, "approver", currentUser)
        metrics.DebugSessionApproved.WithLabelValues(session.Spec.Cluster, "user").Inc()

        // Return updated session - client expects the session object, not just a message
        ctx.JSON(http.StatusOK, session)</span>
}

// handleRejectDebugSession rejects a pending debug session
func (c *DebugSessionAPIController) handleRejectDebugSession(ctx *gin.Context) <span class="cov0" title="0">{
        reqLog := system.GetReqLogger(ctx, c.log)
        name := ctx.Param("name")
        namespaceHint := ctx.Query("namespace")

        var req ApprovalRequest
        _ = ctx.ShouldBindJSON(&amp;req) // Optional body with reason

        // Get current user
        currentUser, exists := ctx.Get("username")
        if !exists || currentUser == nil </span><span class="cov0" title="0">{
                apiresponses.RespondUnauthorized(ctx)
                return
        }</span>

        <span class="cov0" title="0">apiCtx, cancel := context.WithTimeout(ctx.Request.Context(), APIContextTimeout)
        defer cancel()

        session, err := c.getDebugSessionByName(apiCtx, name, namespaceHint)
        if err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        apiresponses.RespondNotFoundSimple(ctx, "debug session not found")
                        return
                }</span>
                <span class="cov0" title="0">reqLog.Errorw("Failed to get debug session", "name", name, "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to get debug session")
                return</span>
        }

        // Check session is pending approval
        <span class="cov0" title="0">if session.Status.State != v1alpha1.DebugSessionStatePendingApproval </span><span class="cov0" title="0">{
                apiresponses.RespondBadRequest(ctx, fmt.Sprintf("session is not pending approval (state: %s)", session.Status.State))
                return
        }</span>

        // Check if user is authorized to reject (in allowed approver groups)
        <span class="cov0" title="0">userGroups, _ := ctx.Get("groups")
        if !c.isUserAuthorizedToApprove(apiCtx, session, currentUser.(string), userGroups) </span><span class="cov0" title="0">{
                apiresponses.RespondForbidden(ctx, "user is not authorized to reject this session")
                return
        }</span>

        // Mark as rejected
        <span class="cov0" title="0">now := metav1.Now()
        if session.Status.Approval == nil </span><span class="cov0" title="0">{
                session.Status.Approval = &amp;v1alpha1.DebugSessionApproval{}
        }</span>
        <span class="cov0" title="0">session.Status.Approval.RejectedBy = currentUser.(string)
        session.Status.Approval.RejectedAt = &amp;now
        // Sanitize rejection reason to prevent injection attacks
        sanitizedReason := req.Reason
        if req.Reason != "" </span><span class="cov0" title="0">{
                var err error
                sanitizedReason, err = SanitizeReasonText(req.Reason)
                if err != nil </span><span class="cov0" title="0">{
                        reqLog.Warnw("Failed to sanitize rejection reason, using empty string", "error", err)
                        sanitizedReason = "" // Use empty string as safe fallback
                }</span>
        }
        <span class="cov0" title="0">session.Status.Approval.Reason = sanitizedReason

        // Move to terminated state
        session.Status.State = v1alpha1.DebugSessionStateTerminated
        session.Status.Message = fmt.Sprintf("Rejected by %s: %s", currentUser, sanitizedReason)

        if err := applyDebugSessionStatus(apiCtx, c.client, session); err != nil </span><span class="cov0" title="0">{
                reqLog.Errorw("Failed to reject session", "session", name, "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to reject session")
                return
        }</span>

        // Send rejection email to requester
        <span class="cov0" title="0">c.sendDebugSessionRejectionEmail(apiCtx, session)

        // Emit audit event for session rejection
        c.emitDebugSessionAuditEvent(apiCtx, audit.EventDebugSessionTerminated, session, currentUser.(string), fmt.Sprintf("Debug session rejected: %s", req.Reason))

        reqLog.Infow("Debug session rejected", "session", name, "rejector", currentUser, "reason", req.Reason)
        metrics.DebugSessionRejected.WithLabelValues(session.Spec.Cluster, "user_rejected").Inc()

        // Return updated session - client expects the session object, not just a message
        ctx.JSON(http.StatusOK, session)</span>
}

// handleLeaveDebugSession allows a participant to leave a session
func (c *DebugSessionAPIController) handleLeaveDebugSession(ctx *gin.Context) <span class="cov0" title="0">{
        reqLog := system.GetReqLogger(ctx, c.log)
        name := ctx.Param("name")
        namespaceHint := ctx.Query("namespace")

        // Get current user
        currentUser, exists := ctx.Get("username")
        if !exists || currentUser == nil </span><span class="cov0" title="0">{
                apiresponses.RespondUnauthorized(ctx)
                return
        }</span>

        <span class="cov0" title="0">apiCtx, cancel := context.WithTimeout(ctx.Request.Context(), APIContextTimeout)
        defer cancel()

        session, err := c.getDebugSessionByName(apiCtx, name, namespaceHint)
        if err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        apiresponses.RespondNotFoundSimple(ctx, "debug session not found")
                        return
                }</span>
                <span class="cov0" title="0">reqLog.Errorw("Failed to get debug session", "name", name, "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to get debug session")
                return</span>
        }

        // Find the participant
        <span class="cov0" title="0">username := currentUser.(string)
        found := false
        now := metav1.Now()
        for i := range session.Status.Participants </span><span class="cov0" title="0">{
                if session.Status.Participants[i].User == username </span><span class="cov0" title="0">{
                        // Check if owner - owners cannot leave
                        if session.Status.Participants[i].Role == v1alpha1.ParticipantRoleOwner </span><span class="cov0" title="0">{
                                apiresponses.RespondForbidden(ctx, "session owner cannot leave; use terminate instead")
                                return
                        }</span>
                        // Mark as left
                        <span class="cov0" title="0">session.Status.Participants[i].LeftAt = &amp;now
                        found = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                apiresponses.RespondNotFoundSimple(ctx, "user is not a participant in this session")
                return
        }</span>

        <span class="cov0" title="0">if err := applyDebugSessionStatus(apiCtx, c.client, session); err != nil </span><span class="cov0" title="0">{
                reqLog.Errorw("Failed to leave session", "session", name, "user", username, "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to leave session")
                return
        }</span>

        <span class="cov0" title="0">reqLog.Infow("User left debug session", "session", name, "user", username)
        // Update active participant count (exclude those who left)
        activeCount := 0
        for _, p := range session.Status.Participants </span><span class="cov0" title="0">{
                if p.LeftAt == nil </span><span class="cov0" title="0">{
                        activeCount++
                }</span>
        }
        <span class="cov0" title="0">metrics.DebugSessionParticipants.WithLabelValues(session.Spec.Cluster, name).Set(float64(activeCount))

        ctx.JSON(http.StatusOK, gin.H{"message": "successfully left session"})</span>
}

// DebugSessionTemplateResponse represents a template in API responses
type DebugSessionTemplateResponse struct {
        Name                  string                            `json:"name"`
        DisplayName           string                            `json:"displayName"`
        Description           string                            `json:"description,omitempty"`
        Mode                  v1alpha1.DebugSessionTemplateMode `json:"mode"`
        WorkloadType          v1alpha1.DebugWorkloadType        `json:"workloadType,omitempty"`
        PodTemplateRef        string                            `json:"podTemplateRef,omitempty"`
        TargetNamespace       string                            `json:"targetNamespace,omitempty"`
        Constraints           *v1alpha1.DebugSessionConstraints `json:"constraints,omitempty"`
        AllowedClusters       []string                          `json:"allowedClusters,omitempty"`
        AllowedGroups         []string                          `json:"allowedGroups,omitempty"`
        RequiresApproval      bool                              `json:"requiresApproval"`
        SchedulingOptions     *SchedulingOptionsResponse        `json:"schedulingOptions,omitempty"`
        NamespaceConstraints  *NamespaceConstraintsResponse     `json:"namespaceConstraints,omitempty"`
        ExtraDeployVariables  []v1alpha1.ExtraDeployVariable    `json:"extraDeployVariables,omitempty"`
        Priority              int32                             `json:"priority,omitempty"`
        Hidden                bool                              `json:"hidden,omitempty"`
        Deprecated            bool                              `json:"deprecated,omitempty"`
        DeprecationMessage    string                            `json:"deprecationMessage,omitempty"`
        HasAvailableClusters  bool                              `json:"hasAvailableClusters"`            // True if at least one cluster is available for this template
        AvailableClusterCount int                               `json:"availableClusterCount,omitempty"` // Number of clusters user can deploy to
}

// SchedulingOptionsResponse represents scheduling options in API responses
type SchedulingOptionsResponse struct {
        Required bool                       `json:"required"`
        Options  []SchedulingOptionResponse `json:"options"`
}

// SchedulingOptionResponse represents a single scheduling option in API responses
type SchedulingOptionResponse struct {
        Name                  string                        `json:"name"`
        DisplayName           string                        `json:"displayName"`
        Description           string                        `json:"description,omitempty"`
        Default               bool                          `json:"default,omitempty"`
        SchedulingConstraints *SchedulingConstraintsSummary `json:"schedulingConstraints,omitempty"`
}

// NamespaceConstraintsResponse represents namespace constraints in API responses
type NamespaceConstraintsResponse struct {
        AllowedPatterns       []string                        `json:"allowedPatterns,omitempty"`
        AllowedLabelSelectors []NamespaceSelectorTermResponse `json:"allowedLabelSelectors,omitempty"`
        DeniedPatterns        []string                        `json:"deniedPatterns,omitempty"`
        DeniedLabelSelectors  []NamespaceSelectorTermResponse `json:"deniedLabelSelectors,omitempty"`
        DefaultNamespace      string                          `json:"defaultNamespace,omitempty"`
        AllowUserNamespace    bool                            `json:"allowUserNamespace"`
}

// NamespaceSelectorTermResponse represents a label selector term in API responses
type NamespaceSelectorTermResponse struct {
        MatchLabels      map[string]string                      `json:"matchLabels,omitempty"`
        MatchExpressions []NamespaceSelectorRequirementResponse `json:"matchExpressions,omitempty"`
}

// NamespaceSelectorRequirementResponse represents a label selector requirement in API responses
type NamespaceSelectorRequirementResponse struct {
        Key      string   `json:"key"`
        Operator string   `json:"operator"`
        Values   []string `json:"values,omitempty"`
}

// DebugPodTemplateResponse represents a pod template in API responses
type DebugPodTemplateResponse struct {
        Name        string `json:"name"`
        DisplayName string `json:"displayName"`
        Description string `json:"description,omitempty"`
        Containers  int    `json:"containers"`
}

// TemplateClustersResponse represents the response for GET /templates/{name}/clusters
type TemplateClustersResponse struct {
        TemplateName        string                   `json:"templateName"`
        TemplateDisplayName string                   `json:"templateDisplayName"`
        Clusters            []AvailableClusterDetail `json:"clusters"`
}

// AvailableClusterDetail represents a cluster with resolved constraints for a template.
// When multiple bindings match a cluster, BindingOptions contains all available options.
// The first binding option (or BindingRef for backward compatibility) is the default.
type AvailableClusterDetail struct {
        Name                          string                            `json:"name"`
        DisplayName                   string                            `json:"displayName,omitempty"`
        Environment                   string                            `json:"environment,omitempty"`
        Location                      string                            `json:"location,omitempty"`
        Site                          string                            `json:"site,omitempty"`
        Tenant                        string                            `json:"tenant,omitempty"`
        BindingRef                    *BindingReference                 `json:"bindingRef,omitempty"`     // Default/primary binding (backward compat)
        BindingOptions                []BindingOption                   `json:"bindingOptions,omitempty"` // All available binding options
        Constraints                   *v1alpha1.DebugSessionConstraints `json:"constraints,omitempty"`    // Default constraints (from first binding)
        SchedulingConstraints         *SchedulingConstraintsSummary     `json:"schedulingConstraints,omitempty"`
        SchedulingOptions             *SchedulingOptionsResponse        `json:"schedulingOptions,omitempty"`
        NamespaceConstraints          *NamespaceConstraintsResponse     `json:"namespaceConstraints,omitempty"`
        Impersonation                 *ImpersonationSummary             `json:"impersonation,omitempty"`
        RequiredAuxResourceCategories []string                          `json:"requiredAuxiliaryResourceCategories,omitempty"`
        Approval                      *ApprovalInfo                     `json:"approval,omitempty"`
        RequestReason                 *ReasonConfigInfo                 `json:"requestReason,omitempty"`
        ApprovalReason                *ReasonConfigInfo                 `json:"approvalReason,omitempty"`
        Notification                  *NotificationConfigInfo           `json:"notification,omitempty"`
        Status                        *ClusterStatusInfo                `json:"status,omitempty"`
}

// BindingOption represents a single binding option for a cluster with its resolved configuration.
// When users select a cluster with multiple binding options, they can choose which binding to use.
type BindingOption struct {
        BindingRef                    BindingReference                  `json:"bindingRef"`
        DisplayName                   string                            `json:"displayName,omitempty"` // Effective display name for this binding
        Constraints                   *v1alpha1.DebugSessionConstraints `json:"constraints,omitempty"`
        SchedulingConstraints         *SchedulingConstraintsSummary     `json:"schedulingConstraints,omitempty"`
        SchedulingOptions             *SchedulingOptionsResponse        `json:"schedulingOptions,omitempty"`
        NamespaceConstraints          *NamespaceConstraintsResponse     `json:"namespaceConstraints,omitempty"`
        Impersonation                 *ImpersonationSummary             `json:"impersonation,omitempty"`
        RequiredAuxResourceCategories []string                          `json:"requiredAuxiliaryResourceCategories,omitempty"`
        Approval                      *ApprovalInfo                     `json:"approval,omitempty"`
        RequestReason                 *ReasonConfigInfo                 `json:"requestReason,omitempty"`
        ApprovalReason                *ReasonConfigInfo                 `json:"approvalReason,omitempty"`
        Notification                  *NotificationConfigInfo           `json:"notification,omitempty"`
}

// BindingReference identifies the binding that enabled access
type BindingReference struct {
        Name              string `json:"name"`
        Namespace         string `json:"namespace"`
        DisplayNamePrefix string `json:"displayNamePrefix,omitempty"`
}

// SchedulingConstraintsSummary summarizes scheduling constraints for API responses
type SchedulingConstraintsSummary struct {
        Summary          string              `json:"summary,omitempty"`
        NodeSelector     map[string]string   `json:"nodeSelector,omitempty"`
        DeniedNodeLabels map[string]string   `json:"deniedNodeLabels,omitempty"`
        Tolerations      []TolerationSummary `json:"tolerations,omitempty"`
}

// TolerationSummary summarizes a toleration for API responses
type TolerationSummary struct {
        Key      string `json:"key"`
        Operator string `json:"operator,omitempty"`
        Value    string `json:"value,omitempty"`
        Effect   string `json:"effect,omitempty"`
}

// ImpersonationSummary summarizes impersonation configuration for API responses
type ImpersonationSummary struct {
        Enabled        bool   `json:"enabled"`
        ServiceAccount string `json:"serviceAccount,omitempty"`
        Namespace      string `json:"namespace,omitempty"`
        Reason         string `json:"reason,omitempty"`
}

// ApprovalInfo contains approval requirements for a cluster
type ApprovalInfo struct {
        Required       bool     `json:"required"`
        ApproverGroups []string `json:"approverGroups,omitempty"`
        ApproverUsers  []string `json:"approverUsers,omitempty"`
        CanAutoApprove bool     `json:"canAutoApprove,omitempty"`
}

// ClusterStatusInfo contains cluster health status
type ClusterStatusInfo struct {
        Healthy     bool   `json:"healthy"`
        LastChecked string `json:"lastChecked,omitempty"`
}

// ReasonConfigInfo contains reason configuration for API responses
type ReasonConfigInfo struct {
        Mandatory        bool     `json:"mandatory"`
        Description      string   `json:"description,omitempty"`
        MinLength        int32    `json:"minLength,omitempty"`
        MaxLength        int32    `json:"maxLength,omitempty"`
        SuggestedReasons []string `json:"suggestedReasons,omitempty"`
}

// NotificationConfigInfo contains notification configuration for API responses
type NotificationConfigInfo struct {
        Enabled bool `json:"enabled"`
}

// handleListTemplates returns available debug session templates
// Uses the uncached apiReader if configured, for consistent reads after writes.
func (c *DebugSessionAPIController) handleListTemplates(ctx *gin.Context) <span class="cov0" title="0">{
        reqLog := system.GetReqLogger(ctx, c.log)

        templateList := &amp;v1alpha1.DebugSessionTemplateList{}
        apiCtx, cancel := context.WithTimeout(ctx.Request.Context(), APIContextTimeout)
        defer cancel()

        if err := c.reader().List(apiCtx, templateList); err != nil </span><span class="cov0" title="0">{
                reqLog.Errorw("Failed to list debug session templates", "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to list templates")
                return
        }</span>

        // Fetch all ClusterConfigs for pattern resolution
        <span class="cov0" title="0">clusterConfigList := &amp;v1alpha1.ClusterConfigList{}
        if err := c.reader().List(apiCtx, clusterConfigList); err != nil </span><span class="cov0" title="0">{
                reqLog.Warnw("Failed to list cluster configs for pattern resolution", "error", err)
                // Continue without pattern resolution - clusters will be empty
        }</span>
        <span class="cov0" title="0">allClusterNames := make([]string, 0, len(clusterConfigList.Items))
        clusterMap := make(map[string]*v1alpha1.ClusterConfig, len(clusterConfigList.Items))
        for i := range clusterConfigList.Items </span><span class="cov0" title="0">{
                cc := &amp;clusterConfigList.Items[i]
                allClusterNames = append(allClusterNames, cc.Name)
                clusterMap[cc.Name] = cc
        }</span>

        // Fetch all bindings to determine which templates have available clusters
        <span class="cov0" title="0">bindingList := &amp;v1alpha1.DebugSessionClusterBindingList{}
        if err := c.reader().List(apiCtx, bindingList); err != nil </span><span class="cov0" title="0">{
                reqLog.Warnw("Failed to list bindings for template cluster resolution", "error", err)
                // Continue without binding resolution
        }</span>

        // Get user's groups for filtering
        <span class="cov0" title="0">userGroups, _ := ctx.Get("groups")
        groups := []string{}
        if userGroups != nil </span><span class="cov0" title="0">{
                if g, ok := userGroups.([]string); ok </span><span class="cov0" title="0">{
                        groups = g
                }</span>
        }

        <span class="cov0" title="0">includeHidden := ctx.Query("includeHidden") == "true"
        includeUnavailable := ctx.Query("includeUnavailable") == "true"

        // Filter and transform
        var templates []DebugSessionTemplateResponse
        for _, t := range templateList.Items </span><span class="cov0" title="0">{
                if t.Spec.Hidden &amp;&amp; !includeHidden </span><span class="cov0" title="0">{
                        continue</span>
                }
                // Check if user has access to this template
                <span class="cov0" title="0">if t.Spec.Allowed != nil &amp;&amp; len(t.Spec.Allowed.Groups) &gt; 0 </span><span class="cov0" title="0">{
                        hasAccess := false
                        for _, allowedGroup := range t.Spec.Allowed.Groups </span><span class="cov0" title="0">{
                                if allowedGroup == "*" </span><span class="cov0" title="0">{
                                        hasAccess = true
                                        break</span>
                                }
                                <span class="cov0" title="0">for _, userGroup := range groups </span><span class="cov0" title="0">{
                                        if matchPattern(allowedGroup, userGroup) </span><span class="cov0" title="0">{
                                                hasAccess = true
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">if hasAccess </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !hasAccess </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                // Calculate available cluster count for this template
                <span class="cov0" title="0">availableClusterCount := c.countAvailableClustersForTemplate(&amp;t, bindingList.Items, clusterMap, allClusterNames)
                hasAvailableClusters := availableClusterCount &gt; 0

                // Skip templates without available clusters unless explicitly requested
                if !hasAvailableClusters &amp;&amp; !includeUnavailable </span><span class="cov0" title="0">{
                        reqLog.Debugw("Skipping template without available clusters",
                                "template", t.Name,
                                "includeUnavailable", includeUnavailable,
                        )
                        continue</span>
                }

                <span class="cov0" title="0">resp := DebugSessionTemplateResponse{
                        Name:                  t.Name,
                        DisplayName:           t.Spec.DisplayName,
                        Description:           t.Spec.Description,
                        Mode:                  t.Spec.Mode,
                        WorkloadType:          t.Spec.WorkloadType,
                        TargetNamespace:       t.Spec.TargetNamespace,
                        Constraints:           t.Spec.Constraints,
                        RequiresApproval:      t.Spec.Approvers != nil &amp;&amp; (len(t.Spec.Approvers.Groups) &gt; 0 || len(t.Spec.Approvers.Users) &gt; 0),
                        ExtraDeployVariables:  t.Spec.ExtraDeployVariables,
                        Priority:              t.Spec.Priority,
                        Hidden:                t.Spec.Hidden,
                        Deprecated:            t.Spec.Deprecated,
                        DeprecationMessage:    t.Spec.DeprecationMessage,
                        HasAvailableClusters:  hasAvailableClusters,
                        AvailableClusterCount: availableClusterCount,
                }

                if t.Spec.PodTemplateRef != nil </span><span class="cov0" title="0">{
                        resp.PodTemplateRef = t.Spec.PodTemplateRef.Name
                }</span>
                <span class="cov0" title="0">if t.Spec.Allowed != nil </span><span class="cov0" title="0">{
                        // Resolve cluster patterns to actual cluster names
                        resp.AllowedClusters = resolveClusterPatterns(t.Spec.Allowed.Clusters, allClusterNames)
                        resp.AllowedGroups = t.Spec.Allowed.Groups
                }</span>

                // Include scheduling options if present
                <span class="cov0" title="0">if t.Spec.SchedulingOptions != nil </span><span class="cov0" title="0">{
                        resp.SchedulingOptions = &amp;SchedulingOptionsResponse{
                                Required: t.Spec.SchedulingOptions.Required,
                                Options:  make([]SchedulingOptionResponse, 0, len(t.Spec.SchedulingOptions.Options)),
                        }
                        for _, opt := range t.Spec.SchedulingOptions.Options </span><span class="cov0" title="0">{
                                resp.SchedulingOptions.Options = append(resp.SchedulingOptions.Options, SchedulingOptionResponse{
                                        Name:                  opt.Name,
                                        DisplayName:           opt.DisplayName,
                                        Description:           opt.Description,
                                        Default:               opt.Default,
                                        SchedulingConstraints: buildConstraintsSummary(opt.SchedulingConstraints),
                                })
                        }</span>
                }

                // Include namespace constraints if present
                <span class="cov0" title="0">if t.Spec.NamespaceConstraints != nil </span><span class="cov0" title="0">{
                        resp.NamespaceConstraints = &amp;NamespaceConstraintsResponse{
                                DefaultNamespace:   t.Spec.NamespaceConstraints.DefaultNamespace,
                                AllowUserNamespace: t.Spec.NamespaceConstraints.AllowUserNamespace,
                        }
                        if t.Spec.NamespaceConstraints.AllowedNamespaces != nil </span><span class="cov0" title="0">{
                                resp.NamespaceConstraints.AllowedPatterns = t.Spec.NamespaceConstraints.AllowedNamespaces.Patterns
                                resp.NamespaceConstraints.AllowedLabelSelectors = convertSelectorTerms(t.Spec.NamespaceConstraints.AllowedNamespaces.SelectorTerms)
                        }</span>
                        <span class="cov0" title="0">if t.Spec.NamespaceConstraints.DeniedNamespaces != nil </span><span class="cov0" title="0">{
                                resp.NamespaceConstraints.DeniedPatterns = t.Spec.NamespaceConstraints.DeniedNamespaces.Patterns
                                resp.NamespaceConstraints.DeniedLabelSelectors = convertSelectorTerms(t.Spec.NamespaceConstraints.DeniedNamespaces.SelectorTerms)
                        }</span>
                }

                <span class="cov0" title="0">templates = append(templates, resp)</span>
        }

        <span class="cov0" title="0">sort.Slice(templates, func(i, j int) bool </span><span class="cov0" title="0">{
                if templates[i].Priority != templates[j].Priority </span><span class="cov0" title="0">{
                        return templates[i].Priority &gt; templates[j].Priority
                }</span>
                <span class="cov0" title="0">return templates[i].Name &lt; templates[j].Name</span>
        })

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{
                "templates": templates,
                "total":     len(templates),
        })</span>
}

// handleGetTemplate returns details for a specific template
// Uses the uncached apiReader if configured, for consistent reads after writes.
// Returns the same flat response format as the list endpoint.
func (c *DebugSessionAPIController) handleGetTemplate(ctx *gin.Context) <span class="cov0" title="0">{
        reqLog := system.GetReqLogger(ctx, c.log)
        name := ctx.Param("name")

        if name == "" </span><span class="cov0" title="0">{
                apiresponses.RespondBadRequest(ctx, "template name is required")
                return
        }</span>

        <span class="cov0" title="0">template := &amp;v1alpha1.DebugSessionTemplate{}
        apiCtx, cancel := context.WithTimeout(ctx.Request.Context(), APIContextTimeout)
        defer cancel()

        if err := c.reader().Get(apiCtx, ctrlclient.ObjectKey{Name: name}, template); err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        apiresponses.RespondNotFoundSimple(ctx, "template not found")
                        return
                }</span>
                <span class="cov0" title="0">reqLog.Errorw("Failed to get template", "name", name, "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to get template")
                return</span>
        }

        // Build response using same format as list endpoint
        <span class="cov0" title="0">resp := DebugSessionTemplateResponse{
                Name:                 template.Name,
                DisplayName:          template.Spec.DisplayName,
                Description:          template.Spec.Description,
                Mode:                 template.Spec.Mode,
                WorkloadType:         template.Spec.WorkloadType,
                TargetNamespace:      template.Spec.TargetNamespace,
                Constraints:          template.Spec.Constraints,
                RequiresApproval:     template.Spec.Approvers != nil &amp;&amp; (len(template.Spec.Approvers.Groups) &gt; 0 || len(template.Spec.Approvers.Users) &gt; 0),
                ExtraDeployVariables: template.Spec.ExtraDeployVariables,
                Priority:             template.Spec.Priority,
                Hidden:               template.Spec.Hidden,
                Deprecated:           template.Spec.Deprecated,
                DeprecationMessage:   template.Spec.DeprecationMessage,
        }

        if template.Spec.PodTemplateRef != nil </span><span class="cov0" title="0">{
                resp.PodTemplateRef = template.Spec.PodTemplateRef.Name
        }</span>
        <span class="cov0" title="0">if template.Spec.Allowed != nil </span><span class="cov0" title="0">{
                resp.AllowedClusters = template.Spec.Allowed.Clusters
                resp.AllowedGroups = template.Spec.Allowed.Groups
        }</span>

        // Include scheduling options if present
        <span class="cov0" title="0">if template.Spec.SchedulingOptions != nil </span><span class="cov0" title="0">{
                resp.SchedulingOptions = &amp;SchedulingOptionsResponse{
                        Required: template.Spec.SchedulingOptions.Required,
                        Options:  make([]SchedulingOptionResponse, 0, len(template.Spec.SchedulingOptions.Options)),
                }
                for _, opt := range template.Spec.SchedulingOptions.Options </span><span class="cov0" title="0">{
                        resp.SchedulingOptions.Options = append(resp.SchedulingOptions.Options, SchedulingOptionResponse{
                                Name:                  opt.Name,
                                DisplayName:           opt.DisplayName,
                                Description:           opt.Description,
                                Default:               opt.Default,
                                SchedulingConstraints: buildConstraintsSummary(opt.SchedulingConstraints),
                        })
                }</span>
        }

        // Include namespace constraints if present
        <span class="cov0" title="0">if template.Spec.NamespaceConstraints != nil </span><span class="cov0" title="0">{
                resp.NamespaceConstraints = &amp;NamespaceConstraintsResponse{
                        DefaultNamespace:   template.Spec.NamespaceConstraints.DefaultNamespace,
                        AllowUserNamespace: template.Spec.NamespaceConstraints.AllowUserNamespace,
                }
                if template.Spec.NamespaceConstraints.AllowedNamespaces != nil </span><span class="cov0" title="0">{
                        resp.NamespaceConstraints.AllowedPatterns = template.Spec.NamespaceConstraints.AllowedNamespaces.Patterns
                        resp.NamespaceConstraints.AllowedLabelSelectors = convertSelectorTerms(template.Spec.NamespaceConstraints.AllowedNamespaces.SelectorTerms)
                }</span>
                <span class="cov0" title="0">if template.Spec.NamespaceConstraints.DeniedNamespaces != nil </span><span class="cov0" title="0">{
                        resp.NamespaceConstraints.DeniedPatterns = template.Spec.NamespaceConstraints.DeniedNamespaces.Patterns
                        resp.NamespaceConstraints.DeniedLabelSelectors = convertSelectorTerms(template.Spec.NamespaceConstraints.DeniedNamespaces.SelectorTerms)
                }</span>
        }

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, resp)</span>
}

// handleGetTemplateClusters returns cluster-specific details for a template
func (c *DebugSessionAPIController) handleGetTemplateClusters(ctx *gin.Context) <span class="cov0" title="0">{
        reqLog := system.GetReqLogger(ctx, c.log)
        name := ctx.Param("name")

        if name == "" </span><span class="cov0" title="0">{
                apiresponses.RespondBadRequest(ctx, "template name is required")
                return
        }</span>

        <span class="cov0" title="0">apiCtx, cancel := context.WithTimeout(ctx.Request.Context(), APIContextTimeout)
        defer cancel()

        // Fetch the template
        template := &amp;v1alpha1.DebugSessionTemplate{}
        if err := c.client.Get(apiCtx, ctrlclient.ObjectKey{Name: name}, template); err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        apiresponses.RespondNotFoundSimple(ctx, "template not found")
                        return
                }</span>
                <span class="cov0" title="0">reqLog.Errorw("Failed to get template", "name", name, "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to get template")
                return</span>
        }

        // Get user's groups for filtering
        <span class="cov0" title="0">userGroups, _ := ctx.Get("groups")
        groups := []string{}
        if userGroups != nil </span><span class="cov0" title="0">{
                if g, ok := userGroups.([]string); ok </span><span class="cov0" title="0">{
                        groups = g
                }</span>
        }

        // Check if user has access to this template
        <span class="cov0" title="0">if template.Spec.Allowed != nil &amp;&amp; len(template.Spec.Allowed.Groups) &gt; 0 </span><span class="cov0" title="0">{
                hasAccess := false
                for _, allowedGroup := range template.Spec.Allowed.Groups </span><span class="cov0" title="0">{
                        if allowedGroup == "*" </span><span class="cov0" title="0">{
                                hasAccess = true
                                break</span>
                        }
                        <span class="cov0" title="0">for _, userGroup := range groups </span><span class="cov0" title="0">{
                                if matchPattern(allowedGroup, userGroup) </span><span class="cov0" title="0">{
                                        hasAccess = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if hasAccess </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !hasAccess </span><span class="cov0" title="0">{
                        apiresponses.RespondForbidden(ctx, "access denied to this template")
                        return
                }</span>
        }

        // Fetch ClusterConfigs and ClusterBindings in parallel for performance
        <span class="cov0" title="0">var clusterConfigList v1alpha1.ClusterConfigList
        var bindingList v1alpha1.DebugSessionClusterBindingList
        var ccErr, bindErr error

        // Use goroutines with sync.WaitGroup for parallel fetching
        var wg sync.WaitGroup
        wg.Add(2)

        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                ccErr = c.client.List(apiCtx, &amp;clusterConfigList)
        }</span>()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                bindErr = c.client.List(apiCtx, &amp;bindingList)
        }</span>()

        <span class="cov0" title="0">wg.Wait()

        if ccErr != nil </span><span class="cov0" title="0">{
                reqLog.Errorw("Failed to list cluster configs", "error", ccErr)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to list clusters")
                return
        }</span>

        <span class="cov0" title="0">if bindErr != nil </span><span class="cov0" title="0">{
                reqLog.Errorw("Failed to list cluster bindings", "error", bindErr)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to list bindings")
                return
        }</span>

        // Build cluster name -&gt; ClusterConfig map
        <span class="cov0" title="0">clusterMap := make(map[string]*v1alpha1.ClusterConfig, len(clusterConfigList.Items))
        for i := range clusterConfigList.Items </span><span class="cov0" title="0">{
                cc := &amp;clusterConfigList.Items[i]
                clusterMap[cc.Name] = cc
        }</span>

        // Find all bindings that apply to this template
        <span class="cov0" title="0">applicableBindings := c.findBindingsForTemplate(template, bindingList.Items)

        // Build the response - resolve clusters from bindings and template's allowed.clusters
        clusterDetails := c.resolveTemplateClusters(template, applicableBindings, clusterMap, groups)

        // Apply optional query filters
        environment := ctx.Query("environment")
        location := ctx.Query("location")
        bindingName := ctx.Query("bindingName")

        filteredClusters := make([]AvailableClusterDetail, 0, len(clusterDetails))
        for _, cd := range clusterDetails </span><span class="cov0" title="0">{
                if environment != "" &amp;&amp; cd.Environment != environment </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if location != "" &amp;&amp; cd.Location != location </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if bindingName != "" &amp;&amp; (cd.BindingRef == nil || cd.BindingRef.Name != bindingName) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">filteredClusters = append(filteredClusters, cd)</span>
        }

        <span class="cov0" title="0">response := TemplateClustersResponse{
                TemplateName:        template.Name,
                TemplateDisplayName: template.Spec.DisplayName,
                Clusters:            filteredClusters,
        }

        ctx.JSON(http.StatusOK, response)</span>
}

// countAvailableClustersForTemplate counts how many clusters are available for a template.
// It considers both bindings and direct template.Spec.Allowed.Clusters patterns.
func (c *DebugSessionAPIController) countAvailableClustersForTemplate(
        template *v1alpha1.DebugSessionTemplate,
        allBindings []v1alpha1.DebugSessionClusterBinding,
        clusterMap map[string]*v1alpha1.ClusterConfig,
        allClusterNames []string,
) int <span class="cov0" title="0">{
        seenClusters := make(map[string]bool)

        // Find bindings that match this template
        applicableBindings := c.findBindingsForTemplate(template, allBindings)

        // Collect clusters from bindings
        for i := range applicableBindings </span><span class="cov0" title="0">{
                binding := &amp;applicableBindings[i]
                bindingClusters := c.resolveClustersFromBinding(binding, clusterMap)
                for _, clusterName := range bindingClusters </span><span class="cov0" title="0">{
                        if clusterMap[clusterName] != nil </span><span class="cov0" title="0">{
                                seenClusters[clusterName] = true
                        }</span>
                }
        }

        // Also check template's direct allowed.clusters patterns
        <span class="cov0" title="0">if template.Spec.Allowed != nil &amp;&amp; len(template.Spec.Allowed.Clusters) &gt; 0 </span><span class="cov0" title="0">{
                resolvedClusters := resolveClusterPatterns(template.Spec.Allowed.Clusters, allClusterNames)
                for _, clusterName := range resolvedClusters </span><span class="cov0" title="0">{
                        if clusterMap[clusterName] != nil </span><span class="cov0" title="0">{
                                seenClusters[clusterName] = true
                        }</span>
                }
        }

        <span class="cov0" title="0">return len(seenClusters)</span>
}

// findBindingsForTemplate returns all bindings that reference the given template
func (c *DebugSessionAPIController) findBindingsForTemplate(template *v1alpha1.DebugSessionTemplate, bindings []v1alpha1.DebugSessionClusterBinding) []v1alpha1.DebugSessionClusterBinding <span class="cov0" title="0">{
        var result []v1alpha1.DebugSessionClusterBinding
        for i := range bindings </span><span class="cov0" title="0">{
                binding := &amp;bindings[i]
                bindingID := fmt.Sprintf("%s/%s", binding.Namespace, binding.Name)
                if !IsBindingActive(binding) </span><span class="cov0" title="0">{
                        c.log.Debugw("findBindingsForTemplate: skipping inactive binding",
                                "template", template.Name,
                                "binding", bindingID,
                        )
                        continue</span>
                }
                // Check templateRef
                <span class="cov0" title="0">if binding.Spec.TemplateRef != nil &amp;&amp; binding.Spec.TemplateRef.Name == template.Name </span><span class="cov0" title="0">{
                        c.log.Debugw("findBindingsForTemplate: matched by templateRef",
                                "template", template.Name,
                                "binding", bindingID,
                        )
                        result = append(result, *binding)
                        continue</span>
                }
                // Check templateSelector
                <span class="cov0" title="0">if binding.Spec.TemplateSelector != nil </span><span class="cov0" title="0">{
                        selector, err := metav1.LabelSelectorAsSelector(binding.Spec.TemplateSelector)
                        if err != nil </span><span class="cov0" title="0">{
                                c.log.Warnw("findBindingsForTemplate: failed to parse templateSelector",
                                        "binding", bindingID,
                                        "error", err,
                                )
                        }</span> else<span class="cov0" title="0"> {
                                labelSet := labelSetFromMap(template.Labels)
                                matches := selector.Matches(labelSet)
                                c.log.Debugw("findBindingsForTemplate: checking templateSelector",
                                        "template", template.Name,
                                        "templateLabels", template.Labels,
                                        "binding", bindingID,
                                        "selectorString", selector.String(),
                                        "matches", matches,
                                )
                                if matches </span><span class="cov0" title="0">{
                                        result = append(result, *binding)
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return result</span>
}

// resolveTemplateClusters resolves all available clusters for a template.
// When multiple bindings match the same cluster, all binding options are returned
// so users can select which binding configuration to use.
func (c *DebugSessionAPIController) resolveTemplateClusters(template *v1alpha1.DebugSessionTemplate, bindings []v1alpha1.DebugSessionClusterBinding, clusterMap map[string]*v1alpha1.ClusterConfig, userGroups []string) []AvailableClusterDetail <span class="cov0" title="0">{
        // Build a map of cluster -&gt; all matching bindings
        clusterBindings := make(map[string][]*v1alpha1.DebugSessionClusterBinding)

        // Collect all bindings for each cluster
        for i := range bindings </span><span class="cov0" title="0">{
                binding := &amp;bindings[i]
                bindingClusters := c.resolveClustersFromBinding(binding, clusterMap)
                for _, clusterName := range bindingClusters </span><span class="cov0" title="0">{
                        clusterBindings[clusterName] = append(clusterBindings[clusterName], binding)
                }</span>
        }

        <span class="cov0" title="0">var result []AvailableClusterDetail
        seenClusters := make(map[string]bool)

        // Build cluster details with all binding options
        for clusterName, matchingBindings := range clusterBindings </span><span class="cov0" title="0">{
                if seenClusters[clusterName] </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">seenClusters[clusterName] = true

                cc := clusterMap[clusterName]
                if cc == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Build detail with all binding options
                <span class="cov0" title="0">detail := c.buildClusterDetailWithBindings(template, matchingBindings, cc, userGroups)
                result = append(result, detail)</span>
        }

        // Then, resolve clusters from template's allowed.clusters (fallback, no binding)
        <span class="cov0" title="0">if template.Spec.Allowed != nil &amp;&amp; len(template.Spec.Allowed.Clusters) &gt; 0 </span><span class="cov0" title="0">{
                allClusterNames := make([]string, 0, len(clusterMap))
                for name := range clusterMap </span><span class="cov0" title="0">{
                        allClusterNames = append(allClusterNames, name)
                }</span>
                <span class="cov0" title="0">allowedClusters := resolveClusterPatterns(template.Spec.Allowed.Clusters, allClusterNames)
                for _, clusterName := range allowedClusters </span><span class="cov0" title="0">{
                        if seenClusters[clusterName] </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">seenClusters[clusterName] = true

                        cc := clusterMap[clusterName]
                        if cc == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // No binding - use template defaults
                        <span class="cov0" title="0">detail := c.buildClusterDetailWithBindings(template, nil, cc, userGroups)
                        result = append(result, detail)</span>
                }
        }

        <span class="cov0" title="0">return result</span>
}

// buildClusterDetailWithBindings creates a cluster detail with all matching binding options.
// The first binding becomes the default (for backward compatibility with BindingRef).
func (c *DebugSessionAPIController) buildClusterDetailWithBindings(template *v1alpha1.DebugSessionTemplate, matchingBindings []*v1alpha1.DebugSessionClusterBinding, cc *v1alpha1.ClusterConfig, userGroups []string) AvailableClusterDetail <span class="cov0" title="0">{
        detail := AvailableClusterDetail{
                Name:        cc.Name,
                DisplayName: cc.Name,
                Environment: cc.Labels["environment"],
                Location:    cc.Labels["location"],
                Site:        cc.Labels["site"],
                Tenant:      cc.Labels["tenant"],
                Status:      c.resolveClusterStatus(cc),
        }

        if len(matchingBindings) == 0 </span><span class="cov0" title="0">{
                // No bindings - use template defaults
                detail.Constraints = template.Spec.Constraints
                detail.SchedulingConstraints = c.getSchedulingConstraintsSummary(template, nil)
                detail.SchedulingOptions = c.resolveSchedulingOptions(template, nil)
                detail.NamespaceConstraints = c.resolveNamespaceConstraints(template, nil)
                detail.Impersonation = c.resolveImpersonation(template, nil)
                detail.Approval = c.resolveApproval(template, nil, cc, userGroups)
                detail.RequiredAuxResourceCategories = c.resolveRequiredAuxResourceCategories(template, nil)
                return detail
        }</span>

        // Build all binding options
        <span class="cov0" title="0">detail.BindingOptions = make([]BindingOption, 0, len(matchingBindings))
        for _, binding := range matchingBindings </span><span class="cov0" title="0">{
                effectiveDisplayName := v1alpha1.GetEffectiveDisplayName(binding, template.Spec.DisplayName, template.Name)
                option := BindingOption{
                        BindingRef: BindingReference{
                                Name:              binding.Name,
                                Namespace:         binding.Namespace,
                                DisplayNamePrefix: binding.Spec.DisplayNamePrefix,
                        },
                        DisplayName:                   effectiveDisplayName,
                        Constraints:                   c.mergeConstraints(template.Spec.Constraints, binding),
                        SchedulingConstraints:         c.getSchedulingConstraintsSummary(template, binding),
                        SchedulingOptions:             c.resolveSchedulingOptions(template, binding),
                        NamespaceConstraints:          c.resolveNamespaceConstraints(template, binding),
                        Impersonation:                 c.resolveImpersonation(template, binding),
                        RequiredAuxResourceCategories: c.resolveRequiredAuxResourceCategories(template, binding),
                        Approval:                      c.resolveApproval(template, binding, cc, userGroups),
                        RequestReason:                 c.resolveRequestReason(template, binding),
                        ApprovalReason:                c.resolveApprovalReason(template, binding),
                        Notification:                  c.resolveNotification(template, binding),
                }
                detail.BindingOptions = append(detail.BindingOptions, option)
        }</span>

        // Set primary binding (first one) for backward compatibility
        <span class="cov0" title="0">if len(matchingBindings) &gt; 0 </span><span class="cov0" title="0">{
                primaryBinding := matchingBindings[0]
                detail.BindingRef = &amp;BindingReference{
                        Name:              primaryBinding.Name,
                        Namespace:         primaryBinding.Namespace,
                        DisplayNamePrefix: primaryBinding.Spec.DisplayNamePrefix,
                }
                // Set default constraints from primary binding for backward compatibility
                detail.Constraints = c.mergeConstraints(template.Spec.Constraints, primaryBinding)
                detail.SchedulingConstraints = c.getSchedulingConstraintsSummary(template, primaryBinding)
                detail.SchedulingOptions = c.resolveSchedulingOptions(template, primaryBinding)
                detail.NamespaceConstraints = c.resolveNamespaceConstraints(template, primaryBinding)
                detail.Impersonation = c.resolveImpersonation(template, primaryBinding)
                detail.Approval = c.resolveApproval(template, primaryBinding, cc, userGroups)
                detail.RequiredAuxResourceCategories = c.resolveRequiredAuxResourceCategories(template, primaryBinding)
                detail.RequestReason = c.resolveRequestReason(template, primaryBinding)
                detail.ApprovalReason = c.resolveApprovalReason(template, primaryBinding)
                detail.Notification = c.resolveNotification(template, primaryBinding)
        }</span>

        <span class="cov0" title="0">return detail</span>
}

// resolveClustersFromBinding resolves cluster names from a binding's spec
func (c *DebugSessionAPIController) resolveClustersFromBinding(binding *v1alpha1.DebugSessionClusterBinding, clusterMap map[string]*v1alpha1.ClusterConfig) []string <span class="cov0" title="0">{
        var result []string
        bindingID := fmt.Sprintf("%s/%s", binding.Namespace, binding.Name)

        // Add explicit clusters
        for _, clusterName := range binding.Spec.Clusters </span><span class="cov0" title="0">{
                if _, exists := clusterMap[clusterName]; exists </span><span class="cov0" title="0">{
                        result = append(result, clusterName)
                }</span>
        }

        <span class="cov0" title="0">c.log.Debugw("resolveClustersFromBinding: explicit clusters",
                "binding", bindingID,
                "explicitClusters", binding.Spec.Clusters,
                "matchedExplicitClusters", result,
        )

        // Add clusters matching selector
        if binding.Spec.ClusterSelector != nil </span><span class="cov0" title="0">{
                selector, err := metav1.LabelSelectorAsSelector(binding.Spec.ClusterSelector)
                if err != nil </span><span class="cov0" title="0">{
                        c.log.Warnw("resolveClustersFromBinding: failed to parse clusterSelector",
                                "binding", bindingID,
                                "error", err,
                        )
                }</span> else<span class="cov0" title="0"> {
                        selectorString := selector.String()
                        c.log.Debugw("resolveClustersFromBinding: checking clusterSelector",
                                "binding", bindingID,
                                "selectorString", selectorString,
                                "clusterMapSize", len(clusterMap),
                        )
                        for name, cc := range clusterMap </span><span class="cov0" title="0">{
                                labelSet := labelSetFromMap(cc.Labels)
                                matches := selector.Matches(labelSet)
                                if matches </span><span class="cov0" title="0">{
                                        result = append(result, name)
                                        c.log.Debugw("resolveClustersFromBinding: cluster matched selector",
                                                "binding", bindingID,
                                                "cluster", name,
                                                "clusterLabels", cc.Labels,
                                        )
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">c.log.Debugw("resolveClustersFromBinding: final result",
                "binding", bindingID,
                "resolvedClusters", result,
        )

        return result</span>
}

// mergeConstraints merges template and binding constraints
func (c *DebugSessionAPIController) mergeConstraints(templateConstraints *v1alpha1.DebugSessionConstraints, binding *v1alpha1.DebugSessionClusterBinding) *v1alpha1.DebugSessionConstraints <span class="cov0" title="0">{
        if binding == nil || binding.Spec.Constraints == nil </span><span class="cov0" title="0">{
                return templateConstraints
        }</span>
        <span class="cov0" title="0">if templateConstraints == nil </span><span class="cov0" title="0">{
                return binding.Spec.Constraints
        }</span>

        // Binding constraints override template constraints
        <span class="cov0" title="0">merged := templateConstraints.DeepCopy()
        bc := binding.Spec.Constraints

        if bc.MaxDuration != "" </span><span class="cov0" title="0">{
                merged.MaxDuration = bc.MaxDuration
        }</span>
        <span class="cov0" title="0">if bc.DefaultDuration != "" </span><span class="cov0" title="0">{
                merged.DefaultDuration = bc.DefaultDuration
        }</span>
        <span class="cov0" title="0">if bc.MaxConcurrentSessions &gt; 0 </span><span class="cov0" title="0">{
                merged.MaxConcurrentSessions = bc.MaxConcurrentSessions
        }</span>
        <span class="cov0" title="0">if bc.MaxRenewals != nil </span><span class="cov0" title="0">{
                merged.MaxRenewals = bc.MaxRenewals
        }</span>

        <span class="cov0" title="0">return merged</span>
}

// getSchedulingConstraintsSummary builds a summary of scheduling constraints
func (c *DebugSessionAPIController) getSchedulingConstraintsSummary(template *v1alpha1.DebugSessionTemplate, binding *v1alpha1.DebugSessionClusterBinding) *SchedulingConstraintsSummary <span class="cov0" title="0">{
        var sc *v1alpha1.SchedulingConstraints

        // Binding constraints take precedence
        if binding != nil &amp;&amp; binding.Spec.SchedulingConstraints != nil </span><span class="cov0" title="0">{
                sc = binding.Spec.SchedulingConstraints
        }</span> else<span class="cov0" title="0"> if template.Spec.SchedulingConstraints != nil </span><span class="cov0" title="0">{
                sc = template.Spec.SchedulingConstraints
        }</span>

        <span class="cov0" title="0">if sc == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return buildConstraintsSummary(sc)</span>
}

// buildConstraintsSummary builds a SchedulingConstraintsSummary from SchedulingConstraints.
// Shared between cluster-level and per-option constraint summaries.
func buildConstraintsSummary(sc *v1alpha1.SchedulingConstraints) *SchedulingConstraintsSummary <span class="cov0" title="0">{
        if sc == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">summary := &amp;SchedulingConstraintsSummary{
                NodeSelector:     sc.NodeSelector,
                DeniedNodeLabels: sc.DeniedNodeLabels,
        }

        // Convert tolerations to summaries
        if len(sc.Tolerations) &gt; 0 </span><span class="cov0" title="0">{
                summary.Tolerations = make([]TolerationSummary, 0, len(sc.Tolerations))
                for _, t := range sc.Tolerations </span><span class="cov0" title="0">{
                        summary.Tolerations = append(summary.Tolerations, TolerationSummary{
                                Key:      t.Key,
                                Operator: string(t.Operator),
                                Value:    t.Value,
                                Effect:   string(t.Effect),
                        })
                }</span>
        }

        // Build summary string
        <span class="cov0" title="0">var parts []string
        if len(sc.DeniedNodeLabels) &gt; 0 </span><span class="cov0" title="0">{
                parts = append(parts, "Some node labels are restricted")
        }</span>
        <span class="cov0" title="0">if len(sc.NodeSelector) &gt; 0 </span><span class="cov0" title="0">{
                parts = append(parts, "Specific node labels required")
        }</span>
        <span class="cov0" title="0">if len(sc.DeniedNodes) &gt; 0 </span><span class="cov0" title="0">{
                parts = append(parts, "Some nodes are denied")
        }</span>
        <span class="cov0" title="0">if len(sc.Tolerations) &gt; 0 </span><span class="cov0" title="0">{
                parts = append(parts, "Custom tolerations applied")
        }</span>
        <span class="cov0" title="0">if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                summary.Summary = strings.Join(parts, "; ")
        }</span>

        <span class="cov0" title="0">return summary</span>
}

// resolveSchedulingOptions resolves scheduling options from binding or template
func (c *DebugSessionAPIController) resolveSchedulingOptions(template *v1alpha1.DebugSessionTemplate, binding *v1alpha1.DebugSessionClusterBinding) *SchedulingOptionsResponse <span class="cov0" title="0">{
        var so *v1alpha1.SchedulingOptions

        // Binding options take precedence
        if binding != nil &amp;&amp; binding.Spec.SchedulingOptions != nil </span><span class="cov0" title="0">{
                so = binding.Spec.SchedulingOptions
        }</span> else<span class="cov0" title="0"> if template.Spec.SchedulingOptions != nil </span><span class="cov0" title="0">{
                so = template.Spec.SchedulingOptions
        }</span>

        <span class="cov0" title="0">if so == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">response := &amp;SchedulingOptionsResponse{
                Required: so.Required,
                Options:  make([]SchedulingOptionResponse, 0, len(so.Options)),
        }

        for _, opt := range so.Options </span><span class="cov0" title="0">{
                response.Options = append(response.Options, SchedulingOptionResponse{
                        Name:                  opt.Name,
                        DisplayName:           opt.DisplayName,
                        Description:           opt.Description,
                        Default:               opt.Default,
                        SchedulingConstraints: buildConstraintsSummary(opt.SchedulingConstraints),
                })
        }</span>

        <span class="cov0" title="0">return response</span>
}

// resolveNamespaceConstraints resolves namespace constraints from binding or template
func (c *DebugSessionAPIController) resolveNamespaceConstraints(template *v1alpha1.DebugSessionTemplate, binding *v1alpha1.DebugSessionClusterBinding) *NamespaceConstraintsResponse <span class="cov0" title="0">{
        var nc *v1alpha1.NamespaceConstraints

        // Binding constraints take precedence
        if binding != nil &amp;&amp; binding.Spec.NamespaceConstraints != nil </span><span class="cov0" title="0">{
                nc = binding.Spec.NamespaceConstraints
        }</span> else<span class="cov0" title="0"> if template.Spec.NamespaceConstraints != nil </span><span class="cov0" title="0">{
                nc = template.Spec.NamespaceConstraints
        }</span>

        <span class="cov0" title="0">if nc == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">response := &amp;NamespaceConstraintsResponse{
                DefaultNamespace:   nc.DefaultNamespace,
                AllowUserNamespace: nc.AllowUserNamespace,
        }

        if nc.AllowedNamespaces != nil </span><span class="cov0" title="0">{
                response.AllowedPatterns = nc.AllowedNamespaces.Patterns
                response.AllowedLabelSelectors = convertSelectorTerms(nc.AllowedNamespaces.SelectorTerms)
        }</span>
        <span class="cov0" title="0">if nc.DeniedNamespaces != nil </span><span class="cov0" title="0">{
                response.DeniedPatterns = nc.DeniedNamespaces.Patterns
                response.DeniedLabelSelectors = convertSelectorTerms(nc.DeniedNamespaces.SelectorTerms)
        }</span>

        <span class="cov0" title="0">return response</span>
}

// resolveImpersonation resolves impersonation settings from binding or template
func (c *DebugSessionAPIController) resolveImpersonation(template *v1alpha1.DebugSessionTemplate, binding *v1alpha1.DebugSessionClusterBinding) *ImpersonationSummary <span class="cov0" title="0">{
        var imp *v1alpha1.ImpersonationConfig

        // Binding impersonation takes precedence
        if binding != nil &amp;&amp; binding.Spec.Impersonation != nil </span><span class="cov0" title="0">{
                imp = binding.Spec.Impersonation
        }</span> else<span class="cov0" title="0"> if template.Spec.Impersonation != nil </span><span class="cov0" title="0">{
                imp = template.Spec.Impersonation
        }</span>

        <span class="cov0" title="0">if imp == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">summary := &amp;ImpersonationSummary{
                Enabled: true,
        }

        if imp.ServiceAccountRef != nil </span><span class="cov0" title="0">{
                summary.ServiceAccount = imp.ServiceAccountRef.Name
                summary.Namespace = imp.ServiceAccountRef.Namespace
        }</span>

        <span class="cov0" title="0">return summary</span>
}

// resolveApproval resolves approval requirements from binding, template, or ClusterConfig.
// It also evaluates AutoApproveFor conditions to determine if the current user
// would be auto-approved, matching the logic in the reconciler's requiresApproval().
func (c *DebugSessionAPIController) resolveApproval(template *v1alpha1.DebugSessionTemplate, binding *v1alpha1.DebugSessionClusterBinding, cc *v1alpha1.ClusterConfig, userGroups []string) *ApprovalInfo <span class="cov0" title="0">{
        info := &amp;ApprovalInfo{}

        var autoApproveFor *v1alpha1.AutoApproveConfig

        // Check binding approvers first
        if binding != nil &amp;&amp; binding.Spec.Approvers != nil </span><span class="cov0" title="0">{
                info.Required = len(binding.Spec.Approvers.Groups) &gt; 0 || len(binding.Spec.Approvers.Users) &gt; 0
                info.ApproverGroups = binding.Spec.Approvers.Groups
                info.ApproverUsers = binding.Spec.Approvers.Users
                autoApproveFor = binding.Spec.Approvers.AutoApproveFor
        }</span> else<span class="cov0" title="0"> if template.Spec.Approvers != nil </span><span class="cov0" title="0">{
                // Check template approvers
                info.Required = len(template.Spec.Approvers.Groups) &gt; 0 || len(template.Spec.Approvers.Users) &gt; 0
                info.ApproverGroups = template.Spec.Approvers.Groups
                info.ApproverUsers = template.Spec.Approvers.Users
                autoApproveFor = template.Spec.Approvers.AutoApproveFor
        }</span>

        // Evaluate auto-approve conditions if approval is required
        <span class="cov0" title="0">if info.Required &amp;&amp; autoApproveFor != nil </span><span class="cov0" title="0">{
                info.CanAutoApprove = c.evaluateAutoApprove(autoApproveFor, cc.Name, userGroups)
        }</span>

        <span class="cov0" title="0">return info</span>
}

// evaluateAutoApprove checks if auto-approve conditions are met for the given cluster and user groups.
// This mirrors the reconciler's checkAutoApprove() logic for API preview purposes.
func (c *DebugSessionAPIController) evaluateAutoApprove(autoApprove *v1alpha1.AutoApproveConfig, clusterName string, userGroups []string) bool <span class="cov0" title="0">{
        // Check cluster patterns
        for _, pattern := range autoApprove.Clusters </span><span class="cov0" title="0">{
                if matched, _ := filepath.Match(pattern, clusterName); matched </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        // Check group matches
        <span class="cov0" title="0">for _, autoApproveGroup := range autoApprove.Groups </span><span class="cov0" title="0">{
                for _, userGroup := range userGroups </span><span class="cov0" title="0">{
                        if userGroup == autoApproveGroup </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">return false</span>
}

// resolveClusterStatus returns cluster health status
func (c *DebugSessionAPIController) resolveClusterStatus(cc *v1alpha1.ClusterConfig) *ClusterStatusInfo <span class="cov0" title="0">{
        status := &amp;ClusterStatusInfo{}

        // Check for Ready condition
        for _, cond := range cc.Status.Conditions </span><span class="cov0" title="0">{
                if cond.Type == string(v1alpha1.ClusterConfigConditionReady) </span><span class="cov0" title="0">{
                        status.Healthy = cond.Status == metav1.ConditionTrue
                        status.LastChecked = cond.LastTransitionTime.Format("2006-01-02T15:04:05Z")
                        break</span>
                }
        }

        <span class="cov0" title="0">return status</span>
}

// resolveRequiredAuxResourceCategories returns required auxiliary resource categories
// from binding or template configuration.
func (c *DebugSessionAPIController) resolveRequiredAuxResourceCategories(template *v1alpha1.DebugSessionTemplate, binding *v1alpha1.DebugSessionClusterBinding) []string <span class="cov0" title="0">{
        // Collect categories from both template and binding
        categories := make(map[string]bool)

        // Template required categories take precedence
        if template.Spec.RequiredAuxiliaryResourceCategories != nil </span><span class="cov0" title="0">{
                for _, cat := range template.Spec.RequiredAuxiliaryResourceCategories </span><span class="cov0" title="0">{
                        categories[cat] = true
                }</span>
        }

        // Binding required categories are added
        <span class="cov0" title="0">if binding != nil &amp;&amp; len(binding.Spec.RequiredAuxiliaryResourceCategories) &gt; 0 </span><span class="cov0" title="0">{
                for _, cat := range binding.Spec.RequiredAuxiliaryResourceCategories </span><span class="cov0" title="0">{
                        categories[cat] = true
                }</span>
        }

        <span class="cov0" title="0">if len(categories) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := make([]string, 0, len(categories))
        for cat := range categories </span><span class="cov0" title="0">{
                result = append(result, cat)
        }</span>
        <span class="cov0" title="0">return result</span>
}

// resolveRequestReason resolves request reason configuration from binding or template
func (c *DebugSessionAPIController) resolveRequestReason(template *v1alpha1.DebugSessionTemplate, binding *v1alpha1.DebugSessionClusterBinding) *ReasonConfigInfo <span class="cov0" title="0">{
        // Binding overrides template
        if binding != nil &amp;&amp; binding.Spec.RequestReason != nil </span><span class="cov0" title="0">{
                return &amp;ReasonConfigInfo{
                        Mandatory:        binding.Spec.RequestReason.Mandatory,
                        Description:      binding.Spec.RequestReason.Description,
                        MinLength:        binding.Spec.RequestReason.MinLength,
                        MaxLength:        binding.Spec.RequestReason.MaxLength,
                        SuggestedReasons: binding.Spec.RequestReason.SuggestedReasons,
                }
        }</span>

        // Fall back to template
        <span class="cov0" title="0">if template.Spec.RequestReason != nil </span><span class="cov0" title="0">{
                return &amp;ReasonConfigInfo{
                        Mandatory:        template.Spec.RequestReason.Mandatory,
                        Description:      template.Spec.RequestReason.Description,
                        MinLength:        template.Spec.RequestReason.MinLength,
                        MaxLength:        template.Spec.RequestReason.MaxLength,
                        SuggestedReasons: template.Spec.RequestReason.SuggestedReasons,
                }
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// resolveApprovalReason resolves approval reason configuration from binding or template
func (c *DebugSessionAPIController) resolveApprovalReason(template *v1alpha1.DebugSessionTemplate, binding *v1alpha1.DebugSessionClusterBinding) *ReasonConfigInfo <span class="cov0" title="0">{
        // Binding overrides template
        if binding != nil &amp;&amp; binding.Spec.ApprovalReason != nil </span><span class="cov0" title="0">{
                return &amp;ReasonConfigInfo{
                        Mandatory:   binding.Spec.ApprovalReason.Mandatory,
                        Description: binding.Spec.ApprovalReason.Description,
                }
        }</span>

        // Fall back to template
        <span class="cov0" title="0">if template.Spec.ApprovalReason != nil </span><span class="cov0" title="0">{
                return &amp;ReasonConfigInfo{
                        Mandatory:   template.Spec.ApprovalReason.Mandatory,
                        Description: template.Spec.ApprovalReason.Description,
                }
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// resolveNotification resolves notification configuration from binding or template
func (c *DebugSessionAPIController) resolveNotification(template *v1alpha1.DebugSessionTemplate, binding *v1alpha1.DebugSessionClusterBinding) *NotificationConfigInfo <span class="cov0" title="0">{
        // Binding overrides template
        if binding != nil &amp;&amp; binding.Spec.Notification != nil </span><span class="cov0" title="0">{
                return &amp;NotificationConfigInfo{
                        Enabled: binding.Spec.Notification.Enabled,
                }
        }</span>

        // Fall back to template
        <span class="cov0" title="0">if template.Spec.Notification != nil </span><span class="cov0" title="0">{
                return &amp;NotificationConfigInfo{
                        Enabled: template.Spec.Notification.Enabled,
                }
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type notificationEvent string

const (
        notificationEventRequest  notificationEvent = "request"
        notificationEventApproval notificationEvent = "approval"
        notificationEventExpiry   notificationEvent = "expiry"
)

func resolveNotificationConfig(template *v1alpha1.DebugSessionTemplate, binding *v1alpha1.DebugSessionClusterBinding) *v1alpha1.DebugSessionNotificationConfig <span class="cov0" title="0">{
        if binding != nil &amp;&amp; binding.Spec.Notification != nil </span><span class="cov0" title="0">{
                return binding.Spec.Notification
        }</span>
        <span class="cov0" title="0">return template.Spec.Notification</span>
}

func shouldSendNotification(cfg *v1alpha1.DebugSessionNotificationConfig, event notificationEvent) bool <span class="cov0" title="0">{
        if cfg == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if !cfg.Enabled </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">switch event </span>{
        case notificationEventRequest:<span class="cov0" title="0">
                return cfg.NotifyOnRequest</span>
        case notificationEventApproval:<span class="cov0" title="0">
                return cfg.NotifyOnApproval</span>
        case notificationEventExpiry:<span class="cov0" title="0">
                return cfg.NotifyOnExpiry</span>
        default:<span class="cov0" title="0">
                return true</span>
        }
}

func buildNotificationRecipients(base []string, cfg *v1alpha1.DebugSessionNotificationConfig) []string <span class="cov0" title="0">{
        if cfg == nil &amp;&amp; len(base) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">seen := make(map[string]struct{}, len(base))
        var recipients []string
        add := func(addr string) </span><span class="cov0" title="0">{
                if addr == "" </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">if _, ok := seen[addr]; ok </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">seen[addr] = struct{}{}
                recipients = append(recipients, addr)</span>
        }

        <span class="cov0" title="0">for _, addr := range base </span><span class="cov0" title="0">{
                add(addr)
        }</span>
        <span class="cov0" title="0">if cfg != nil </span><span class="cov0" title="0">{
                for _, addr := range cfg.AdditionalRecipients </span><span class="cov0" title="0">{
                        add(addr)
                }</span>
                <span class="cov0" title="0">if cfg.ExcludedRecipients != nil &amp;&amp; len(cfg.ExcludedRecipients.Users) &gt; 0 </span><span class="cov0" title="0">{
                        excluded := make(map[string]struct{}, len(cfg.ExcludedRecipients.Users))
                        for _, u := range cfg.ExcludedRecipients.Users </span><span class="cov0" title="0">{
                                excluded[u] = struct{}{}
                        }</span>
                        <span class="cov0" title="0">filtered := recipients[:0]
                        for _, addr := range recipients </span><span class="cov0" title="0">{
                                if _, blocked := excluded[addr]; blocked </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">filtered = append(filtered, addr)</span>
                        }
                        <span class="cov0" title="0">recipients = filtered</span>
                }
        }

        <span class="cov0" title="0">return recipients</span>
}

func (c *DebugSessionAPIController) resolveNotificationConfigForSession(ctx context.Context, session *v1alpha1.DebugSession) *v1alpha1.DebugSessionNotificationConfig <span class="cov0" title="0">{
        if session == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if session.Spec.TemplateRef == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Resolve template
        <span class="cov0" title="0">template := &amp;v1alpha1.DebugSessionTemplate{}
        if err := c.client.Get(ctx, ctrlclient.ObjectKey{Name: session.Spec.TemplateRef}, template); err != nil </span><span class="cov0" title="0">{
                c.log.Debugw("Failed to load template for notification config", "template", session.Spec.TemplateRef, "error", err)
                return nil
        }</span>

        // Resolve binding if referenced
        <span class="cov0" title="0">var binding *v1alpha1.DebugSessionClusterBinding
        if session.Spec.BindingRef != nil </span><span class="cov0" title="0">{
                resolved := &amp;v1alpha1.DebugSessionClusterBinding{}
                if err := c.client.Get(ctx, ctrlclient.ObjectKey{Name: session.Spec.BindingRef.Name, Namespace: session.Spec.BindingRef.Namespace}, resolved); err != nil </span><span class="cov0" title="0">{
                        c.log.Debugw("Failed to load binding for notification config", "binding", session.Spec.BindingRef.Name, "error", err)
                }</span> else<span class="cov0" title="0"> {
                        binding = resolved
                }</span>
        }

        <span class="cov0" title="0">return resolveNotificationConfig(template, binding)</span>
}

// labelSetFromMap creates a labels.Set from a map for selector matching
func labelSetFromMap(m map[string]string) labels.Set <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return labels.Set{}
        }</span>
        <span class="cov0" title="0">return labels.Set(m)</span>
}

// handleListPodTemplates returns available debug pod templates
// Uses the uncached apiReader if configured, for consistent reads after writes.
func (c *DebugSessionAPIController) handleListPodTemplates(ctx *gin.Context) <span class="cov0" title="0">{
        reqLog := system.GetReqLogger(ctx, c.log)

        templateList := &amp;v1alpha1.DebugPodTemplateList{}
        apiCtx, cancel := context.WithTimeout(ctx.Request.Context(), APIContextTimeout)
        defer cancel()

        if err := c.reader().List(apiCtx, templateList); err != nil </span><span class="cov0" title="0">{
                reqLog.Errorw("Failed to list debug pod templates", "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to list pod templates")
                return
        }</span>

        <span class="cov0" title="0">var templates []DebugPodTemplateResponse
        for _, t := range templateList.Items </span><span class="cov0" title="0">{
                templates = append(templates, DebugPodTemplateResponse{
                        Name:        t.Name,
                        DisplayName: t.Spec.DisplayName,
                        Description: t.Spec.Description,
                        Containers:  len(t.Spec.Template.Spec.Containers),
                })
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{
                "templates": templates,
                "total":     len(templates),
        })</span>
}

// handleGetPodTemplate returns details for a specific pod template
// Uses the uncached apiReader if configured, for consistent reads after writes.
func (c *DebugSessionAPIController) handleGetPodTemplate(ctx *gin.Context) <span class="cov0" title="0">{
        reqLog := system.GetReqLogger(ctx, c.log)
        name := ctx.Param("name")

        if name == "" </span><span class="cov0" title="0">{
                apiresponses.RespondBadRequest(ctx, "template name is required")
                return
        }</span>

        <span class="cov0" title="0">template := &amp;v1alpha1.DebugPodTemplate{}
        apiCtx, cancel := context.WithTimeout(ctx.Request.Context(), APIContextTimeout)
        defer cancel()

        if err := c.reader().Get(apiCtx, ctrlclient.ObjectKey{Name: name}, template); err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        apiresponses.RespondNotFoundSimple(ctx, "pod template not found")
                        return
                }</span>
                <span class="cov0" title="0">reqLog.Errorw("Failed to get pod template", "name", name, "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to get pod template")
                return</span>
        }

        // Build response using same flat format as list endpoint
        <span class="cov0" title="0">containerCount := 0
        if template.Spec.Template.Spec.Containers != nil </span><span class="cov0" title="0">{
                containerCount = len(template.Spec.Template.Spec.Containers)
        }</span>
        <span class="cov0" title="0">resp := DebugPodTemplateResponse{
                Name:        template.Name,
                DisplayName: template.Spec.DisplayName,
                Description: template.Spec.Description,
                Containers:  containerCount,
        }

        ctx.JSON(http.StatusOK, resp)</span>
}

// isUserAuthorizedToApprove checks if the user is authorized to approve/reject a debug session
// The user must be in one of the approver groups/users defined in the session's template or binding.
// Additionally, the requester of the session is not allowed to self-approve.
func (c *DebugSessionAPIController) isUserAuthorizedToApprove(ctx context.Context, session *v1alpha1.DebugSession, username string, userGroupsInterface interface{}) bool <span class="cov0" title="0">{
        // Block self-approval: the user who requested the session cannot approve it
        if session.Spec.RequestedBy == username </span><span class="cov0" title="0">{
                c.log.Infow("Blocking self-approval attempt",
                        "session", session.Name, "requester", session.Spec.RequestedBy, "approver", username)
                return false
        }</span>

        // First try to find the binding that granted this session - it may have its own approvers
        <span class="cov0" title="0">bindings := &amp;v1alpha1.DebugSessionClusterBindingList{}
        if err := c.client.List(ctx, bindings); err == nil </span><span class="cov0" title="0">{
                for i := range bindings.Items </span><span class="cov0" title="0">{
                        binding := &amp;bindings.Items[i]
                        // Check if this binding applies to this session
                        if binding.Spec.TemplateRef != nil &amp;&amp; binding.Spec.TemplateRef.Name == session.Spec.TemplateRef </span><span class="cov0" title="0">{
                                // Check if this binding covers the session's cluster
                                for _, cluster := range binding.Spec.Clusters </span><span class="cov0" title="0">{
                                        if matchPattern(cluster, session.Spec.Cluster) </span><span class="cov0" title="0">{
                                                // Found a matching binding - check if it has approvers
                                                if binding.Spec.Approvers != nil &amp;&amp; (len(binding.Spec.Approvers.Users) &gt; 0 || len(binding.Spec.Approvers.Groups) &gt; 0) </span><span class="cov0" title="0">{
                                                        return c.checkApproverAuthorization(binding.Spec.Approvers, username, userGroupsInterface)
                                                }</span>
                                                <span class="cov0" title="0">break</span>
                                        }
                                }
                        }
                }
        }

        // If template has no resolved approvers info in status, fall back to fetching template
        <span class="cov0" title="0">if session.Status.ResolvedTemplate == nil || session.Status.ResolvedTemplate.Approvers == nil </span><span class="cov0" title="0">{
                // Fetch the template to check approvers
                template := &amp;v1alpha1.DebugSessionTemplate{}
                if err := c.client.Get(ctx, ctrlclient.ObjectKey{Name: session.Spec.TemplateRef}, template); err != nil </span><span class="cov0" title="0">{
                        // If we can't fetch template, allow approval (fail open for usability)
                        c.log.Warnw("Could not fetch template to check approvers, allowing approval",
                                "session", session.Name, "template", session.Spec.TemplateRef, "error", err)
                        return true
                }</span>

                // If template has no approvers configured, allow any authenticated user
                <span class="cov0" title="0">if template.Spec.Approvers == nil </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov0" title="0">return c.checkApproverAuthorization(template.Spec.Approvers, username, userGroupsInterface)</span>
        }

        // Use resolved template from status
        <span class="cov0" title="0">return c.checkApproverAuthorization(session.Status.ResolvedTemplate.Approvers, username, userGroupsInterface)</span>
}

// checkApproverAuthorization checks if user is in the approved users/groups
func (c *DebugSessionAPIController) checkApproverAuthorization(approvers *v1alpha1.DebugSessionApprovers, username string, userGroupsInterface interface{}) bool <span class="cov0" title="0">{
        // Check if user is in allowed users list
        for _, allowedUser := range approvers.Users </span><span class="cov0" title="0">{
                if matchPattern(allowedUser, username) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        // Check if user is in any of the allowed groups
        <span class="cov0" title="0">if userGroupsInterface != nil </span><span class="cov0" title="0">{
                var userGroups []string
                switch g := userGroupsInterface.(type) </span>{
                case []string:<span class="cov0" title="0">
                        userGroups = g</span>
                case []interface{}:<span class="cov0" title="0">
                        for _, v := range g </span><span class="cov0" title="0">{
                                if s, ok := v.(string); ok </span><span class="cov0" title="0">{
                                        userGroups = append(userGroups, s)
                                }</span>
                        }
                }

                <span class="cov0" title="0">for _, userGroup := range userGroups </span><span class="cov0" title="0">{
                        for _, allowedGroup := range approvers.Groups </span><span class="cov0" title="0">{
                                if matchPattern(allowedGroup, userGroup) </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }
        }

        // If no approvers defined at all, allow any authenticated user
        <span class="cov0" title="0">if len(approvers.Users) == 0 &amp;&amp; len(approvers.Groups) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// matchPattern checks if a string matches a glob pattern.
// Supports patterns like:
//   - "*" matches everything
//   - "prefix*" matches strings starting with prefix
//   - "*suffix" matches strings ending with suffix
//   - "*.tst.*" matches strings containing ".tst."
//   - "dev-*" matches "dev-cluster1"
//
// Uses utils.GlobMatch for pattern matching. If the pattern is invalid (e.g., unclosed
// bracket), falls back to exact string comparison for backward compatibility.
func matchPattern(pattern, value string) bool <span class="cov0" title="0">{
        matched, err := utils.GlobMatch(pattern, value)
        if err != nil </span><span class="cov0" title="0">{
                // Invalid glob pattern  fall back to exact match for backward compatibility.
                // This preserves the previous behavior where patterns like "[unclosed" could
                // still match the literal string.
                return pattern == value
        }</span>
        <span class="cov0" title="0">return matched</span>
}

// convertSelectorTerms converts v1alpha1 selector terms to API response format
func convertSelectorTerms(terms []v1alpha1.NamespaceSelectorTerm) []NamespaceSelectorTermResponse <span class="cov0" title="0">{
        if len(terms) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">result := make([]NamespaceSelectorTermResponse, 0, len(terms))
        for _, term := range terms </span><span class="cov0" title="0">{
                respTerm := NamespaceSelectorTermResponse{
                        MatchLabels: term.MatchLabels,
                }
                if len(term.MatchExpressions) &gt; 0 </span><span class="cov0" title="0">{
                        respTerm.MatchExpressions = make([]NamespaceSelectorRequirementResponse, 0, len(term.MatchExpressions))
                        for _, expr := range term.MatchExpressions </span><span class="cov0" title="0">{
                                respTerm.MatchExpressions = append(respTerm.MatchExpressions, NamespaceSelectorRequirementResponse{
                                        Key:      expr.Key,
                                        Operator: string(expr.Operator),
                                        Values:   expr.Values,
                                })
                        }</span>
                }
                <span class="cov0" title="0">result = append(result, respTerm)</span>
        }
        <span class="cov0" title="0">return result</span>
}

// resolveTargetNamespace validates and resolves the target namespace for debug pods.
// Returns the resolved namespace or an error if the requested namespace is not allowed.
// If a binding is provided and has namespace constraints, those constraints are used to extend
// or override the template's constraints (e.g., binding.AllowUserNamespace=true overrides template's false).
func (c *DebugSessionAPIController) resolveTargetNamespace(template *v1alpha1.DebugSessionTemplate, requestedNamespace string, binding *v1alpha1.DebugSessionClusterBinding) (string, error) <span class="cov0" title="0">{
        // Start with template's namespace constraints
        nc := template.Spec.NamespaceConstraints

        // If binding has namespace constraints, use them to extend/override template's
        if binding != nil &amp;&amp; binding.Spec.NamespaceConstraints != nil </span><span class="cov0" title="0">{
                nc = c.mergeNamespaceConstraints(template.Spec.NamespaceConstraints, binding.Spec.NamespaceConstraints)
                c.log.Debugw("Merged namespace constraints from binding",
                        "template", template.Name,
                        "binding", binding.Name,
                        "bindingNamespace", binding.Namespace,
                        "mergedAllowUserNamespace", nc != nil &amp;&amp; nc.AllowUserNamespace,
                        "mergedDefaultNamespace", func() string </span><span class="cov0" title="0">{
                                if nc != nil </span><span class="cov0" title="0">{
                                        return nc.DefaultNamespace
                                }</span>
                                <span class="cov0" title="0">return ""</span>
                        }(),
                )
        }

        <span class="cov0" title="0">c.log.Debugw("Resolving target namespace",
                "template", template.Name,
                "requestedNamespace", requestedNamespace,
                "hasNamespaceConstraints", nc != nil,
        )

        // If no namespace constraints, use default behavior
        if nc == nil </span><span class="cov0" title="0">{
                if requestedNamespace != "" </span><span class="cov0" title="0">{
                        c.log.Debugw("No namespace constraints, using requested namespace",
                                "template", template.Name,
                                "resolvedNamespace", requestedNamespace,
                        )
                        return requestedNamespace, nil
                }</span>
                <span class="cov0" title="0">c.log.Debugw("No namespace constraints, using default",
                        "template", template.Name,
                        "resolvedNamespace", "breakglass-debug",
                )
                return "breakglass-debug", nil</span> // Default namespace
        }

        <span class="cov0" title="0">c.log.Debugw("Namespace constraints found",
                "template", template.Name,
                "allowUserNamespace", nc.AllowUserNamespace,
                "defaultNamespace", nc.DefaultNamespace,
                "hasAllowedNamespaces", nc.AllowedNamespaces != nil &amp;&amp; !nc.AllowedNamespaces.IsEmpty(),
                "hasDeniedNamespaces", nc.DeniedNamespaces != nil &amp;&amp; !nc.DeniedNamespaces.IsEmpty(),
        )

        // If user didn't request a specific namespace, use the default
        if requestedNamespace == "" </span><span class="cov0" title="0">{
                if nc.DefaultNamespace != "" </span><span class="cov0" title="0">{
                        c.log.Debugw("No namespace requested, using template default",
                                "template", template.Name,
                                "resolvedNamespace", nc.DefaultNamespace,
                        )
                        return nc.DefaultNamespace, nil
                }</span>
                <span class="cov0" title="0">c.log.Debugw("No namespace requested and no template default, using fallback",
                        "template", template.Name,
                        "resolvedNamespace", "breakglass-debug",
                )
                return "breakglass-debug", nil</span>
        }

        // If the requested namespace matches the default, allow it even when user namespace selection is disabled.
        // This handles the case where the frontend sends the default namespace value in the request.
        <span class="cov0" title="0">if nc.DefaultNamespace != "" &amp;&amp; requestedNamespace == nc.DefaultNamespace </span><span class="cov0" title="0">{
                c.log.Debugw("Requested namespace matches default, allowing",
                        "template", template.Name,
                        "requestedNamespace", requestedNamespace,
                        "defaultNamespace", nc.DefaultNamespace,
                )
                return nc.DefaultNamespace, nil
        }</span>

        // Check if user is allowed to specify a namespace
        <span class="cov0" title="0">if !nc.AllowUserNamespace </span><span class="cov0" title="0">{
                c.log.Debugw("User-specified namespace not allowed by template",
                        "template", template.Name,
                        "requestedNamespace", requestedNamespace,
                        "allowUserNamespace", nc.AllowUserNamespace,
                )
                return "", fmt.Errorf("template does not allow user-specified namespaces")
        }</span>

        // Validate against allowed namespaces
        <span class="cov0" title="0">if nc.AllowedNamespaces != nil &amp;&amp; !nc.AllowedNamespaces.IsEmpty() </span><span class="cov0" title="0">{
                if !matchNamespaceFilter(requestedNamespace, nc.AllowedNamespaces) </span><span class="cov0" title="0">{
                        c.log.Debugw("Namespace not in allowed list",
                                "template", template.Name,
                                "requestedNamespace", requestedNamespace,
                                "allowedPatterns", nc.AllowedNamespaces.Patterns,
                        )
                        return "", fmt.Errorf("namespace '%s' is not in the allowed namespaces", requestedNamespace)
                }</span>
        }

        // Validate against denied namespaces
        <span class="cov0" title="0">if nc.DeniedNamespaces != nil &amp;&amp; !nc.DeniedNamespaces.IsEmpty() </span><span class="cov0" title="0">{
                if matchNamespaceFilter(requestedNamespace, nc.DeniedNamespaces) </span><span class="cov0" title="0">{
                        c.log.Debugw("Namespace is in denied list",
                                "template", template.Name,
                                "requestedNamespace", requestedNamespace,
                                "deniedPatterns", nc.DeniedNamespaces.Patterns,
                        )
                        return "", fmt.Errorf("namespace '%s' is explicitly denied", requestedNamespace)
                }</span>
        }

        <span class="cov0" title="0">return requestedNamespace, nil</span>
}

// mergeNamespaceConstraints merges template and binding namespace constraints.
// Binding constraints can extend what template allows (e.g., enable user namespaces).
// Returns a new NamespaceConstraints with merged values.
func (c *DebugSessionAPIController) mergeNamespaceConstraints(
        templateNC, bindingNC *v1alpha1.NamespaceConstraints,
) *v1alpha1.NamespaceConstraints <span class="cov0" title="0">{
        // If both are nil, return nil
        if templateNC == nil &amp;&amp; bindingNC == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // If only one exists, use it
        <span class="cov0" title="0">if templateNC == nil </span><span class="cov0" title="0">{
                return bindingNC.DeepCopy()
        }</span>
        <span class="cov0" title="0">if bindingNC == nil </span><span class="cov0" title="0">{
                return templateNC.DeepCopy()
        }</span>

        // Merge both - binding extends template
        <span class="cov0" title="0">merged := templateNC.DeepCopy()

        // AllowUserNamespace: binding can enable it even if template disables
        if bindingNC.AllowUserNamespace </span><span class="cov0" title="0">{
                merged.AllowUserNamespace = true
        }</span>

        // DefaultNamespace: binding can override template's default
        <span class="cov0" title="0">if bindingNC.DefaultNamespace != "" </span><span class="cov0" title="0">{
                merged.DefaultNamespace = bindingNC.DefaultNamespace
        }</span>

        // AllowedNamespaces: binding can add to allowed list
        <span class="cov0" title="0">if bindingNC.AllowedNamespaces != nil &amp;&amp; !bindingNC.AllowedNamespaces.IsEmpty() </span><span class="cov0" title="0">{
                if merged.AllowedNamespaces == nil </span><span class="cov0" title="0">{
                        merged.AllowedNamespaces = bindingNC.AllowedNamespaces.DeepCopy()
                }</span> else<span class="cov0" title="0"> {
                        // Merge patterns (union)
                        patternSet := make(map[string]bool)
                        for _, p := range merged.AllowedNamespaces.Patterns </span><span class="cov0" title="0">{
                                patternSet[p] = true
                        }</span>
                        <span class="cov0" title="0">for _, p := range bindingNC.AllowedNamespaces.Patterns </span><span class="cov0" title="0">{
                                if !patternSet[p] </span><span class="cov0" title="0">{
                                        merged.AllowedNamespaces.Patterns = append(merged.AllowedNamespaces.Patterns, p)
                                }</span>
                        }
                }
        }

        // DeniedNamespaces: take the intersection (more permissive for the user)
        // For simplicity, if binding specifies denied namespaces, use binding's (override)
        <span class="cov0" title="0">if bindingNC.DeniedNamespaces != nil &amp;&amp; !bindingNC.DeniedNamespaces.IsEmpty() </span><span class="cov0" title="0">{
                merged.DeniedNamespaces = bindingNC.DeniedNamespaces.DeepCopy()
        }</span>

        <span class="cov0" title="0">return merged</span>
}

// matchNamespaceFilter checks if a namespace matches a NamespaceFilter.
// Only evaluates patterns; label selector matching requires runtime access to namespaces.
func matchNamespaceFilter(namespace string, filter *v1alpha1.NamespaceFilter) bool <span class="cov0" title="0">{
        if filter == nil || filter.IsEmpty() </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check patterns
        <span class="cov0" title="0">for _, pattern := range filter.Patterns </span><span class="cov0" title="0">{
                if matchPattern(pattern, namespace) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        // Note: SelectorTerms require runtime namespace label access
        // For now, if only selector terms are specified, we allow it
        // (actual validation happens at deployment time)
        <span class="cov0" title="0">if len(filter.Patterns) == 0 &amp;&amp; filter.HasSelectorTerms() </span><span class="cov0" title="0">{
                return true // Defer to runtime validation
        }</span>

        <span class="cov0" title="0">return false</span>
}

// resolveSchedulingConstraints validates and resolves the scheduling constraints.
// It merges the template's and binding's base constraints with the selected scheduling option.
// When a binding is provided, its base constraints are treated as mandatory additions
// on top of the template, and its scheduling options take precedence over the template's.
// Returns the merged constraints, the selected option name, and any error.
func (c *DebugSessionAPIController) resolveSchedulingConstraints(
        template *v1alpha1.DebugSessionTemplate,
        selectedOption string,
        binding *v1alpha1.DebugSessionClusterBinding,
) (*v1alpha1.SchedulingConstraints, string, error) <span class="cov0" title="0">{
        // Start with the template's base scheduling constraints and merge in binding-level
        // base constraints (which are documented as mandatory additions on top of the template).
        baseConstraints := template.Spec.SchedulingConstraints
        if binding != nil &amp;&amp; binding.Spec.SchedulingConstraints != nil </span><span class="cov0" title="0">{
                baseConstraints = mergeSchedulingConstraints(baseConstraints, binding.Spec.SchedulingConstraints)
        }</span>

        // Resolve effective scheduling options: binding takes precedence over template
        <span class="cov0" title="0">var effectiveOpts *v1alpha1.SchedulingOptions
        if binding != nil &amp;&amp; binding.Spec.SchedulingOptions != nil </span><span class="cov0" title="0">{
                effectiveOpts = binding.Spec.SchedulingOptions
        }</span> else<span class="cov0" title="0"> if template.Spec.SchedulingOptions != nil </span><span class="cov0" title="0">{
                effectiveOpts = template.Spec.SchedulingOptions
        }</span>

        // If no scheduling options defined (in template or binding), just return base constraints
        // Ignore any user-selected option since neither the template nor binding supports them.
        // This handles cases where the frontend sends a stale scheduling option
        // after switching to a template that doesn't have scheduling options.
        <span class="cov0" title="0">if effectiveOpts == nil || len(effectiveOpts.Options) == 0 </span><span class="cov0" title="0">{
                if selectedOption != "" </span><span class="cov0" title="0">{
                        c.log.Debugw("Ignoring scheduling option - no options defined in template or binding",
                                "template", template.Name,
                                "selectedOption", selectedOption,
                        )
                }</span>
                <span class="cov0" title="0">return baseConstraints, "", nil</span>
        }

        <span class="cov0" title="0">opts := effectiveOpts

        // If required and no option selected, find the default
        if selectedOption == "" </span><span class="cov0" title="0">{
                if opts.Required </span><span class="cov0" title="0">{
                        // Find the default option
                        for _, opt := range opts.Options </span><span class="cov0" title="0">{
                                if opt.Default </span><span class="cov0" title="0">{
                                        selectedOption = opt.Name
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if selectedOption == "" </span><span class="cov0" title="0">{
                                return nil, "", fmt.Errorf("scheduling option is required but none selected and no default defined")
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Not required, no selection - use base constraints only
                        return baseConstraints, "", nil
                }</span>
        }

        // Find the selected option
        <span class="cov0" title="0">var selectedOpt *v1alpha1.SchedulingOption
        for i := range opts.Options </span><span class="cov0" title="0">{
                if opts.Options[i].Name == selectedOption </span><span class="cov0" title="0">{
                        selectedOpt = &amp;opts.Options[i]
                        break</span>
                }
        }

        <span class="cov0" title="0">if selectedOpt == nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("scheduling option '%s' not found in template or binding", selectedOption)
        }</span>

        // Merge base constraints with option's constraints
        <span class="cov0" title="0">merged := mergeSchedulingConstraints(baseConstraints, selectedOpt.SchedulingConstraints)

        return merged, selectedOption, nil</span>
}

// mergeSchedulingConstraints merges base constraints with option constraints.
// Option constraints override base constraints for conflicting keys.
func mergeSchedulingConstraints(base, option *v1alpha1.SchedulingConstraints) *v1alpha1.SchedulingConstraints <span class="cov0" title="0">{
        if base == nil &amp;&amp; option == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if base == nil </span><span class="cov0" title="0">{
                return option.DeepCopy()
        }</span>
        <span class="cov0" title="0">if option == nil </span><span class="cov0" title="0">{
                return base.DeepCopy()
        }</span>

        <span class="cov0" title="0">merged := base.DeepCopy()

        // Merge nodeSelector (option overrides base on conflict)
        if len(option.NodeSelector) &gt; 0 </span><span class="cov0" title="0">{
                if merged.NodeSelector == nil </span><span class="cov0" title="0">{
                        merged.NodeSelector = make(map[string]string)
                }</span>
                <span class="cov0" title="0">for k, v := range option.NodeSelector </span><span class="cov0" title="0">{
                        merged.NodeSelector[k] = v
                }</span>
        }

        // Merge deniedNodes (additive)
        <span class="cov0" title="0">if len(option.DeniedNodes) &gt; 0 </span><span class="cov0" title="0">{
                merged.DeniedNodes = append(merged.DeniedNodes, option.DeniedNodes...)
        }</span>

        // Merge deniedNodeLabels (option overrides base on conflict)
        <span class="cov0" title="0">if len(option.DeniedNodeLabels) &gt; 0 </span><span class="cov0" title="0">{
                if merged.DeniedNodeLabels == nil </span><span class="cov0" title="0">{
                        merged.DeniedNodeLabels = make(map[string]string)
                }</span>
                <span class="cov0" title="0">for k, v := range option.DeniedNodeLabels </span><span class="cov0" title="0">{
                        merged.DeniedNodeLabels[k] = v
                }</span>
        }

        // Merge tolerations (additive)
        <span class="cov0" title="0">if len(option.Tolerations) &gt; 0 </span><span class="cov0" title="0">{
                merged.Tolerations = append(merged.Tolerations, option.Tolerations...)
        }</span>

        // For node affinity, option's required affinity is ANDed with base
        <span class="cov0" title="0">if option.RequiredNodeAffinity != nil </span><span class="cov0" title="0">{
                if merged.RequiredNodeAffinity == nil </span><span class="cov0" title="0">{
                        merged.RequiredNodeAffinity = option.RequiredNodeAffinity.DeepCopy()
                }</span> else<span class="cov0" title="0"> {
                        // AND the node selector terms
                        merged.RequiredNodeAffinity.NodeSelectorTerms = append(
                                merged.RequiredNodeAffinity.NodeSelectorTerms,
                                option.RequiredNodeAffinity.NodeSelectorTerms...,
                        )
                }</span>
        }

        // Preferred affinities are additive
        <span class="cov0" title="0">if len(option.PreferredNodeAffinity) &gt; 0 </span><span class="cov0" title="0">{
                merged.PreferredNodeAffinity = append(merged.PreferredNodeAffinity, option.PreferredNodeAffinity...)
        }</span>

        // Pod anti-affinity is additive
        <span class="cov0" title="0">if len(option.RequiredPodAntiAffinity) &gt; 0 </span><span class="cov0" title="0">{
                merged.RequiredPodAntiAffinity = append(merged.RequiredPodAntiAffinity, option.RequiredPodAntiAffinity...)
        }</span>
        <span class="cov0" title="0">if len(option.PreferredPodAntiAffinity) &gt; 0 </span><span class="cov0" title="0">{
                merged.PreferredPodAntiAffinity = append(merged.PreferredPodAntiAffinity, option.PreferredPodAntiAffinity...)
        }</span>

        <span class="cov0" title="0">return merged</span>
}

// resolveClusterPatterns expands cluster patterns (e.g., "*", "prod-*") to actual cluster names.
// Returns empty slice if no clusters are available for resolution.
func resolveClusterPatterns(patterns []string, allClusters []string) []string <span class="cov0" title="0">{
        if len(patterns) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if len(allClusters) == 0 </span><span class="cov0" title="0">{
                // No clusters to resolve against - return empty instead of patterns
                // This ensures the frontend shows "no clusters available" instead of pattern strings
                return nil
        }</span>

        // Use a map to deduplicate
        <span class="cov0" title="0">resolved := make(map[string]struct{})
        for _, pattern := range patterns </span><span class="cov0" title="0">{
                for _, cluster := range allClusters </span><span class="cov0" title="0">{
                        if matchPattern(pattern, cluster) </span><span class="cov0" title="0">{
                                resolved[cluster] = struct{}{}
                        }</span>
                }
        }

        // Convert map to sorted slice for consistent output
        <span class="cov0" title="0">result := make([]string, 0, len(resolved))
        for cluster := range resolved </span><span class="cov0" title="0">{
                result = append(result, cluster)
        }</span>
        // Sort for consistent ordering
        <span class="cov0" title="0">sort.Strings(result)
        return result</span>
}

// sendDebugSessionRequestEmail sends email notification to approvers when a debug session is created
func (c *DebugSessionAPIController) sendDebugSessionRequestEmail(ctx context.Context, session *v1alpha1.DebugSession, template *v1alpha1.DebugSessionTemplate, binding *v1alpha1.DebugSessionClusterBinding) <span class="cov0" title="0">{
        if c.disableEmail || c.mailService == nil || !c.mailService.IsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">notificationCfg := resolveNotificationConfig(template, binding)
        if !shouldSendNotification(notificationCfg, notificationEventRequest) </span><span class="cov0" title="0">{
                c.log.Debugw("Debug session request email disabled by notification settings", "session", session.Name)
                return
        }</span>

        // Collect approver emails
        <span class="cov0" title="0">var approverEmails []string
        if template.Spec.Approvers != nil </span><span class="cov0" title="0">{
                approverEmails = append(approverEmails, template.Spec.Approvers.Users...)
        }</span>

        <span class="cov0" title="0">approverEmails = buildNotificationRecipients(approverEmails, notificationCfg)

        if len(approverEmails) == 0 </span><span class="cov0" title="0">{
                c.log.Debugw("No approvers configured for debug session template, skipping request email", "session", session.Name, "template", template.Name)
                return
        }</span>

        // Use display name if available, fallback to username
        <span class="cov0" title="0">requesterName := session.Spec.RequestedByDisplayName
        if requesterName == "" </span><span class="cov0" title="0">{
                requesterName = session.Spec.RequestedBy
        }</span>

        // Use email if available, fallback to username
        <span class="cov0" title="0">requesterEmail := session.Spec.RequestedByEmail
        if requesterEmail == "" </span><span class="cov0" title="0">{
                requesterEmail = session.Spec.RequestedBy
        }</span>

        <span class="cov0" title="0">params := mail.DebugSessionRequestMailParams{
                RequesterName:     requesterName,
                RequesterEmail:    requesterEmail,
                RequestedAt:       session.CreationTimestamp.Format(time.RFC3339),
                SessionID:         session.Name,
                Cluster:           session.Spec.Cluster,
                TemplateName:      session.Spec.TemplateRef,
                Namespace:         session.Namespace,
                RequestedDuration: session.Spec.RequestedDuration,
                Reason:            session.Spec.Reason,
                URL:               fmt.Sprintf("%s/debug-sessions", c.baseURL),
                BrandingName:      c.brandingName,
        }

        body, err := mail.RenderDebugSessionRequest(params)
        if err != nil </span><span class="cov0" title="0">{
                c.log.Errorw("Failed to render debug session request email", "session", session.Name, "error", err)
                return
        }</span>

        <span class="cov0" title="0">subject := fmt.Sprintf("[%s] Debug Session Request: %s on %s", c.brandingName, requesterName, session.Spec.Cluster)
        if err := c.mailService.Enqueue(session.Name, approverEmails, subject, body); err != nil </span><span class="cov0" title="0">{
                c.log.Errorw("Failed to enqueue debug session request email", "session", session.Name, "error", err)
        }</span> else<span class="cov0" title="0"> {
                c.log.Infow("Debug session request email queued", "session", session.Name, "approvers", len(approverEmails))
        }</span>
}

// sendDebugSessionApprovalEmail sends email notification to requester when a debug session is approved
func (c *DebugSessionAPIController) sendDebugSessionApprovalEmail(ctx context.Context, session *v1alpha1.DebugSession) <span class="cov0" title="0">{
        if c.disableEmail || c.mailService == nil || !c.mailService.IsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">notificationCfg := c.resolveNotificationConfigForSession(ctx, session)
        if !shouldSendNotification(notificationCfg, notificationEventApproval) </span><span class="cov0" title="0">{
                c.log.Debugw("Debug session approval email disabled by notification settings", "session", session.Name)
                return
        }</span>

        // Send to the requester - use email field if available, fallback to requestedBy
        <span class="cov0" title="0">recipientEmail := session.Spec.RequestedByEmail
        if recipientEmail == "" </span><span class="cov0" title="0">{
                recipientEmail = session.Spec.RequestedBy
        }</span>
        // Skip if no valid email (must contain @)
        <span class="cov0" title="0">if !strings.Contains(recipientEmail, "@") </span><span class="cov0" title="0">{
                c.log.Warnw("Skipping approval email - no valid email address", "session", session.Name, "recipient", recipientEmail)
                return
        }</span>
        <span class="cov0" title="0">recipients := buildNotificationRecipients([]string{recipientEmail}, notificationCfg)

        approvedAt := ""
        expiresAt := ""
        approverName := ""
        approvalReason := ""
        if session.Status.Approval != nil </span><span class="cov0" title="0">{
                if session.Status.Approval.ApprovedAt != nil </span><span class="cov0" title="0">{
                        approvedAt = session.Status.Approval.ApprovedAt.Format(time.RFC3339)
                }</span>
                <span class="cov0" title="0">approverName = session.Status.Approval.ApprovedBy
                approvalReason = session.Status.Approval.Reason</span>
        }
        <span class="cov0" title="0">if session.Status.ExpiresAt != nil </span><span class="cov0" title="0">{
                expiresAt = session.Status.ExpiresAt.Format(time.RFC3339)
        }</span>

        // Use display name if available, fallback to username
        <span class="cov0" title="0">requesterName := session.Spec.RequestedByDisplayName
        if requesterName == "" </span><span class="cov0" title="0">{
                requesterName = session.Spec.RequestedBy
        }</span>

        <span class="cov0" title="0">params := mail.DebugSessionApprovedMailParams{
                RequesterName:  requesterName,
                RequesterEmail: recipientEmail,
                SessionID:      session.Name,
                Cluster:        session.Spec.Cluster,
                TemplateName:   session.Spec.TemplateRef,
                Namespace:      session.Namespace,
                ApproverName:   approverName,
                ApproverEmail:  approverName,
                ApprovedAt:     approvedAt,
                ApprovalReason: approvalReason,
                Duration:       session.Spec.RequestedDuration,
                ExpiresAt:      expiresAt,
                BrandingName:   c.brandingName,
        }

        body, err := mail.RenderDebugSessionApproved(params)
        if err != nil </span><span class="cov0" title="0">{
                c.log.Errorw("Failed to render debug session approval email", "session", session.Name, "error", err)
                return
        }</span>

        <span class="cov0" title="0">subject := fmt.Sprintf("[%s] Debug Session Approved: %s", c.brandingName, session.Name)
        if err := c.mailService.Enqueue(session.Name, recipients, subject, body); err != nil </span><span class="cov0" title="0">{
                c.log.Errorw("Failed to enqueue debug session approval email", "session", session.Name, "error", err)
        }</span> else<span class="cov0" title="0"> {
                c.log.Infow("Debug session approval email queued", "session", session.Name)
        }</span>
}

// sendDebugSessionRejectionEmail sends email notification to requester when a debug session is rejected
func (c *DebugSessionAPIController) sendDebugSessionRejectionEmail(ctx context.Context, session *v1alpha1.DebugSession) <span class="cov0" title="0">{
        if c.disableEmail || c.mailService == nil || !c.mailService.IsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">notificationCfg := c.resolveNotificationConfigForSession(ctx, session)
        if !shouldSendNotification(notificationCfg, notificationEventApproval) </span><span class="cov0" title="0">{
                c.log.Debugw("Debug session rejection email disabled by notification settings", "session", session.Name)
                return
        }</span>

        // Send to the requester - use email field if available, fallback to requestedBy
        <span class="cov0" title="0">recipientEmail := session.Spec.RequestedByEmail
        if recipientEmail == "" </span><span class="cov0" title="0">{
                recipientEmail = session.Spec.RequestedBy
        }</span>
        // Skip if no valid email (must contain @)
        <span class="cov0" title="0">if !strings.Contains(recipientEmail, "@") </span><span class="cov0" title="0">{
                c.log.Warnw("Skipping rejection email - no valid email address", "session", session.Name, "recipient", recipientEmail)
                return
        }</span>
        <span class="cov0" title="0">recipients := buildNotificationRecipients([]string{recipientEmail}, notificationCfg)

        rejectedAt := ""
        rejectorName := ""
        rejectionReason := ""
        if session.Status.Approval != nil </span><span class="cov0" title="0">{
                if session.Status.Approval.RejectedAt != nil </span><span class="cov0" title="0">{
                        rejectedAt = session.Status.Approval.RejectedAt.Format(time.RFC3339)
                }</span>
                <span class="cov0" title="0">rejectorName = session.Status.Approval.RejectedBy
                rejectionReason = session.Status.Approval.Reason</span>
        }

        // Use display name if available, fallback to username
        <span class="cov0" title="0">requesterName := session.Spec.RequestedByDisplayName
        if requesterName == "" </span><span class="cov0" title="0">{
                requesterName = session.Spec.RequestedBy
        }</span>

        <span class="cov0" title="0">params := mail.DebugSessionRejectedMailParams{
                RequesterName:   requesterName,
                RequesterEmail:  recipientEmail,
                SessionID:       session.Name,
                Cluster:         session.Spec.Cluster,
                TemplateName:    session.Spec.TemplateRef,
                Namespace:       session.Namespace,
                RejectorName:    rejectorName,
                RejectorEmail:   rejectorName,
                RejectedAt:      rejectedAt,
                RejectionReason: rejectionReason,
                BrandingName:    c.brandingName,
        }

        body, err := mail.RenderDebugSessionRejected(params)
        if err != nil </span><span class="cov0" title="0">{
                c.log.Errorw("Failed to render debug session rejection email", "session", session.Name, "error", err)
                return
        }</span>

        <span class="cov0" title="0">subject := fmt.Sprintf("[%s] Debug Session Rejected: %s", c.brandingName, session.Name)
        if err := c.mailService.Enqueue(session.Name, recipients, subject, body); err != nil </span><span class="cov0" title="0">{
                c.log.Errorw("Failed to enqueue debug session rejection email", "session", session.Name, "error", err)
        }</span> else<span class="cov0" title="0"> {
                c.log.Infow("Debug session rejection email queued", "session", session.Name)
        }</span>
}

// sendDebugSessionCreatedEmail sends email confirmation to requester when a debug session is created
func (c *DebugSessionAPIController) sendDebugSessionCreatedEmail(ctx context.Context, session *v1alpha1.DebugSession, template *v1alpha1.DebugSessionTemplate, binding *v1alpha1.DebugSessionClusterBinding) <span class="cov0" title="0">{
        if c.disableEmail || c.mailService == nil || !c.mailService.IsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">notificationCfg := resolveNotificationConfig(template, binding)
        if !shouldSendNotification(notificationCfg, notificationEventRequest) </span><span class="cov0" title="0">{
                c.log.Debugw("Debug session created email disabled by notification settings", "session", session.Name)
                return
        }</span>

        // Send to the requester - use email field if available, fallback to requestedBy
        <span class="cov0" title="0">recipientEmail := session.Spec.RequestedByEmail
        if recipientEmail == "" </span><span class="cov0" title="0">{
                recipientEmail = session.Spec.RequestedBy
        }</span>
        // Skip if no valid email (must contain @)
        <span class="cov0" title="0">if !strings.Contains(recipientEmail, "@") </span><span class="cov0" title="0">{
                c.log.Warnw("Skipping session created email - no valid email address", "session", session.Name, "recipient", recipientEmail)
                return
        }</span>
        <span class="cov0" title="0">recipients := buildNotificationRecipients([]string{recipientEmail}, notificationCfg)

        // Use display name if available, fallback to username
        requesterName := session.Spec.RequestedByDisplayName
        if requesterName == "" </span><span class="cov0" title="0">{
                requesterName = session.Spec.RequestedBy
        }</span>

        <span class="cov0" title="0">params := mail.DebugSessionCreatedMailParams{
                RequesterName:     requesterName,
                RequesterEmail:    recipientEmail,
                SessionID:         session.Name,
                Cluster:           session.Spec.Cluster,
                TemplateName:      session.Spec.TemplateRef,
                Namespace:         session.Namespace,
                RequestedDuration: session.Spec.RequestedDuration,
                Reason:            session.Spec.Reason,
                RequestedAt:       session.CreationTimestamp.Format(time.RFC3339),
                RequiresApproval:  template.Spec.Approvers != nil &amp;&amp; len(template.Spec.Approvers.Users) &gt; 0,
                URL:               fmt.Sprintf("%s/debug-sessions/%s", c.baseURL, session.Name),
                BrandingName:      c.brandingName,
        }

        body, err := mail.RenderDebugSessionCreated(params)
        if err != nil </span><span class="cov0" title="0">{
                c.log.Errorw("Failed to render debug session created email", "session", session.Name, "error", err)
                return
        }</span>

        <span class="cov0" title="0">subject := fmt.Sprintf("[%s] Debug Session Created: %s", c.brandingName, session.Name)
        if err := c.mailService.Enqueue(session.Name, recipients, subject, body); err != nil </span><span class="cov0" title="0">{
                c.log.Errorw("Failed to enqueue debug session created email", "session", session.Name, "error", err)
        }</span> else<span class="cov0" title="0"> {
                c.log.Infow("Debug session created email queued", "session", session.Name, "requester", session.Spec.RequestedBy)
        }</span>
}

// emitDebugSessionAuditEvent emits an audit event for debug session lifecycle changes
func (c *DebugSessionAPIController) emitDebugSessionAuditEvent(ctx context.Context, eventType audit.EventType, session *v1alpha1.DebugSession, user string, message string) <span class="cov0" title="0">{
        if c.auditService == nil || !c.auditService.IsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">event := &amp;audit.Event{
                Type:      eventType,
                Timestamp: time.Now(),
                Actor: audit.Actor{
                        User:   user,
                        Groups: nil, // Groups not available in this context
                },
                Target: audit.Target{
                        Kind:      "DebugSession",
                        Name:      session.Name,
                        Namespace: session.Namespace,
                        Cluster:   session.Spec.Cluster,
                },
                RequestContext: &amp;audit.RequestContext{
                        SessionName: session.Name,
                },
                Details: map[string]interface{}{
                        "message":     message,
                        "cluster":     session.Spec.Cluster,
                        "templateRef": session.Spec.TemplateRef,
                        "requestedBy": session.Spec.RequestedBy,
                        "state":       string(session.Status.State),
                },
        }

        c.auditService.Emit(ctx, event)</span>
}

// handleInjectEphemeralContainer injects a debug container into an existing pod
func (c *DebugSessionAPIController) handleInjectEphemeralContainer(ctx *gin.Context) <span class="cov0" title="0">{
        reqLog := system.GetReqLogger(ctx, c.log)

        sessionName := ctx.Param("name")
        namespaceHint := ctx.Query("namespace")

        var req InjectEphemeralContainerRequest
        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                apiresponses.RespondBadRequest(ctx, err.Error())
                return
        }</span>

        // Get current user
        <span class="cov0" title="0">currentUser, exists := ctx.Get("username")
        if !exists || currentUser == nil </span><span class="cov0" title="0">{
                apiresponses.RespondUnauthorized(ctx)
                return
        }</span>

        <span class="cov0" title="0">apiCtx, cancel := context.WithTimeout(ctx.Request.Context(), APIContextTimeout)
        defer cancel()

        // Get the debug session
        session, err := c.getDebugSessionByName(apiCtx, sessionName, namespaceHint)
        if err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        apiresponses.RespondNotFoundSimple(ctx, "debug session not found")
                        return
                }</span>
                <span class="cov0" title="0">reqLog.Errorw("Failed to get debug session", "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to get debug session")
                return</span>
        }

        // Verify session is active
        <span class="cov0" title="0">if session.Status.State != v1alpha1.DebugSessionStateActive </span><span class="cov0" title="0">{
                apiresponses.RespondBadRequest(ctx, fmt.Sprintf("session is not active, current state: %s", session.Status.State))
                return
        }</span>

        // Verify user is a participant
        <span class="cov0" title="0">if !c.isUserParticipant(session, currentUser.(string)) </span><span class="cov0" title="0">{
                apiresponses.RespondForbidden(ctx, "user is not a participant of this session")
                return
        }</span>

        // Verify template supports kubectl-debug mode
        <span class="cov0" title="0">if session.Status.ResolvedTemplate == nil ||
                (session.Status.ResolvedTemplate.Mode != v1alpha1.DebugSessionModeKubectlDebug &amp;&amp;
                        session.Status.ResolvedTemplate.Mode != v1alpha1.DebugSessionModeHybrid) </span><span class="cov0" title="0">{
                apiresponses.RespondBadRequest(ctx, "session template does not support kubectl-debug mode")
                return
        }</span>

        // Create kubectl debug handler
        <span class="cov0" title="0">handler := NewKubectlDebugHandler(c.client, &amp;clusterClientAdapter{ccProvider: c.ccProvider})

        // Validate the request
        capabilities := extractCapabilities(req.SecurityContext)
        runAsNonRoot := extractRunAsNonRoot(req.SecurityContext)
        if err := handler.ValidateEphemeralContainerRequest(apiCtx, session, req.Namespace, req.PodName, req.Image, capabilities, runAsNonRoot); err != nil </span><span class="cov0" title="0">{
                apiresponses.RespondForbidden(ctx, err.Error())
                return
        }</span>

        // Inject the ephemeral container
        <span class="cov0" title="0">if err := handler.InjectEphemeralContainer(apiCtx, session, req.Namespace, req.PodName, req.ContainerName, req.Image, req.Command, req.SecurityContext, currentUser.(string)); err != nil </span><span class="cov0" title="0">{
                reqLog.Errorw("Failed to inject ephemeral container", "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to inject ephemeral container")
                return
        }</span>

        <span class="cov0" title="0">reqLog.Infow("Ephemeral container injected",
                "session", sessionName,
                "pod", req.PodName,
                "namespace", req.Namespace,
                "container", req.ContainerName,
                "user", currentUser)

        ctx.JSON(http.StatusOK, gin.H{
                "message":   "ephemeral container injected successfully",
                "pod":       req.PodName,
                "namespace": req.Namespace,
                "container": req.ContainerName,
        })</span>
}

// handleCreatePodCopy creates a debug copy of an existing pod
func (c *DebugSessionAPIController) handleCreatePodCopy(ctx *gin.Context) <span class="cov0" title="0">{
        reqLog := system.GetReqLogger(ctx, c.log)

        sessionName := ctx.Param("name")
        namespaceHint := ctx.Query("namespace")

        var req CreatePodCopyRequest
        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                apiresponses.RespondBadRequest(ctx, err.Error())
                return
        }</span>

        // Get current user
        <span class="cov0" title="0">currentUser, exists := ctx.Get("username")
        if !exists || currentUser == nil </span><span class="cov0" title="0">{
                apiresponses.RespondUnauthorized(ctx)
                return
        }</span>

        <span class="cov0" title="0">apiCtx, cancel := context.WithTimeout(ctx.Request.Context(), APIContextTimeout)
        defer cancel()

        // Get the debug session
        session, err := c.getDebugSessionByName(apiCtx, sessionName, namespaceHint)
        if err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        apiresponses.RespondNotFoundSimple(ctx, "debug session not found")
                        return
                }</span>
                <span class="cov0" title="0">reqLog.Errorw("Failed to get debug session", "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to get debug session")
                return</span>
        }

        // Verify session is active
        <span class="cov0" title="0">if session.Status.State != v1alpha1.DebugSessionStateActive </span><span class="cov0" title="0">{
                apiresponses.RespondBadRequest(ctx, fmt.Sprintf("session is not active, current state: %s", session.Status.State))
                return
        }</span>

        // Verify user is a participant
        <span class="cov0" title="0">if !c.isUserParticipant(session, currentUser.(string)) </span><span class="cov0" title="0">{
                apiresponses.RespondForbidden(ctx, "user is not a participant of this session")
                return
        }</span>

        // Verify template supports kubectl-debug mode
        <span class="cov0" title="0">if session.Status.ResolvedTemplate == nil ||
                (session.Status.ResolvedTemplate.Mode != v1alpha1.DebugSessionModeKubectlDebug &amp;&amp;
                        session.Status.ResolvedTemplate.Mode != v1alpha1.DebugSessionModeHybrid) </span><span class="cov0" title="0">{
                apiresponses.RespondBadRequest(ctx, "session template does not support kubectl-debug mode")
                return
        }</span>

        // Create kubectl debug handler
        <span class="cov0" title="0">handler := NewKubectlDebugHandler(c.client, &amp;clusterClientAdapter{ccProvider: c.ccProvider})

        // Create the pod copy
        pod, err := handler.CreatePodCopy(apiCtx, session, req.Namespace, req.PodName, req.DebugImage, currentUser.(string))
        if err != nil </span><span class="cov0" title="0">{
                reqLog.Errorw("Failed to create pod copy", "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to create pod copy")
                return
        }</span>

        <span class="cov0" title="0">reqLog.Infow("Pod copy created",
                "session", sessionName,
                "originalPod", req.PodName,
                "originalNamespace", req.Namespace,
                "copyName", pod.Name,
                "copyNamespace", pod.Namespace,
                "user", currentUser)

        ctx.JSON(http.StatusOK, gin.H{
                "message":           "pod copy created successfully",
                "copyName":          pod.Name,
                "copyNamespace":     pod.Namespace,
                "originalPod":       req.PodName,
                "originalNamespace": req.Namespace,
        })</span>
}

// handleCreateNodeDebugPod creates a debug pod on a specific node
func (c *DebugSessionAPIController) handleCreateNodeDebugPod(ctx *gin.Context) <span class="cov0" title="0">{
        reqLog := system.GetReqLogger(ctx, c.log)

        sessionName := ctx.Param("name")
        namespaceHint := ctx.Query("namespace")

        var req CreateNodeDebugPodRequest
        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                apiresponses.RespondBadRequest(ctx, err.Error())
                return
        }</span>

        // Get current user
        <span class="cov0" title="0">currentUser, exists := ctx.Get("username")
        if !exists || currentUser == nil </span><span class="cov0" title="0">{
                apiresponses.RespondUnauthorized(ctx)
                return
        }</span>

        <span class="cov0" title="0">apiCtx, cancel := context.WithTimeout(ctx.Request.Context(), APIContextTimeout)
        defer cancel()

        // Get the debug session
        session, err := c.getDebugSessionByName(apiCtx, sessionName, namespaceHint)
        if err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        apiresponses.RespondNotFoundSimple(ctx, "debug session not found")
                        return
                }</span>
                <span class="cov0" title="0">reqLog.Errorw("Failed to get debug session", "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to get debug session")
                return</span>
        }

        // Verify session is active
        <span class="cov0" title="0">if session.Status.State != v1alpha1.DebugSessionStateActive </span><span class="cov0" title="0">{
                apiresponses.RespondBadRequest(ctx, fmt.Sprintf("session is not active, current state: %s", session.Status.State))
                return
        }</span>

        // Verify user is a participant
        <span class="cov0" title="0">if !c.isUserParticipant(session, currentUser.(string)) </span><span class="cov0" title="0">{
                apiresponses.RespondForbidden(ctx, "user is not a participant of this session")
                return
        }</span>

        // Verify template supports kubectl-debug mode
        <span class="cov0" title="0">if session.Status.ResolvedTemplate == nil ||
                (session.Status.ResolvedTemplate.Mode != v1alpha1.DebugSessionModeKubectlDebug &amp;&amp;
                        session.Status.ResolvedTemplate.Mode != v1alpha1.DebugSessionModeHybrid) </span><span class="cov0" title="0">{
                apiresponses.RespondBadRequest(ctx, "session template does not support kubectl-debug mode")
                return
        }</span>

        // Create kubectl debug handler
        <span class="cov0" title="0">handler := NewKubectlDebugHandler(c.client, &amp;clusterClientAdapter{ccProvider: c.ccProvider})

        // Create the node debug pod
        pod, err := handler.CreateNodeDebugPod(apiCtx, session, req.NodeName, currentUser.(string))
        if err != nil </span><span class="cov0" title="0">{
                reqLog.Errorw("Failed to create node debug pod", "error", err)
                apiresponses.RespondInternalErrorSimple(ctx, "failed to create node debug pod")
                return
        }</span>

        <span class="cov0" title="0">reqLog.Infow("Node debug pod created",
                "session", sessionName,
                "node", req.NodeName,
                "podName", pod.Name,
                "namespace", pod.Namespace,
                "user", currentUser)

        ctx.JSON(http.StatusOK, gin.H{
                "message":   "node debug pod created successfully",
                "podName":   pod.Name,
                "namespace": pod.Namespace,
                "node":      req.NodeName,
        })</span>
}

// clusterClientAdapter adapts cluster.ClientProvider to ClientProviderInterface
type clusterClientAdapter struct {
        ccProvider *cluster.ClientProvider
}

func (a *clusterClientAdapter) GetClient(ctx context.Context, clusterName string) (ctrlclient.Client, error) <span class="cov0" title="0">{
        restCfg, err := a.ccProvider.GetRESTConfig(ctx, clusterName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ctrlclient.New(restCfg, ctrlclient.Options{})</span>
}

// isUserParticipant checks if the user is a participant of the session
func (c *DebugSessionAPIController) isUserParticipant(session *v1alpha1.DebugSession, user string) bool <span class="cov0" title="0">{
        // Owner is always a participant
        if session.Spec.RequestedBy == user </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check participants list
        <span class="cov0" title="0">for _, p := range session.Status.Participants </span><span class="cov0" title="0">{
                if p.User == user &amp;&amp; p.LeftAt == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// extractCapabilities extracts capability names from a security context
func extractCapabilities(sc *corev1.SecurityContext) []string <span class="cov0" title="0">{
        if sc == nil || sc.Capabilities == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">var caps []string
        for _, c := range sc.Capabilities.Add </span><span class="cov0" title="0">{
                caps = append(caps, string(c))
        }</span>
        <span class="cov0" title="0">return caps</span>
}

// extractRunAsNonRoot extracts the runAsNonRoot value from a security context
func extractRunAsNonRoot(sc *corev1.SecurityContext) bool <span class="cov0" title="0">{
        if sc == nil || sc.RunAsNonRoot == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return *sc.RunAsNonRoot</span>
}

// checkBindingSessionLimits verifies that creating a new session won't exceed the binding's session limits.
// Returns nil if the session can be created, or an error describing the limit violation.
func (c *DebugSessionAPIController) checkBindingSessionLimits(ctx context.Context, binding *v1alpha1.DebugSessionClusterBinding, userEmail string) error <span class="cov0" title="0">{
        if binding == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get current active sessions for this binding
        <span class="cov0" title="0">sessionList := &amp;v1alpha1.DebugSessionList{}
        if err := c.client.List(ctx, sessionList); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list sessions: %w", err)
        }</span>

        // Count active sessions for this binding
        <span class="cov0" title="0">var totalActive int32
        var userActive int32
        for i := range sessionList.Items </span><span class="cov0" title="0">{
                session := &amp;sessionList.Items[i]
                // Check if session uses this binding
                if session.Spec.BindingRef == nil ||
                        session.Spec.BindingRef.Name != binding.Name ||
                        session.Spec.BindingRef.Namespace != binding.Namespace </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if session is active (pending or approved, not expired/terminated/failed)
                <span class="cov0" title="0">if session.Status.State == v1alpha1.DebugSessionStateTerminated ||
                        session.Status.State == v1alpha1.DebugSessionStateExpired ||
                        session.Status.State == v1alpha1.DebugSessionStateFailed </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">totalActive++
                if session.Spec.RequestedByEmail == userEmail || session.Spec.RequestedBy == userEmail </span><span class="cov0" title="0">{
                        userActive++
                }</span>
        }

        // Check per-user limit
        <span class="cov0" title="0">if binding.Spec.MaxActiveSessionsPerUser != nil </span><span class="cov0" title="0">{
                if userActive &gt;= *binding.Spec.MaxActiveSessionsPerUser </span><span class="cov0" title="0">{
                        return fmt.Errorf("session limit reached: maximum %d active sessions per user allowed via this binding", *binding.Spec.MaxActiveSessionsPerUser)
                }</span>
        }

        // Check total limit
        <span class="cov0" title="0">if binding.Spec.MaxActiveSessionsTotal != nil </span><span class="cov0" title="0">{
                if totalActive &gt;= *binding.Spec.MaxActiveSessionsTotal </span><span class="cov0" title="0">{
                        return fmt.Errorf("session limit reached: maximum %d total active sessions allowed via this binding", *binding.Spec.MaxActiveSessionsTotal)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ClusterAllowedResult contains the result of checking if a cluster is allowed
type ClusterAllowedResult struct {
        Allowed         bool
        AllowedBySource string                                // "template" or "binding:&lt;ns&gt;/&lt;name&gt;"
        MatchingBinding *v1alpha1.DebugSessionClusterBinding  // Non-nil if allowed by binding
        AllBindings     []v1alpha1.DebugSessionClusterBinding // All bindings that allow this cluster
}

// isClusterAllowedByTemplateOrBinding checks if a cluster is allowed by the template's allowed.clusters
// or by any active binding that references this template.
// This function requires the caller to pass in the bindings and clusterConfigs.
// If the template has no allowed.clusters, cluster access depends on bindings.
// If there are no bindings either, access is implicitly allowed (backward compatibility).
func (c *DebugSessionAPIController) isClusterAllowedByTemplateOrBinding(
        template *v1alpha1.DebugSessionTemplate,
        clusterName string,
        bindings []v1alpha1.DebugSessionClusterBinding,
        clusterConfigs map[string]*v1alpha1.ClusterConfig,
) ClusterAllowedResult <span class="cov0" title="0">{
        result := ClusterAllowedResult{}

        hasTemplateClusterRestriction := template.Spec.Allowed != nil &amp;&amp; len(template.Spec.Allowed.Clusters) &gt; 0

        c.log.Debugw("isClusterAllowedByTemplateOrBinding starting",
                "template", template.Name,
                "cluster", clusterName,
                "hasTemplateClusterRestriction", hasTemplateClusterRestriction,
                "totalBindingsProvided", len(bindings),
                "totalClusterConfigs", len(clusterConfigs),
        )

        // Check if clusterName exists in clusterConfigs
        if _, exists := clusterConfigs[clusterName]; !exists </span><span class="cov0" title="0">{
                c.log.Warnw("Requested cluster not found in ClusterConfig map",
                        "cluster", clusterName,
                        "availableClusters", func() []string </span><span class="cov0" title="0">{
                                names := make([]string, 0, len(clusterConfigs))
                                for name := range clusterConfigs </span><span class="cov0" title="0">{
                                        names = append(names, name)
                                }</span>
                                <span class="cov0" title="0">return names</span>
                        }(),
                )
        }

        // 1. Check if allowed by template's allowed.clusters
        <span class="cov0" title="0">if hasTemplateClusterRestriction </span><span class="cov0" title="0">{
                for _, pattern := range template.Spec.Allowed.Clusters </span><span class="cov0" title="0">{
                        if matchPattern(pattern, clusterName) </span><span class="cov0" title="0">{
                                c.log.Debugw("Cluster allowed by template pattern",
                                        "cluster", clusterName,
                                        "pattern", pattern,
                                )
                                result.Allowed = true
                                result.AllowedBySource = "template"
                                return result
                        }</span>
                }
                <span class="cov0" title="0">c.log.Debugw("Cluster not allowed by template patterns",
                        "cluster", clusterName,
                        "templatePatterns", template.Spec.Allowed.Clusters,
                )</span>
        }

        // 2. Check if allowed by any binding that references this template
        <span class="cov0" title="0">applicableBindings := c.findBindingsForTemplate(template, bindings)
        c.log.Debugw("Found bindings for template",
                "template", template.Name,
                "applicableBindingsCount", len(applicableBindings),
                "applicableBindingNames", func() []string </span><span class="cov0" title="0">{
                        names := make([]string, len(applicableBindings))
                        for i, b := range applicableBindings </span><span class="cov0" title="0">{
                                names[i] = fmt.Sprintf("%s/%s", b.Namespace, b.Name)
                        }</span>
                        <span class="cov0" title="0">return names</span>
                }(),
        )

        <span class="cov0" title="0">for i := range applicableBindings </span><span class="cov0" title="0">{
                binding := &amp;applicableBindings[i]
                bindingClusters := c.resolveClustersFromBinding(binding, clusterConfigs)
                c.log.Debugw("Binding cluster resolution",
                        "binding", fmt.Sprintf("%s/%s", binding.Namespace, binding.Name),
                        "resolvedClusters", bindingClusters,
                        "lookingFor", clusterName,
                )
                for _, bc := range bindingClusters </span><span class="cov0" title="0">{
                        if bc == clusterName </span><span class="cov0" title="0">{
                                result.AllBindings = append(result.AllBindings, *binding)
                                if !result.Allowed </span><span class="cov0" title="0">{
                                        result.Allowed = true
                                        result.AllowedBySource = fmt.Sprintf("binding:%s/%s", binding.Namespace, binding.Name)
                                        result.MatchingBinding = binding
                                        c.log.Debugw("Cluster allowed by binding",
                                                "cluster", clusterName,
                                                "binding", fmt.Sprintf("%s/%s", binding.Namespace, binding.Name),
                                        )
                                }</span>
                        }
                }
        }

        // 3. If template has no cluster restriction and no bindings provide explicit access,
        // the template is effectively unavailable (no clusters can be deployed to).
        // This is different from the old "backward compatibility" behavior that allowed all clusters.
        <span class="cov0" title="0">if !result.Allowed &amp;&amp; !hasTemplateClusterRestriction &amp;&amp; len(applicableBindings) == 0 </span><span class="cov0" title="0">{
                c.log.Debugw("Cluster denied - template has no cluster restrictions and no bindings (unavailable template)",
                        "cluster", clusterName,
                        "template", template.Name,
                )
                // result.Allowed remains false
        }</span>

        <span class="cov0" title="0">c.log.Debugw("isClusterAllowedByTemplateOrBinding result",
                "cluster", clusterName,
                "allowed", result.Allowed,
                "source", result.AllowedBySource,
        )

        return result</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
Copyright 2026.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package breakglass

import (
        "context"
        "fmt"
        "path/filepath"
        "strings"
        "time"

        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        ctrlclient "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/telekom/k8s-breakglass/api/v1alpha1"
        "github.com/telekom/k8s-breakglass/pkg/indexer"
        "github.com/telekom/k8s-breakglass/pkg/utils"
)

// KubectlDebugHandler handles kubectl-debug mode operations
type KubectlDebugHandler struct {
        client     ctrlclient.Client
        ccProvider ClientProviderInterface
}

// ClientProviderInterface abstracts the cluster.ClientProvider for testing
type ClientProviderInterface interface {
        GetClient(ctx context.Context, clusterName string) (ctrlclient.Client, error)
}

// NewKubectlDebugHandler creates a new kubectl debug handler
func NewKubectlDebugHandler(client ctrlclient.Client, ccProvider ClientProviderInterface) *KubectlDebugHandler <span class="cov0" title="0">{
        return &amp;KubectlDebugHandler{
                client:     client,
                ccProvider: ccProvider,
        }
}</span>

// FindActiveSession finds an active debug session for the user/cluster
func (h *KubectlDebugHandler) FindActiveSession(ctx context.Context, user, cluster string) (*v1alpha1.DebugSession, error) <span class="cov0" title="0">{
        var list v1alpha1.DebugSessionList
        listOpts := make([]ctrlclient.ListOption, 0, 3)
        if cluster != "" &amp;&amp; indexer.IsIndexRegistered("DebugSession", "spec.cluster") </span><span class="cov0" title="0">{
                listOpts = append(listOpts, ctrlclient.MatchingFields{"spec.cluster": cluster})
        }</span>
        <span class="cov0" title="0">if indexer.IsIndexRegistered("DebugSession", "status.state") </span><span class="cov0" title="0">{
                listOpts = append(listOpts, ctrlclient.MatchingFields{"status.state": string(v1alpha1.DebugSessionStateActive)})
        }</span>
        <span class="cov0" title="0">if user != "" &amp;&amp; indexer.IsIndexRegistered("DebugSession", "status.participants.user") </span><span class="cov0" title="0">{
                listOpts = append(listOpts, ctrlclient.MatchingFields{"status.participants.user": user})
        }</span>

        <span class="cov0" title="0">if err := h.client.List(ctx, &amp;list, listOpts...); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, ds := range list.Items </span><span class="cov0" title="0">{
                // If cluster is specified, filter by it
                if cluster != "" &amp;&amp; ds.Spec.Cluster != cluster </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if ds.Status.State != v1alpha1.DebugSessionStateActive </span><span class="cov0" title="0">{
                        continue</span>
                }
                // Check expiration just in case status is stale
                <span class="cov0" title="0">if ds.Status.ExpiresAt != nil &amp;&amp; time.Now().After(ds.Status.ExpiresAt.Time) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if user is a participant
                <span class="cov0" title="0">for _, p := range ds.Status.Participants </span><span class="cov0" title="0">{
                        if p.User == user </span><span class="cov0" title="0">{
                                return &amp;ds, nil
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil, nil</span>
}

// ValidateEphemeralContainerRequest validates an ephemeral container injection request
func (h *KubectlDebugHandler) ValidateEphemeralContainerRequest(
        ctx context.Context,
        ds *v1alpha1.DebugSession,
        namespace, podName, image string,
        capabilities []string,
        runAsNonRoot bool,
) error <span class="cov0" title="0">{
        template := ds.Status.ResolvedTemplate
        if template == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no resolved template in session")
        }</span>

        <span class="cov0" title="0">if template.KubectlDebug == nil || template.KubectlDebug.EphemeralContainers == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ephemeral containers not configured in template")
        }</span>

        <span class="cov0" title="0">ec := template.KubectlDebug.EphemeralContainers
        if !ec.Enabled </span><span class="cov0" title="0">{
                return fmt.Errorf("ephemeral containers are not enabled for this template")
        }</span>

        // Validate namespace
        <span class="cov0" title="0">if !h.isNamespaceAllowed(namespace, ec.AllowedNamespaces, ec.DeniedNamespaces) </span><span class="cov0" title="0">{
                return fmt.Errorf("namespace %s is not allowed for ephemeral container injection", namespace)
        }</span>

        // Validate image
        <span class="cov0" title="0">if !h.isImageAllowed(image, ec.AllowedImages) </span><span class="cov0" title="0">{
                return fmt.Errorf("image %s is not in the allowed list", image)
        }</span>

        // Validate image digest if required
        <span class="cov0" title="0">if ec.RequireImageDigest &amp;&amp; !h.hasImageDigest(image) </span><span class="cov0" title="0">{
                return fmt.Errorf("image must use @sha256: digest")
        }</span>

        // Validate capabilities
        <span class="cov0" title="0">for _, cap := range capabilities </span><span class="cov0" title="0">{
                if !h.isCapabilityAllowed(cap, ec.MaxCapabilities) </span><span class="cov0" title="0">{
                        return fmt.Errorf("capability %s is not allowed", cap)
                }</span>
        }

        // Validate non-root
        <span class="cov0" title="0">if ec.RequireNonRoot &amp;&amp; !runAsNonRoot </span><span class="cov0" title="0">{
                return fmt.Errorf("ephemeral container must run as non-root")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// InjectEphemeralContainer injects an ephemeral debug container into a pod
func (h *KubectlDebugHandler) InjectEphemeralContainer(
        ctx context.Context,
        ds *v1alpha1.DebugSession,
        namespace, podName, containerName, image string,
        command []string,
        securityContext *corev1.SecurityContext,
        user string,
) error <span class="cov0" title="0">{
        // Get target cluster client
        targetClient, err := h.ccProvider.GetClient(ctx, ds.Spec.Cluster)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get client for cluster %s: %w", ds.Spec.Cluster, err)
        }</span>

        // Get the target pod
        <span class="cov0" title="0">pod := &amp;corev1.Pod{}
        if err := targetClient.Get(ctx, ctrlclient.ObjectKey{Namespace: namespace, Name: podName}, pod); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get pod %s/%s: %w", namespace, podName, err)
        }</span>

        // Check if container name already exists
        <span class="cov0" title="0">for _, ec := range pod.Spec.EphemeralContainers </span><span class="cov0" title="0">{
                if ec.Name == containerName </span><span class="cov0" title="0">{
                        return fmt.Errorf("ephemeral container %s already exists in pod", containerName)
                }</span>
        }

        // Create ephemeral container spec
        <span class="cov0" title="0">ephemeralContainer := corev1.EphemeralContainer{
                EphemeralContainerCommon: corev1.EphemeralContainerCommon{
                        Name:            containerName,
                        Image:           image,
                        Command:         command,
                        ImagePullPolicy: corev1.PullIfNotPresent,
                        TTY:             true,
                        Stdin:           true,
                },
        }

        if securityContext != nil </span><span class="cov0" title="0">{
                ephemeralContainer.SecurityContext = securityContext
        }</span>

        // Add the ephemeral container
        <span class="cov0" title="0">pod.Spec.EphemeralContainers = append(pod.Spec.EphemeralContainers, ephemeralContainer)

        // Update the pod using SubResource for ephemeral containers
        if err := targetClient.SubResource("ephemeralcontainers").Update(ctx, pod); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to inject ephemeral container: %w", err)
        }</span>

        // Track the injected container in session status
        <span class="cov0" title="0">now := metav1.Now()
        if ds.Status.KubectlDebugStatus == nil </span><span class="cov0" title="0">{
                ds.Status.KubectlDebugStatus = &amp;v1alpha1.KubectlDebugStatus{}
        }</span>

        <span class="cov0" title="0">ds.Status.KubectlDebugStatus.EphemeralContainersInjected = append(
                ds.Status.KubectlDebugStatus.EphemeralContainersInjected,
                v1alpha1.EphemeralContainerRef{
                        PodName:       podName,
                        Namespace:     namespace,
                        ContainerName: containerName,
                        Image:         image,
                        InjectedAt:    now,
                        InjectedBy:    user,
                },
        )

        // Also add to allowed pods if not already present
        podAlreadyAllowed := false
        for _, p := range ds.Status.AllowedPods </span><span class="cov0" title="0">{
                if p.Namespace == namespace &amp;&amp; p.Name == podName </span><span class="cov0" title="0">{
                        podAlreadyAllowed = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !podAlreadyAllowed </span><span class="cov0" title="0">{
                ds.Status.AllowedPods = append(ds.Status.AllowedPods, v1alpha1.AllowedPodRef{
                        Namespace: namespace,
                        Name:      podName,
                        Ready:     true,
                })
        }</span>

        <span class="cov0" title="0">return applyDebugSessionStatus(ctx, h.client, ds)</span>
}

// CreatePodCopy creates a debug copy of a pod
func (h *KubectlDebugHandler) CreatePodCopy(
        ctx context.Context,
        ds *v1alpha1.DebugSession,
        originalNamespace, originalPodName string,
        debugImage string,
        user string,
) (*corev1.Pod, error) <span class="cov0" title="0">{
        template := ds.Status.ResolvedTemplate
        if template == nil || template.KubectlDebug == nil || template.KubectlDebug.PodCopy == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("pod copy not configured in template")
        }</span>

        <span class="cov0" title="0">pc := template.KubectlDebug.PodCopy
        if !pc.Enabled </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("pod copy is not enabled for this template")
        }</span>

        // Get target cluster client
        <span class="cov0" title="0">targetClient, err := h.ccProvider.GetClient(ctx, ds.Spec.Cluster)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get client for cluster %s: %w", ds.Spec.Cluster, err)
        }</span>

        // Get the original pod
        <span class="cov0" title="0">originalPod := &amp;corev1.Pod{}
        if err := targetClient.Get(ctx, ctrlclient.ObjectKey{Namespace: originalNamespace, Name: originalPodName}, originalPod); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get pod %s/%s: %w", originalNamespace, originalPodName, err)
        }</span>

        // Determine target namespace
        <span class="cov0" title="0">targetNs := pc.TargetNamespace
        if targetNs == "" </span><span class="cov0" title="0">{
                targetNs = "debug-copies"
        }</span>

        // Ensure target namespace exists
        <span class="cov0" title="0">ns := &amp;corev1.Namespace{}
        if err := targetClient.Get(ctx, ctrlclient.ObjectKey{Name: targetNs}, ns); err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("target namespace %s does not exist", targetNs)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to check namespace: %w", err)</span>
        }

        // Create copy name
        <span class="cov0" title="0">copyName := fmt.Sprintf("debug-copy-%s-%s", originalPodName, ds.Name[:8])
        if len(copyName) &gt; 63 </span><span class="cov0" title="0">{
                copyName = copyName[:63]
        }</span>

        // Build the copy pod spec
        <span class="cov0" title="0">copyPod := &amp;corev1.Pod{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      copyName,
                        Namespace: targetNs,
                        Labels: map[string]string{
                                DebugSessionLabelKey:                 ds.Name,
                                "breakglass.telekom.com/debug-copy":  "true",
                                "breakglass.telekom.com/original":    originalPodName,
                                "breakglass.telekom.com/original-ns": originalNamespace,
                        },
                },
                Spec: *originalPod.Spec.DeepCopy(),
        }

        // Add custom labels from config
        for k, v := range pc.Labels </span><span class="cov0" title="0">{
                copyPod.Labels[k] = v
        }</span>

        // Modify for debugging
        <span class="cov0" title="0">copyPod.Spec.RestartPolicy = corev1.RestartPolicyNever

        // Add debug container if image specified
        if debugImage != "" </span><span class="cov0" title="0">{
                debugContainer := corev1.Container{
                        Name:    "debugger",
                        Image:   debugImage,
                        Command: []string{"sleep", "infinity"},
                        TTY:     true,
                        Stdin:   true,
                }
                copyPod.Spec.Containers = append(copyPod.Spec.Containers, debugContainer)
        }</span>

        // Reset status-related fields
        <span class="cov0" title="0">copyPod.Spec.NodeName = ""
        copyPod.ResourceVersion = ""
        copyPod.UID = ""

        // Create the copy pod using Create (not SSA) because each pod copy must be unique
        if err := targetClient.Create(ctx, copyPod); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create pod copy: %w", err)
        }</span>

        // Calculate expiry (supports day units like "1d")
        <span class="cov0" title="0">ttl := pc.TTL
        if ttl == "" </span><span class="cov0" title="0">{
                ttl = "2h"
        }</span>
        <span class="cov0" title="0">ttlDuration, err := v1alpha1.ParseDuration(ttl)
        if err != nil </span><span class="cov0" title="0">{
                ttlDuration = 2 * time.Hour
        }</span>
        <span class="cov0" title="0">expiresAt := metav1.NewTime(time.Now().Add(ttlDuration))

        // Track the copied pod in session status
        now := metav1.Now()
        if ds.Status.KubectlDebugStatus == nil </span><span class="cov0" title="0">{
                ds.Status.KubectlDebugStatus = &amp;v1alpha1.KubectlDebugStatus{}
        }</span>

        <span class="cov0" title="0">ds.Status.KubectlDebugStatus.CopiedPods = append(
                ds.Status.KubectlDebugStatus.CopiedPods,
                v1alpha1.CopiedPodRef{
                        OriginalPod:       originalPodName,
                        OriginalNamespace: originalNamespace,
                        CopyName:          copyName,
                        CopyNamespace:     targetNs,
                        CreatedAt:         now,
                        ExpiresAt:         &amp;expiresAt,
                },
        )

        // Add to allowed pods
        ds.Status.AllowedPods = append(ds.Status.AllowedPods, v1alpha1.AllowedPodRef{
                Namespace: targetNs,
                Name:      copyName,
                Ready:     false, // Will be updated by reconciler
        })

        if err := applyDebugSessionStatus(ctx, h.client, ds); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update session status: %w", err)
        }</span>

        <span class="cov0" title="0">return copyPod, nil</span>
}

// CreateNodeDebugPod creates a debug pod on a specific node
func (h *KubectlDebugHandler) CreateNodeDebugPod(
        ctx context.Context,
        ds *v1alpha1.DebugSession,
        nodeName string,
        user string,
) (*corev1.Pod, error) <span class="cov0" title="0">{
        template := ds.Status.ResolvedTemplate
        if template == nil || template.KubectlDebug == nil || template.KubectlDebug.NodeDebug == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("node debug not configured in template")
        }</span>

        <span class="cov0" title="0">nd := template.KubectlDebug.NodeDebug
        if !nd.Enabled </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("node debug is not enabled for this template")
        }</span>

        // Validate node selector if configured
        <span class="cov0" title="0">if len(nd.NodeSelector) &gt; 0 </span><span class="cov0" title="0">{
                // Get target cluster client
                targetClient, err := h.ccProvider.GetClient(ctx, ds.Spec.Cluster)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get client for cluster %s: %w", ds.Spec.Cluster, err)
                }</span>

                // Get the node
                <span class="cov0" title="0">node := &amp;corev1.Node{}
                if err := targetClient.Get(ctx, ctrlclient.ObjectKey{Name: nodeName}, node); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get node %s: %w", nodeName, err)
                }</span>

                // Check node selector
                <span class="cov0" title="0">for k, v := range nd.NodeSelector </span><span class="cov0" title="0">{
                        if nodeVal, exists := node.Labels[k]; !exists || nodeVal != v </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("node %s does not match required selector %s=%s", nodeName, k, v)
                        }</span>
                }
        }

        // Determine image
        <span class="cov0" title="0">image := "busybox:stable"
        if len(nd.AllowedImages) &gt; 0 </span><span class="cov0" title="0">{
                image = nd.AllowedImages[0]
        }</span>

        // Build host namespace config
        <span class="cov0" title="0">hostNetwork := true
        hostPID := true
        hostIPC := false
        if nd.HostNamespaces != nil </span><span class="cov0" title="0">{
                hostNetwork = nd.HostNamespaces.HostNetwork
                hostPID = nd.HostNamespaces.HostPID
                hostIPC = nd.HostNamespaces.HostIPC
        }</span>

        // Get target cluster client
        <span class="cov0" title="0">targetClient, err := h.ccProvider.GetClient(ctx, ds.Spec.Cluster)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get client for cluster %s: %w", ds.Spec.Cluster, err)
        }</span>

        // Create the debug pod
        <span class="cov0" title="0">podName := fmt.Sprintf("node-debugger-%s-%s", nodeName, ds.Name[:8])
        if len(podName) &gt; 63 </span><span class="cov0" title="0">{
                podName = podName[:63]
        }</span>

        // Determine namespace from template or default
        <span class="cov0" title="0">namespace := "breakglass-debug"
        if template.TargetNamespace != "" </span><span class="cov0" title="0">{
                namespace = template.TargetNamespace
        }</span>

        <span class="cov0" title="0">debugPod := &amp;corev1.Pod{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      podName,
                        Namespace: namespace,
                        Labels: map[string]string{
                                DebugSessionLabelKey:                  ds.Name,
                                "breakglass.telekom.com/node-debug":   "true",
                                "breakglass.telekom.com/target-node":  nodeName,
                                "breakglass.telekom.com/requested-by": sanitizeLabel(user),
                        },
                },
                Spec: corev1.PodSpec{
                        NodeName:      nodeName,
                        HostNetwork:   hostNetwork,
                        HostPID:       hostPID,
                        HostIPC:       hostIPC,
                        RestartPolicy: corev1.RestartPolicyNever,
                        Containers: []corev1.Container{
                                {
                                        Name:    "debugger",
                                        Image:   image,
                                        Command: []string{"sleep", "infinity"},
                                        TTY:     true,
                                        Stdin:   true,
                                        SecurityContext: &amp;corev1.SecurityContext{
                                                Privileged: boolPtr(true),
                                        },
                                        VolumeMounts: []corev1.VolumeMount{
                                                {
                                                        Name:      "host-root",
                                                        MountPath: "/host",
                                                        ReadOnly:  false,
                                                },
                                        },
                                },
                        },
                        Volumes: []corev1.Volume{
                                {
                                        Name: "host-root",
                                        VolumeSource: corev1.VolumeSource{
                                                HostPath: &amp;corev1.HostPathVolumeSource{
                                                        Path: "/",
                                                },
                                        },
                                },
                        },
                        Tolerations: []corev1.Toleration{
                                {
                                        Operator: corev1.TolerationOpExists,
                                },
                        },
                },
        }

        // Create the pod using Create (not SSA) because each debug pod must be unique
        if err := targetClient.Create(ctx, debugPod); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create node debug pod: %w", err)
        }</span>

        // Add to allowed pods and deployed resources
        <span class="cov0" title="0">ds.Status.AllowedPods = append(ds.Status.AllowedPods, v1alpha1.AllowedPodRef{
                Namespace: namespace,
                Name:      podName,
                NodeName:  nodeName,
                Ready:     false, // Will be updated by reconciler
        })

        ds.Status.DeployedResources = append(ds.Status.DeployedResources, v1alpha1.DeployedResourceRef{
                APIVersion: "v1",
                Kind:       "Pod",
                Name:       podName,
                Namespace:  namespace,
        })

        if err := applyDebugSessionStatus(ctx, h.client, ds); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update session status: %w", err)
        }</span>

        <span class="cov0" title="0">return debugPod, nil</span>
}

// CleanupKubectlDebugResources cleans up kubectl-debug resources
func (h *KubectlDebugHandler) CleanupKubectlDebugResources(ctx context.Context, ds *v1alpha1.DebugSession) error <span class="cov0" title="0">{
        if ds.Status.KubectlDebugStatus == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">targetClient, err := h.ccProvider.GetClient(ctx, ds.Spec.Cluster)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get client for cluster %s: %w", ds.Spec.Cluster, err)
        }</span>

        // Cleanup copied pods
        <span class="cov0" title="0">for _, cp := range ds.Status.KubectlDebugStatus.CopiedPods </span><span class="cov0" title="0">{
                pod := &amp;corev1.Pod{
                        ObjectMeta: metav1.ObjectMeta{
                                Name:      cp.CopyName,
                                Namespace: cp.CopyNamespace,
                        },
                }
                if err := targetClient.Delete(ctx, pod); err != nil &amp;&amp; !apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        // Log but continue cleanup
                        continue</span>
                }
        }

        // Note: Ephemeral containers cannot be removed, they remain until pod deletion
        // Clear the status
        <span class="cov0" title="0">ds.Status.KubectlDebugStatus = nil

        return applyDebugSessionStatus(ctx, h.client, ds)</span>
}

// Helper functions

func (h *KubectlDebugHandler) isNamespaceAllowed(namespace string, allowed, denied *v1alpha1.NamespaceFilter) bool <span class="cov0" title="0">{
        // Use NamespaceAllowDenyMatcher for combined allow/deny logic
        matcher := utils.NewNamespaceAllowDenyMatcher(allowed, denied)
        return matcher.IsAllowed(namespace)
}</span>

func (h *KubectlDebugHandler) isImageAllowed(image string, allowed []string) bool <span class="cov0" title="0">{
        if len(allowed) == 0 </span><span class="cov0" title="0">{
                return true // No restrictions
        }</span>

        <span class="cov0" title="0">for _, pattern := range allowed </span><span class="cov0" title="0">{
                // Handle digest patterns (image@sha256:*)
                if strings.Contains(pattern, "@sha256:*") </span><span class="cov0" title="0">{
                        base := strings.Split(pattern, "@")[0]
                        if strings.HasPrefix(image, base+"@sha256:") </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }

                // Standard glob matching
                <span class="cov0" title="0">if matched, _ := filepath.Match(pattern, image); matched </span><span class="cov0" title="0">{
                        return true
                }</span>

                // Check if image starts with pattern (for versioned images)
                <span class="cov0" title="0">if strings.HasPrefix(image, strings.TrimSuffix(pattern, "*")) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (h *KubectlDebugHandler) hasImageDigest(image string) bool <span class="cov0" title="0">{
        return strings.Contains(image, "@sha256:")
}</span>

func (h *KubectlDebugHandler) isCapabilityAllowed(capability string, maxCaps []string) bool <span class="cov0" title="0">{
        if len(maxCaps) == 0 </span><span class="cov0" title="0">{
                return true // No restrictions
        }</span>

        <span class="cov0" title="0">for _, allowed := range maxCaps </span><span class="cov0" title="0">{
                if strings.EqualFold(capability, allowed) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func boolPtr(b bool) *bool <span class="cov0" title="0">{
        return &amp;b
}</span>

func sanitizeLabel(value string) string <span class="cov0" title="0">{
        // Simple sanitization for Kubernetes label values
        // Replace invalid characters with underscore
        result := strings.Map(func(r rune) rune </span><span class="cov0" title="0">{
                if (r &gt;= 'a' &amp;&amp; r &lt;= 'z') || (r &gt;= 'A' &amp;&amp; r &lt;= 'Z') || (r &gt;= '0' &amp;&amp; r &lt;= '9') || r == '-' || r == '_' || r == '.' </span><span class="cov0" title="0">{
                        return r
                }</span>
                <span class="cov0" title="0">return '_'</span>
        }, value)

        // Truncate to max label length
        <span class="cov0" title="0">if len(result) &gt; 63 </span><span class="cov0" title="0">{
                result = result[:63]
        }</span>

        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">/*
Copyright 2026.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package breakglass

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "path/filepath"
        "strings"
        "time"

        "go.uber.org/zap"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        policyv1 "k8s.io/api/policy/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/api/resource"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/apimachinery/pkg/util/intstr"
        "k8s.io/client-go/rest"
        ctrl "sigs.k8s.io/controller-runtime"
        ctrlclient "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/yaml"

        "github.com/telekom/k8s-breakglass/api/v1alpha1"
        "github.com/telekom/k8s-breakglass/api/v1alpha1/applyconfiguration/ssa"
        "github.com/telekom/k8s-breakglass/pkg/audit"
        "github.com/telekom/k8s-breakglass/pkg/cluster"
        "github.com/telekom/k8s-breakglass/pkg/mail"
        "github.com/telekom/k8s-breakglass/pkg/metrics"
        "github.com/telekom/k8s-breakglass/pkg/utils"
)

const (
        // DebugSessionLabelKey is used to identify debug pods
        DebugSessionLabelKey = "breakglass.telekom.com/debug-session"
        // DebugTemplateLabelKey identifies the template used
        DebugTemplateLabelKey = "breakglass.telekom.com/debug-template"
        // DebugClusterLabelKey identifies the target cluster
        DebugClusterLabelKey = "breakglass.telekom.com/debug-cluster"

        // DefaultDebugSessionRequeue is the default requeue interval
        DefaultDebugSessionRequeue = 30 * time.Second
        // ExpiredSessionRequeue is requeue for cleanup
        ExpiredSessionRequeue = 5 * time.Second
)

// DebugSessionController manages DebugSession lifecycle
type DebugSessionController struct {
        log          *zap.SugaredLogger
        client       ctrlclient.Client
        ccProvider   *cluster.ClientProvider
        auditManager *audit.Manager
        mailService  MailEnqueuer
        auxiliaryMgr *AuxiliaryResourceManager
        brandingName string
        baseURL      string
        disableEmail bool
}

// NewDebugSessionController creates a new DebugSessionController
func NewDebugSessionController(log *zap.SugaredLogger, client ctrlclient.Client, ccProvider *cluster.ClientProvider) *DebugSessionController <span class="cov0" title="0">{
        return &amp;DebugSessionController{
                log:          log,
                client:       client,
                ccProvider:   ccProvider,
                auxiliaryMgr: NewAuxiliaryResourceManager(log.Named("auxiliary"), client),
        }
}</span>

// WithAuditManager sets the audit manager for the controller
func (c *DebugSessionController) WithAuditManager(am *audit.Manager) *DebugSessionController <span class="cov0" title="0">{
        c.auditManager = am
        return c
}</span>

// WithMailService sets the mail service for sending failure notifications
func (c *DebugSessionController) WithMailService(mailService MailEnqueuer, brandingName, baseURL string, disableEmail bool) *DebugSessionController <span class="cov0" title="0">{
        c.mailService = mailService
        c.brandingName = brandingName
        c.baseURL = baseURL
        c.disableEmail = disableEmail
        return c
}</span>

// SetupWithManager sets up the controller with the Manager
func (c *DebugSessionController) SetupWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;v1alpha1.DebugSession{}).
                Complete(c)
}</span>

// +kubebuilder:rbac:groups=breakglass.t-caas.telekom.com,resources=debugsessions,verbs=get;list;watch;create;update;patch;delete;deletecollection
// +kubebuilder:rbac:groups=breakglass.t-caas.telekom.com,resources=debugsessions/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=breakglass.t-caas.telekom.com,resources=debugsessions/finalizers,verbs=update
// +kubebuilder:rbac:groups=breakglass.t-caas.telekom.com,resources=debugsessiontemplates,verbs=get;list;watch
// +kubebuilder:rbac:groups=breakglass.t-caas.telekom.com,resources=debugsessiontemplates/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=breakglass.t-caas.telekom.com,resources=debugpodtemplates,verbs=get;list;watch
// +kubebuilder:rbac:groups=breakglass.t-caas.telekom.com,resources=debugpodtemplates/status,verbs=get;update;patch
// +kubebuilder:rbac:groups="",resources=pods,verbs=get;list;watch;create;delete
// +kubebuilder:rbac:groups="",resources=pods/exec,verbs=create
// +kubebuilder:rbac:groups="",resources=pods/log,verbs=get
// +kubebuilder:rbac:groups=events.k8s.io,resources=events,verbs=create;patch

// Reconcile handles DebugSession state transitions
func (c *DebugSessionController) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov0" title="0">{
        log := c.log.With("debugSession", req.NamespacedName)

        ds := &amp;v1alpha1.DebugSession{}
        if err := c.client.Get(ctx, req.NamespacedName, ds); err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        log.Debug("DebugSession not found, ignoring")
                        return ctrl.Result{}, nil
                }</span>
                <span class="cov0" title="0">log.Errorw("Failed to get DebugSession", "error", err)
                return ctrl.Result{}, err</span>
        }

        // Perform structural validation using shared validation function.
        // This catches malformed resources that somehow bypassed the admission webhook.
        <span class="cov0" title="0">validationResult := v1alpha1.ValidateDebugSession(ds)
        if !validationResult.IsValid() </span><span class="cov0" title="0">{
                log.Warnw("DebugSession failed structural validation, skipping reconciliation",
                        "errors", validationResult.ErrorMessage())

                // Update status condition to reflect validation failure
                ds.Status.State = v1alpha1.DebugSessionStateFailed
                ds.Status.Message = fmt.Sprintf("Validation failed: %s", validationResult.ErrorMessage())
                if statusErr := applyDebugSessionStatus(ctx, c.client, ds); statusErr != nil </span><span class="cov0" title="0">{
                        log.Errorw("Failed to update DebugSession status after validation failure", "error", statusErr)
                }</span>

                // Return nil error to skip requeue - malformed resource won't fix itself
                <span class="cov0" title="0">return ctrl.Result{}, nil</span>
        }

        <span class="cov0" title="0">log = log.With("state", ds.Status.State, "cluster", ds.Spec.Cluster)

        switch ds.Status.State </span>{
        case "", v1alpha1.DebugSessionStatePending:<span class="cov0" title="0">
                return c.handlePending(ctx, ds)</span>
        case v1alpha1.DebugSessionStatePendingApproval:<span class="cov0" title="0">
                return c.handlePendingApproval(ctx, ds)</span>
        case v1alpha1.DebugSessionStateActive:<span class="cov0" title="0">
                return c.handleActive(ctx, ds)</span>
        case v1alpha1.DebugSessionStateExpired, v1alpha1.DebugSessionStateTerminated:<span class="cov0" title="0">
                return c.handleCleanup(ctx, ds)</span>
        case v1alpha1.DebugSessionStateFailed:<span class="cov0" title="0">
                // Terminal state, no action needed
                return ctrl.Result{}, nil</span>
        default:<span class="cov0" title="0">
                log.Warnw("Unknown debug session state", "state", ds.Status.State)
                return ctrl.Result{}, nil</span>
        }
}

// handlePending processes a newly created debug session
func (c *DebugSessionController) handlePending(ctx context.Context, ds *v1alpha1.DebugSession) (ctrl.Result, error) <span class="cov0" title="0">{
        log := c.log.With("debugSession", ds.Name, "namespace", ds.Namespace)

        // Resolve the template
        template, err := c.getTemplate(ctx, ds.Spec.TemplateRef)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorw("Failed to get DebugSessionTemplate", "template", ds.Spec.TemplateRef, "error", err)
                return c.failSession(ctx, ds, fmt.Sprintf("template not found: %s", ds.Spec.TemplateRef))
        }</span>

        // Cache the resolved template in status
        <span class="cov0" title="0">ds.Status.ResolvedTemplate = &amp;template.Spec

        // Find binding early so we can check its approvers for the approval decision
        // This ensures bindings with approvers properly trigger approval workflow
        var binding *v1alpha1.DebugSessionClusterBinding
        if ds.Spec.BindingRef != nil </span><span class="cov0" title="0">{
                binding, err = c.getBinding(ctx, ds.Spec.BindingRef.Name, ds.Spec.BindingRef.Namespace)
                if err != nil </span><span class="cov0" title="0">{
                        log.Warnw("Failed to get binding by ref, will try auto-discovery",
                                "binding", ds.Spec.BindingRef.Name,
                                "namespace", ds.Spec.BindingRef.Namespace,
                                "error", err)
                }</span>
        }
        <span class="cov0" title="0">if binding == nil </span><span class="cov0" title="0">{
                binding, _ = c.findBindingForSession(ctx, template, ds.Spec.Cluster)
                if binding != nil </span><span class="cov0" title="0">{
                        log.Infow("Auto-discovered binding for session",
                                "binding", binding.Name,
                                "namespace", binding.Namespace)
                }</span>
        }

        // Check if approval is required (checks both template and binding approvers)
        <span class="cov0" title="0">requiresApproval := c.requiresApproval(template, binding, ds)
        ds.Status.Approval = &amp;v1alpha1.DebugSessionApproval{
                Required: requiresApproval,
        }

        if requiresApproval </span><span class="cov0" title="0">{
                ds.Status.State = v1alpha1.DebugSessionStatePendingApproval
                ds.Status.Message = "Waiting for approval"
                if err := applyDebugSessionStatus(ctx, c.client, ds); err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>
                <span class="cov0" title="0">metrics.DebugSessionsCreated.WithLabelValues(ds.Spec.Cluster, ds.Spec.TemplateRef).Inc()
                return ctrl.Result{RequeueAfter: DefaultDebugSessionRequeue}, nil</span>
        }

        // Auto-approved, transition to active
        <span class="cov0" title="0">return c.activateSession(ctx, ds, template, binding)</span>
}

// handlePendingApproval checks for approval status
func (c *DebugSessionController) handlePendingApproval(ctx context.Context, ds *v1alpha1.DebugSession) (ctrl.Result, error) <span class="cov0" title="0">{
        // If approved, activate
        if ds.Status.Approval != nil &amp;&amp; ds.Status.Approval.ApprovedAt != nil </span><span class="cov0" title="0">{
                template, err := c.getTemplate(ctx, ds.Spec.TemplateRef)
                if err != nil </span><span class="cov0" title="0">{
                        return c.failSession(ctx, ds, fmt.Sprintf("template not found: %s", ds.Spec.TemplateRef))
                }</span>
                // Find binding for merging allowed pod operations
                <span class="cov0" title="0">var binding *v1alpha1.DebugSessionClusterBinding
                if ds.Spec.BindingRef != nil </span><span class="cov0" title="0">{
                        binding, _ = c.getBinding(ctx, ds.Spec.BindingRef.Name, ds.Spec.BindingRef.Namespace)
                }</span>
                <span class="cov0" title="0">if binding == nil </span><span class="cov0" title="0">{
                        binding, _ = c.findBindingForSession(ctx, template, ds.Spec.Cluster)
                }</span>
                <span class="cov0" title="0">return c.activateSession(ctx, ds, template, binding)</span>
        }

        // If rejected, mark as terminated
        <span class="cov0" title="0">if ds.Status.Approval != nil &amp;&amp; ds.Status.Approval.RejectedAt != nil </span><span class="cov0" title="0">{
                ds.Status.State = v1alpha1.DebugSessionStateTerminated
                ds.Status.Message = fmt.Sprintf("Rejected by %s: %s", ds.Status.Approval.RejectedBy, ds.Status.Approval.Reason)
                return ctrl.Result{}, applyDebugSessionStatus(ctx, c.client, ds)
        }</span>

        // Still waiting for approval
        <span class="cov0" title="0">return ctrl.Result{RequeueAfter: DefaultDebugSessionRequeue}, nil</span>
}

// handleActive manages an active debug session
func (c *DebugSessionController) handleActive(ctx context.Context, ds *v1alpha1.DebugSession) (ctrl.Result, error) <span class="cov0" title="0">{
        log := c.log.With("debugSession", ds.Name, "namespace", ds.Namespace)

        // Emit expiring-soon status message when within grace period
        if ds.Status.ExpiresAt != nil &amp;&amp; ds.Status.ResolvedTemplate != nil &amp;&amp; ds.Status.ResolvedTemplate.GracePeriodBeforeExpiry != "" </span><span class="cov0" title="0">{
                grace, err := time.ParseDuration(ds.Status.ResolvedTemplate.GracePeriodBeforeExpiry)
                if err == nil </span><span class="cov0" title="0">{
                        until := time.Until(ds.Status.ExpiresAt.Time)
                        if until &gt; 0 &amp;&amp; until &lt;= grace &amp;&amp; ds.Status.Message != "Session expiring soon" </span><span class="cov0" title="0">{
                                ds.Status.Message = "Session expiring soon"
                                if err := applyDebugSessionStatus(ctx, c.client, ds); err != nil </span><span class="cov0" title="0">{
                                        return ctrl.Result{}, err
                                }</span>
                        }
                }
        }

        // Check expiration
        <span class="cov0" title="0">if ds.Status.ExpiresAt != nil &amp;&amp; time.Now().After(ds.Status.ExpiresAt.Time) </span><span class="cov0" title="0">{
                log.Info("Debug session expired")
                if ds.Status.ResolvedTemplate != nil &amp;&amp; ds.Status.ResolvedTemplate.ExpirationBehavior == "notify-only" </span><span class="cov0" title="0">{
                        ds.Status.Message = "Session expired (notify-only)"
                        ds.Status.ExpiresAt = nil
                        if err := applyDebugSessionStatus(ctx, c.client, ds); err != nil </span><span class="cov0" title="0">{
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
                }
                <span class="cov0" title="0">ds.Status.State = v1alpha1.DebugSessionStateExpired
                ds.Status.Message = "Session expired"
                if err := applyDebugSessionStatus(ctx, c.client, ds); err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>
                <span class="cov0" title="0">metrics.DebugSessionsActive.WithLabelValues(ds.Spec.Cluster, ds.Spec.TemplateRef).Dec()
                return ctrl.Result{RequeueAfter: ExpiredSessionRequeue}, nil</span>
        }

        // Update allowed pods list from deployed workloads
        <span class="cov0" title="0">if err := c.updateAllowedPods(ctx, ds); err != nil </span><span class="cov0" title="0">{
                log.Warnw("Failed to update allowed pods", "error", err)
        }</span>

        // Calculate next requeue based on expiration
        <span class="cov0" title="0">if ds.Status.ExpiresAt != nil </span><span class="cov0" title="0">{
                until := time.Until(ds.Status.ExpiresAt.Time)
                if until &gt; 0 &amp;&amp; until &lt; DefaultDebugSessionRequeue </span><span class="cov0" title="0">{
                        return ctrl.Result{RequeueAfter: until + time.Second}, nil
                }</span>
        }

        <span class="cov0" title="0">return ctrl.Result{RequeueAfter: DefaultDebugSessionRequeue}, nil</span>
}

// handleCleanup removes deployed resources for expired/terminated sessions
func (c *DebugSessionController) handleCleanup(ctx context.Context, ds *v1alpha1.DebugSession) (ctrl.Result, error) <span class="cov0" title="0">{
        log := c.log.With("debugSession", ds.Name, "namespace", ds.Namespace)

        if err := c.cleanupResources(ctx, ds); err != nil </span><span class="cov0" title="0">{
                log.Errorw("Failed to cleanup debug session resources", "error", err)
                // Requeue to retry cleanup
                return ctrl.Result{RequeueAfter: ExpiredSessionRequeue}, nil
        }</span>

        // Record metrics
        <span class="cov0" title="0">if ds.Status.StartsAt != nil </span><span class="cov0" title="0">{
                duration := time.Since(ds.Status.StartsAt.Time).Seconds()
                metrics.DebugSessionDuration.WithLabelValues(ds.Spec.Cluster, ds.Spec.TemplateRef).Observe(duration)
        }</span>

        // Update template status to decrement active session count
        <span class="cov0" title="0">if ds.Spec.TemplateRef != "" </span><span class="cov0" title="0">{
                template, err := c.getTemplate(ctx, ds.Spec.TemplateRef)
                if err == nil </span><span class="cov0" title="0">{
                        if err := c.updateTemplateStatus(ctx, template, false); err != nil </span><span class="cov0" title="0">{
                                log.Warnw("Failed to update template status during cleanup", "template", ds.Spec.TemplateRef, "error", err)
                                // Non-fatal: cleanup still succeeds
                        }</span>
                }
        }

        <span class="cov0" title="0">log.Info("Debug session cleanup complete")
        return ctrl.Result{}, nil</span>
}

// activateSession deploys debug resources and marks session as active
func (c *DebugSessionController) activateSession(ctx context.Context, ds *v1alpha1.DebugSession, template *v1alpha1.DebugSessionTemplate, binding *v1alpha1.DebugSessionClusterBinding) (ctrl.Result, error) <span class="cov0" title="0">{
        log := c.log.With("debugSession", ds.Name, "namespace", ds.Namespace)

        // Only deploy workloads for workload or hybrid mode
        mode := template.Spec.Mode
        if mode == "" </span><span class="cov0" title="0">{
                mode = v1alpha1.DebugSessionModeWorkload
        }</span>

        <span class="cov0" title="0">if mode == v1alpha1.DebugSessionModeWorkload || mode == v1alpha1.DebugSessionModeHybrid </span><span class="cov0" title="0">{
                if err := c.deployDebugResources(ctx, ds, template); err != nil </span><span class="cov0" title="0">{
                        log.Errorw("Failed to deploy debug resources", "error", err)
                        return c.failSession(ctx, ds, fmt.Sprintf("failed to deploy resources: %v", err))
                }</span>
        }

        // Calculate expiration
        <span class="cov0" title="0">duration := c.parseDuration(ds.Spec.RequestedDuration, template.Spec.Constraints)
        now := metav1.Now()
        expiresAt := metav1.NewTime(now.Add(duration))

        ds.Status.State = v1alpha1.DebugSessionStateActive
        ds.Status.StartsAt = &amp;now
        ds.Status.ExpiresAt = &amp;expiresAt
        ds.Status.Message = "Debug session active"

        // Cache AllowedPodOperations merged from template and binding for webhook enforcement
        // Binding can only be more restrictive than template
        var bindingOps *v1alpha1.AllowedPodOperations
        if binding != nil </span><span class="cov0" title="0">{
                bindingOps = binding.Spec.AllowedPodOperations
        }</span>
        <span class="cov0" title="0">ds.Status.AllowedPodOperations = v1alpha1.MergeAllowedPodOperations(template.Spec.AllowedPodOperations, bindingOps)

        // Add the requesting user as owner participant
        ds.Status.Participants = []v1alpha1.DebugSessionParticipant{{
                User:        ds.Spec.RequestedBy,
                Email:       ds.Spec.RequestedByEmail,
                DisplayName: ds.Spec.RequestedByDisplayName,
                Role:        v1alpha1.ParticipantRoleOwner,
                JoinedAt:    now,
        }}

        // Setup terminal sharing if enabled
        if template.Spec.TerminalSharing != nil &amp;&amp; template.Spec.TerminalSharing.Enabled </span><span class="cov0" title="0">{
                ds.Status.TerminalSharing = c.setupTerminalSharing(ds, template)
        }</span>

        <span class="cov0" title="0">if err := applyDebugSessionStatus(ctx, c.client, ds); err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">metrics.DebugSessionsCreated.WithLabelValues(ds.Spec.Cluster, ds.Spec.TemplateRef).Inc()
        metrics.DebugSessionsActive.WithLabelValues(ds.Spec.Cluster, ds.Spec.TemplateRef).Inc()

        // Update template status to reflect active session
        if err := c.updateTemplateStatus(ctx, template, true); err != nil </span><span class="cov0" title="0">{
                log.Warnw("Failed to update template status", "template", template.Name, "error", err)
                // Non-fatal: session activation still succeeds
        }</span>

        <span class="cov0" title="0">log.Infow("Debug session activated",
                "expiresAt", expiresAt.Time,
                "duration", duration.String(),
                "mode", mode,
                "terminalSharing", ds.Status.TerminalSharing != nil)

        return ctrl.Result{RequeueAfter: DefaultDebugSessionRequeue}, nil</span>
}

// failSession marks a session as failed and logs the failure
func (c *DebugSessionController) failSession(ctx context.Context, ds *v1alpha1.DebugSession, reason string) (ctrl.Result, error) <span class="cov0" title="0">{
        log := c.log.With("debugSession", ds.Name, "namespace", ds.Namespace, "cluster", ds.Spec.Cluster)

        // Best-effort cleanup of any partially deployed resources on the target cluster.
        // Short-circuit if the session never deployed anything to avoid noisy cross-cluster calls.
        hasDeployedResources := len(ds.Status.DeployedResources) &gt; 0 ||
                len(ds.Status.AuxiliaryResourceStatuses) &gt; 0 ||
                len(ds.Status.PodTemplateResourceStatuses) &gt; 0 ||
                len(ds.Status.AllowedPods) &gt; 0
        if hasDeployedResources </span><span class="cov0" title="0">{
                if cleanupErr := c.cleanupResources(ctx, ds); cleanupErr != nil </span><span class="cov0" title="0">{
                        log.Warnw("Best-effort cleanup of partially deployed resources failed during session failure",
                                "cleanupError", cleanupErr)
                }</span>
        }

        // Log the failure with full context
        <span class="cov0" title="0">log.Errorw("Debug session failed",
                "reason", reason,
                "template", ds.Spec.TemplateRef,
                "requestedBy", ds.Spec.RequestedBy,
                "previousState", ds.Status.State,
        )

        // Emit audit event if audit is enabled for this session
        if c.shouldEmitAudit(ds) &amp;&amp; c.auditManager != nil </span><span class="cov0" title="0">{
                c.auditManager.DebugSessionFailed(ctx, ds.Name, ds.Namespace, ds.Spec.Cluster, reason, map[string]interface{}{
                        "template":       ds.Spec.TemplateRef,
                        "requested_by":   ds.Spec.RequestedBy,
                        "previous_state": string(ds.Status.State),
                })
                // Send to webhook destinations if configured
                c.sendToWebhookDestinations(ctx, ds, "DebugSessionFailed", map[string]interface{}{
                        "session":   ds.Name,
                        "namespace": ds.Namespace,
                        "cluster":   ds.Spec.Cluster,
                        "reason":    reason,
                })
        }</span>

        <span class="cov0" title="0">ds.Status.State = v1alpha1.DebugSessionStateFailed
        ds.Status.Message = reason

        // Send failure notification email to requester
        c.sendDebugSessionFailedEmail(ds, reason)

        // Increment failure metric
        metrics.DebugSessionsFailed.WithLabelValues(ds.Spec.Cluster, ds.Spec.TemplateRef).Inc()

        return ctrl.Result{}, applyDebugSessionStatus(ctx, c.client, ds)</span>
}

// sendDebugSessionFailedEmail sends email notification to requester when a debug session fails
func (c *DebugSessionController) sendDebugSessionFailedEmail(ds *v1alpha1.DebugSession, reason string) <span class="cov0" title="0">{
        if c.disableEmail || c.mailService == nil || !c.mailService.IsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">recipients := []string{ds.Spec.RequestedBy}

        params := mail.DebugSessionFailedMailParams{
                RequesterName:  ds.Spec.RequestedBy,
                RequesterEmail: ds.Spec.RequestedBy,
                SessionID:      ds.Name,
                Cluster:        ds.Spec.Cluster,
                TemplateName:   ds.Spec.TemplateRef,
                Namespace:      ds.Namespace,
                FailedAt:       time.Now().Format(time.RFC3339),
                FailureReason:  reason,
                URL:            fmt.Sprintf("%s/debug-sessions", c.baseURL),
                BrandingName:   c.brandingName,
        }

        body, err := mail.RenderDebugSessionFailed(params)
        if err != nil </span><span class="cov0" title="0">{
                c.log.Errorw("Failed to render debug session failed email", "session", ds.Name, "error", err)
                return
        }</span>

        <span class="cov0" title="0">subject := fmt.Sprintf("[%s] Debug Session Failed: %s", c.brandingName, ds.Name)
        if err := c.mailService.Enqueue(ds.Name, recipients, subject, body); err != nil </span><span class="cov0" title="0">{
                c.log.Errorw("Failed to enqueue debug session failed email", "session", ds.Name, "error", err)
        }</span> else<span class="cov0" title="0"> {
                c.log.Infow("Debug session failed email queued", "session", ds.Name, "requester", ds.Spec.RequestedBy)
        }</span>
}

// shouldEmitAudit checks if audit events should be emitted for this session
// based on the template's audit configuration.
func (c *DebugSessionController) shouldEmitAudit(ds *v1alpha1.DebugSession) bool <span class="cov0" title="0">{
        if ds.Status.ResolvedTemplate == nil </span><span class="cov0" title="0">{
                return true // Default to emit audit if no template resolved yet
        }</span>
        <span class="cov0" title="0">if ds.Status.ResolvedTemplate.Audit == nil </span><span class="cov0" title="0">{
                return true // Default to enabled if not configured
        }</span>
        <span class="cov0" title="0">return ds.Status.ResolvedTemplate.Audit.Enabled</span>
}

// sendToWebhookDestinations sends audit events to configured webhook destinations
// from the debug session template's audit config.
func (c *DebugSessionController) sendToWebhookDestinations(ctx context.Context, ds *v1alpha1.DebugSession, eventType string, payload map[string]interface{}) <span class="cov0" title="0">{
        if ds.Status.ResolvedTemplate == nil || ds.Status.ResolvedTemplate.Audit == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for _, dest := range ds.Status.ResolvedTemplate.Audit.Destinations </span><span class="cov0" title="0">{
                if dest.Type != "webhook" || dest.URL == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">go func(destination v1alpha1.AuditDestination) </span><span class="cov0" title="0">{
                        if err := c.sendWebhookEvent(ctx, destination, eventType, ds, payload); err != nil </span><span class="cov0" title="0">{
                                c.log.Warnw("Failed to send audit event to webhook destination",
                                        "url", destination.URL,
                                        "eventType", eventType,
                                        "session", ds.Name,
                                        "error", err)
                        }</span>
                }(dest)
        }
}

// sendWebhookEvent sends an audit event to a webhook destination.
func (c *DebugSessionController) sendWebhookEvent(ctx context.Context, dest v1alpha1.AuditDestination, eventType string, ds *v1alpha1.DebugSession, payload map[string]interface{}) error <span class="cov0" title="0">{
        // Build the full payload
        fullPayload := map[string]interface{}{
                "eventType": eventType,
                "timestamp": time.Now().UTC().Format(time.RFC3339),
                "session": map[string]interface{}{
                        "name":        ds.Name,
                        "namespace":   ds.Namespace,
                        "cluster":     ds.Spec.Cluster,
                        "templateRef": ds.Spec.TemplateRef,
                        "requestedBy": ds.Spec.RequestedBy,
                        "state":       string(ds.Status.State),
                },
                "details": payload,
        }

        jsonData, err := json.Marshal(fullPayload)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal payload: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, http.MethodPost, dest.URL, bytes.NewReader(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        for k, v := range dest.Headers </span><span class="cov0" title="0">{
                req.Header.Set(k, v)
        }</span>

        <span class="cov0" title="0">client := &amp;http.Client{Timeout: 10 * time.Second}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        <span class="cov0" title="0">if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                return fmt.Errorf("webhook returned status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// getTemplate retrieves a DebugSessionTemplate by name
func (c *DebugSessionController) getTemplate(ctx context.Context, name string) (*v1alpha1.DebugSessionTemplate, error) <span class="cov0" title="0">{
        template := &amp;v1alpha1.DebugSessionTemplate{}
        if err := c.client.Get(ctx, ctrlclient.ObjectKey{Name: name}, template); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return template, nil</span>
}

// getPodTemplate retrieves a DebugPodTemplate by name
func (c *DebugSessionController) getPodTemplate(ctx context.Context, name string) (*v1alpha1.DebugPodTemplate, error) <span class="cov0" title="0">{
        template := &amp;v1alpha1.DebugPodTemplate{}
        if err := c.client.Get(ctx, ctrlclient.ObjectKey{Name: name}, template); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return template, nil</span>
}

// getBinding retrieves a DebugSessionClusterBinding by name and namespace
func (c *DebugSessionController) getBinding(ctx context.Context, name, namespace string) (*v1alpha1.DebugSessionClusterBinding, error) <span class="cov0" title="0">{
        binding := &amp;v1alpha1.DebugSessionClusterBinding{}
        if err := c.client.Get(ctx, ctrlclient.ObjectKey{Name: name, Namespace: namespace}, binding); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return binding, nil</span>
}

// findBindingForSession finds a DebugSessionClusterBinding that matches the session's template and cluster.
// This enables binding configuration to be applied even when BindingRef is not explicitly set.
// Returns nil if no matching binding is found.
func (c *DebugSessionController) findBindingForSession(ctx context.Context, template *v1alpha1.DebugSessionTemplate, clusterName string) (*v1alpha1.DebugSessionClusterBinding, error) <span class="cov0" title="0">{
        bindingList := &amp;v1alpha1.DebugSessionClusterBindingList{}
        if err := c.client.List(ctx, bindingList); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list cluster bindings: %w", err)
        }</span>

        // Get cluster config for label-based matching
        <span class="cov0" title="0">var clusterConfig *v1alpha1.ClusterConfig
        clusterConfigList := &amp;v1alpha1.ClusterConfigList{}
        if err := c.client.List(ctx, clusterConfigList); err == nil </span><span class="cov0" title="0">{
                for i := range clusterConfigList.Items </span><span class="cov0" title="0">{
                        if clusterConfigList.Items[i].Name == clusterName </span><span class="cov0" title="0">{
                                clusterConfig = &amp;clusterConfigList.Items[i]
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">for i := range bindingList.Items </span><span class="cov0" title="0">{
                binding := &amp;bindingList.Items[i]
                if !IsBindingActive(binding) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if binding references this template
                <span class="cov0" title="0">if !c.bindingMatchesTemplate(binding, template) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if binding matches this cluster
                <span class="cov0" title="0">if !c.bindingMatchesCluster(binding, clusterName, clusterConfig) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Found a matching binding
                <span class="cov0" title="0">return binding, nil</span>
        }

        <span class="cov0" title="0">return nil, nil</span> // No matching binding found (not an error)
}

// bindingMatchesTemplate checks if a binding references the given template
func (c *DebugSessionController) bindingMatchesTemplate(binding *v1alpha1.DebugSessionClusterBinding, template *v1alpha1.DebugSessionTemplate) bool <span class="cov0" title="0">{
        // Check templateRef
        if binding.Spec.TemplateRef != nil &amp;&amp; binding.Spec.TemplateRef.Name == template.Name </span><span class="cov0" title="0">{
                return true
        }</span>
        // Check templateSelector
        <span class="cov0" title="0">if binding.Spec.TemplateSelector != nil </span><span class="cov0" title="0">{
                selector, err := metav1.LabelSelectorAsSelector(binding.Spec.TemplateSelector)
                if err == nil </span><span class="cov0" title="0">{
                        templateLabels := labels.Set(template.Labels)
                        if selector.Matches(templateLabels) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

// bindingMatchesCluster checks if a binding applies to the given cluster
func (c *DebugSessionController) bindingMatchesCluster(binding *v1alpha1.DebugSessionClusterBinding, clusterName string, clusterConfig *v1alpha1.ClusterConfig) bool <span class="cov0" title="0">{
        // Check explicit cluster list
        for _, cluster := range binding.Spec.Clusters </span><span class="cov0" title="0">{
                if cluster == clusterName </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        // Check clusterSelector
        <span class="cov0" title="0">if binding.Spec.ClusterSelector != nil &amp;&amp; clusterConfig != nil </span><span class="cov0" title="0">{
                selector, err := metav1.LabelSelectorAsSelector(binding.Spec.ClusterSelector)
                if err == nil </span><span class="cov0" title="0">{
                        clusterLabels := labels.Set(clusterConfig.Labels)
                        if selector.Matches(clusterLabels) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">return false</span>
}

// resolveImpersonationConfig determines the impersonation configuration for a session.
// Binding impersonation overrides template impersonation.
func (c *DebugSessionController) resolveImpersonationConfig(
        template *v1alpha1.DebugSessionTemplate,
        binding *v1alpha1.DebugSessionClusterBinding,
) *v1alpha1.ImpersonationConfig <span class="cov0" title="0">{
        // Binding takes precedence
        if binding != nil &amp;&amp; binding.Spec.Impersonation != nil </span><span class="cov0" title="0">{
                return binding.Spec.Impersonation
        }</span>
        // Fall back to template
        <span class="cov0" title="0">if template != nil &amp;&amp; template.Spec.Impersonation != nil </span><span class="cov0" title="0">{
                return template.Spec.Impersonation
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// createImpersonatedClient creates a spoke cluster client that impersonates the specified ServiceAccount.
// The SA is expected to exist in the spoke cluster, not the hub.
func (c *DebugSessionController) createImpersonatedClient(
        ctx context.Context,
        clusterName string,
        impConfig *v1alpha1.ImpersonationConfig,
) (ctrlclient.Client, error) <span class="cov0" title="0">{
        // Get base REST config for spoke cluster
        restCfg, err := c.ccProvider.GetRESTConfig(ctx, clusterName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get REST config for cluster %s: %w", clusterName, err)
        }</span>

        // If impersonation is configured, set up impersonation
        <span class="cov0" title="0">if impConfig != nil &amp;&amp; impConfig.ServiceAccountRef != nil </span><span class="cov0" title="0">{
                // Impersonate the spoke cluster's ServiceAccount
                // Format: system:serviceaccount:&lt;namespace&gt;:&lt;name&gt;
                restCfg.Impersonate = rest.ImpersonationConfig{
                        UserName: fmt.Sprintf("system:serviceaccount:%s:%s",
                                impConfig.ServiceAccountRef.Namespace,
                                impConfig.ServiceAccountRef.Name),
                }
        }</span>

        <span class="cov0" title="0">client, err := ctrlclient.New(restCfg, ctrlclient.Options{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create client for cluster %s: %w", clusterName, err)
        }</span>
        <span class="cov0" title="0">return client, nil</span>
}

// validateSpokeServiceAccount checks if the ServiceAccount exists in the spoke cluster.
// This is a runtime validation that cannot happen at webhook time.
func (c *DebugSessionController) validateSpokeServiceAccount(
        ctx context.Context,
        spokeClient ctrlclient.Client,
        saRef *v1alpha1.ServiceAccountReference,
) error <span class="cov0" title="0">{
        sa := &amp;corev1.ServiceAccount{}
        err := spokeClient.Get(ctx, ctrlclient.ObjectKey{
                Name:      saRef.Name,
                Namespace: saRef.Namespace,
        }, sa)
        if err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("impersonation ServiceAccount %s/%s not found in spoke cluster",
                                saRef.Namespace, saRef.Name)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to validate impersonation ServiceAccount: %w", err)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// requiresApproval checks if the session requires approval.
// It checks both the template and the binding for approvers configuration.
// Approval is required if either the template or binding specifies approvers
// (unless auto-approve conditions are met).
func (c *DebugSessionController) requiresApproval(template *v1alpha1.DebugSessionTemplate, binding *v1alpha1.DebugSessionClusterBinding, ds *v1alpha1.DebugSession) bool <span class="cov0" title="0">{
        // Check if binding has approvers configured (takes precedence)
        if binding != nil &amp;&amp; binding.Spec.Approvers != nil </span><span class="cov0" title="0">{
                if len(binding.Spec.Approvers.Users) &gt; 0 || len(binding.Spec.Approvers.Groups) &gt; 0 </span><span class="cov0" title="0">{
                        c.log.Infow("Approval required by binding",
                                "session", ds.Name,
                                "binding", binding.Name,
                                "bindingNamespace", binding.Namespace)
                        // Check binding auto-approve conditions
                        if binding.Spec.Approvers.AutoApproveFor != nil </span><span class="cov0" title="0">{
                                if c.checkAutoApprove(binding.Spec.Approvers.AutoApproveFor, ds) </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                        }
                        <span class="cov0" title="0">return true</span>
                }
        }

        // Check if template has approvers configured
        <span class="cov0" title="0">if template.Spec.Approvers == nil </span><span class="cov0" title="0">{
                return false // No approvers configured = auto-approve
        }</span>

        // Check if template has actual approvers (not just auto-approve rules)
        <span class="cov0" title="0">if len(template.Spec.Approvers.Users) == 0 &amp;&amp; len(template.Spec.Approvers.Groups) == 0 </span><span class="cov0" title="0">{
                return false // No actual approvers configured
        }</span>

        // Check template auto-approve conditions
        <span class="cov0" title="0">if template.Spec.Approvers.AutoApproveFor != nil </span><span class="cov0" title="0">{
                if c.checkAutoApprove(template.Spec.Approvers.AutoApproveFor, ds) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// checkAutoApprove checks if auto-approve conditions are met for the session
func (c *DebugSessionController) checkAutoApprove(autoApprove *v1alpha1.AutoApproveConfig, ds *v1alpha1.DebugSession) bool <span class="cov0" title="0">{
        // Auto-approve for specific clusters
        for _, pattern := range autoApprove.Clusters </span><span class="cov0" title="0">{
                if matched, _ := filepath.Match(pattern, ds.Spec.Cluster); matched </span><span class="cov0" title="0">{
                        c.log.Infow("Auto-approving debug session based on cluster match",
                                "session", ds.Name,
                                "cluster", ds.Spec.Cluster,
                                "pattern", pattern)
                        return true
                }</span>
        }

        // Auto-approve for specific groups
        <span class="cov0" title="0">if len(autoApprove.Groups) &gt; 0 &amp;&amp; len(ds.Spec.UserGroups) &gt; 0 </span><span class="cov0" title="0">{
                for _, autoApproveGroup := range autoApprove.Groups </span><span class="cov0" title="0">{
                        for _, userGroup := range ds.Spec.UserGroups </span><span class="cov0" title="0">{
                                if userGroup == autoApproveGroup </span><span class="cov0" title="0">{
                                        c.log.Infow("Auto-approving debug session based on group match",
                                                "session", ds.Name,
                                                "user", ds.Spec.RequestedBy,
                                                "matchedGroup", userGroup)
                                        return true
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return false</span>
}

// deployDebugResources creates the debug workload on the target cluster
func (c *DebugSessionController) deployDebugResources(ctx context.Context, ds *v1alpha1.DebugSession, template *v1alpha1.DebugSessionTemplate) error <span class="cov0" title="0">{
        log := c.log.With("debugSession", ds.Name, "cluster", ds.Spec.Cluster)

        // Get pod template if referenced
        var podTemplate *v1alpha1.DebugPodTemplate
        if template.Spec.PodTemplateRef != nil </span><span class="cov0" title="0">{
                var err error
                podTemplate, err = c.getPodTemplate(ctx, template.Spec.PodTemplateRef.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get pod template: %w", err)
                }</span>
        }

        // Get binding if session was created via a binding
        <span class="cov0" title="0">var binding *v1alpha1.DebugSessionClusterBinding
        if ds.Spec.BindingRef != nil </span><span class="cov0" title="0">{
                var err error
                binding, err = c.getBinding(ctx, ds.Spec.BindingRef.Name, ds.Spec.BindingRef.Namespace)
                if err != nil </span><span class="cov0" title="0">{
                        log.Warnw("Failed to get binding by ref, will try auto-discovery",
                                "binding", ds.Spec.BindingRef.Name,
                                "namespace", ds.Spec.BindingRef.Namespace,
                                "error", err)
                        // Non-fatal: try auto-discovery below
                }</span>
        }

        // Auto-discover binding if not found via BindingRef
        // This enables binding configuration to apply even when sessions are created
        // without explicitly setting BindingRef (e.g., via the unified API)
        <span class="cov0" title="0">if binding == nil </span><span class="cov0" title="0">{
                discoveredBinding, err := c.findBindingForSession(ctx, template, ds.Spec.Cluster)
                if err != nil </span><span class="cov0" title="0">{
                        log.Warnw("Failed to auto-discover binding, continuing without binding config",
                                "error", err)
                }</span> else<span class="cov0" title="0"> if discoveredBinding != nil </span><span class="cov0" title="0">{
                        log.Infow("Auto-discovered binding for session",
                                "binding", discoveredBinding.Name,
                                "namespace", discoveredBinding.Namespace)
                        binding = discoveredBinding
                }</span>
        }

        // Cache resolved binding info in session status for observability
        <span class="cov0" title="0">if binding != nil </span><span class="cov0" title="0">{
                displayName := v1alpha1.GetEffectiveDisplayName(binding, template.Spec.DisplayName, template.Name)
                ds.Status.ResolvedBinding = &amp;v1alpha1.ResolvedBindingRef{
                        Name:        binding.Name,
                        Namespace:   binding.Namespace,
                        DisplayName: displayName,
                }
        }</span>

        // Resolve impersonation configuration (binding overrides template)
        <span class="cov0" title="0">impConfig := c.resolveImpersonationConfig(template, binding)

        // Get target cluster client (with or without impersonation)
        var targetClient ctrlclient.Client
        var err error

        // First, resolve the target namespace (needed for per-session SA creation)
        targetNs := ds.Spec.TargetNamespace
        if targetNs == "" </span><span class="cov0" title="0">{
                targetNs = template.Spec.TargetNamespace
        }</span>
        <span class="cov0" title="0">if targetNs == "" </span><span class="cov0" title="0">{
                // Check namespaceConstraints for default
                if template.Spec.NamespaceConstraints != nil &amp;&amp; template.Spec.NamespaceConstraints.DefaultNamespace != "" </span><span class="cov0" title="0">{
                        targetNs = template.Spec.NamespaceConstraints.DefaultNamespace
                }</span>
        }
        <span class="cov0" title="0">if targetNs == "" </span><span class="cov0" title="0">{
                targetNs = "breakglass-debug"
        }</span>

        // Create base client for spoke cluster (no impersonation yet)
        <span class="cov0" title="0">baseRestCfg, restErr := c.ccProvider.GetRESTConfig(ctx, ds.Spec.Cluster)
        if restErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get REST config for cluster %s: %w", ds.Spec.Cluster, restErr)
        }</span>
        <span class="cov0" title="0">baseClient, baseErr := ctrlclient.New(baseRestCfg, ctrlclient.Options{})
        if baseErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create base client for cluster %s: %w", ds.Spec.Cluster, baseErr)
        }</span>

        // Handle impersonation configuration
        <span class="cov0" title="0">if impConfig != nil &amp;&amp; impConfig.ServiceAccountRef != nil </span><span class="cov0" title="0">{
                // Use existing ServiceAccount - validate it exists
                if err := c.validateSpokeServiceAccount(ctx, baseClient, impConfig.ServiceAccountRef); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("impersonation validation failed: %w", err)
                }</span>

                // Create impersonated client
                <span class="cov0" title="0">targetClient, err = c.createImpersonatedClient(ctx, ds.Spec.Cluster, impConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create impersonated client: %w", err)
                }</span>

                <span class="cov0" title="0">log.Infow("Using impersonation for deployment",
                        "serviceAccount", fmt.Sprintf("%s/%s",
                                impConfig.ServiceAccountRef.Namespace,
                                impConfig.ServiceAccountRef.Name))</span>
        } else<span class="cov0" title="0"> {
                // No impersonation - use controller's own credentials
                targetClient = baseClient
        }</span>

        // Ensure target namespace exists
        <span class="cov0" title="0">ns := &amp;corev1.Namespace{}
        if err := targetClient.Get(ctx, ctrlclient.ObjectKey{Name: targetNs}, ns); err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        if template.Spec.FailMode == "open" </span><span class="cov0" title="0">{
                                log.Warnw("Target namespace does not exist, fail-open mode", "namespace", targetNs)
                                return nil
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("target namespace %s does not exist", targetNs)</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("failed to check namespace: %w", err)</span>
        }

        // Deploy ResourceQuota if configured
        <span class="cov0" title="0">if template.Spec.ResourceQuota != nil </span><span class="cov0" title="0">{
                rq, rqErr := c.buildResourceQuota(ds, template, binding, targetNs)
                if rqErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to build resource quota: %w", rqErr)
                }</span>
                <span class="cov0" title="0">if rq != nil </span><span class="cov0" title="0">{
                        gvk := rq.GetObjectKind().GroupVersionKind()
                        if err := utils.ApplyObject(ctx, targetClient, rq); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to apply resource quota: %w", err)
                        }</span>
                        <span class="cov0" title="0">log.Infow("ResourceQuota applied", "name", rq.Name)
                        ds.Status.DeployedResources = append(ds.Status.DeployedResources, v1alpha1.DeployedResourceRef{
                                APIVersion: gvk.GroupVersion().String(),
                                Kind:       gvk.Kind,
                                Name:       rq.Name,
                                Namespace:  rq.Namespace,
                                Source:     "debug-resourcequota",
                        })</span>
                }
        }

        // Deploy PodDisruptionBudget if configured
        <span class="cov0" title="0">if template.Spec.PodDisruptionBudget != nil &amp;&amp; template.Spec.PodDisruptionBudget.Enabled </span><span class="cov0" title="0">{
                pdb, pdbErr := c.buildPodDisruptionBudget(ds, template, binding, targetNs)
                if pdbErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to build pod disruption budget: %w", pdbErr)
                }</span>
                <span class="cov0" title="0">if pdb != nil </span><span class="cov0" title="0">{
                        gvk := pdb.GetObjectKind().GroupVersionKind()
                        if err := utils.ApplyObject(ctx, targetClient, pdb); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to apply pod disruption budget: %w", err)
                        }</span>
                        <span class="cov0" title="0">log.Infow("PodDisruptionBudget applied", "name", pdb.Name)
                        ds.Status.DeployedResources = append(ds.Status.DeployedResources, v1alpha1.DeployedResourceRef{
                                APIVersion: gvk.GroupVersion().String(),
                                Kind:       gvk.Kind,
                                Name:       pdb.Name,
                                Namespace:  pdb.Namespace,
                                Source:     "debug-pdb",
                        })</span>
                }
        }

        // Build and deploy workload
        <span class="cov0" title="0">workload, podTemplateResources, err := c.buildWorkload(ds, template, binding, podTemplate, targetNs)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to build workload: %w", err)
        }</span>

        // Deploy additional resources from multi-document pod templates BEFORE the workload
        // (e.g., PVCs, ConfigMaps, Secrets that the pod needs)
        <span class="cov0" title="0">if len(podTemplateResources) &gt; 0 </span><span class="cov0" title="0">{
                log.Infow("Deploying pod template resources",
                        "count", len(podTemplateResources),
                        "debugSession", ds.Name)
                for _, res := range podTemplateResources </span><span class="cov0" title="0">{
                        if err := c.deployPodTemplateResource(ctx, targetClient, ds, res, targetNs); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to deploy pod template resource %s/%s: %w", res.GetKind(), res.GetName(), err)
                        }</span>
                }
        }

        // Capture GVK before Apply call as Kubernetes client may clear TypeMeta
        <span class="cov0" title="0">gvk := workload.GetObjectKind().GroupVersionKind()

        if err := utils.ApplyObject(ctx, targetClient, workload); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to apply workload: %w", err)
        }</span>
        <span class="cov0" title="0">log.Infow("Debug workload applied", "name", workload.GetName())

        // Record deployed resource using captured GVK
        ds.Status.DeployedResources = append(ds.Status.DeployedResources, v1alpha1.DeployedResourceRef{
                APIVersion: gvk.GroupVersion().String(),
                Kind:       gvk.Kind,
                Name:       workload.GetName(),
                Namespace:  targetNs,
                Source:     "debug-pod",
        })

        log.Infow("Deployed debug workload",
                "name", workload.GetName(),
                "namespace", targetNs,
                "kind", gvk.Kind)

        // Deploy auxiliary resources if configured
        if c.auxiliaryMgr != nil &amp;&amp; len(template.Spec.AuxiliaryResources) &gt; 0 </span><span class="cov0" title="0">{
                auxStatuses, auxErr := c.auxiliaryMgr.DeployAuxiliaryResources(ctx, ds, &amp;template.Spec, binding, targetClient, targetNs)
                if auxErr != nil </span><span class="cov0" title="0">{
                        // Log but don't fail the session - auxiliary resources are optional
                        log.Warnw("Failed to deploy some auxiliary resources", "error", auxErr)
                }</span>
                // Add deployed auxiliary resources to status
                <span class="cov0" title="0">ds.Status.AuxiliaryResourceStatuses = auxStatuses</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// buildWorkload creates the DaemonSet or Deployment for debug pods.
// It also returns any additional resources from multi-document pod templates
// that should be deployed alongside the workload.
// Supports three templateString formats:
//   - Bare PodSpec: wrapped into the workloadType (DaemonSet/Deployment)
//   - Full Pod manifest (kind: Pod): PodSpec extracted, wrapped into workloadType
//   - Full workload manifest (kind: Deployment/DaemonSet): used directly with breakglass labels merged
func (c *DebugSessionController) buildWorkload(ds *v1alpha1.DebugSession, template *v1alpha1.DebugSessionTemplate, binding *v1alpha1.DebugSessionClusterBinding, podTemplate *v1alpha1.DebugPodTemplate, targetNs string) (ctrlclient.Object, []*unstructured.Unstructured, error) <span class="cov0" title="0">{
        // ds.Name already starts with "debug-" (generated as "debug-{user}-{cluster}-{ts}"),
        // so we use it directly to avoid a redundant "debug-debug-" prefix.
        workloadName := ds.Name
        renderResult, err := c.buildPodSpec(ds, template, podTemplate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">labels := map[string]string{
                DebugSessionLabelKey:           ds.Name,
                DebugTemplateLabelKey:          ds.Spec.TemplateRef,
                DebugClusterLabelKey:           ds.Spec.Cluster,
                "app.kubernetes.io/managed-by": "breakglass",
        }

        labels = mergeStringMaps(labels, template.Spec.Labels, bindingLabels(binding), podTemplateLabels(podTemplate))
        for k, v := range ds.Labels </span><span class="cov0" title="0">{
                if k == DebugSessionLabelKey || k == DebugTemplateLabelKey || k == DebugClusterLabelKey </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">labels[k] = v</span>
        }

        // Merge pod-level labels from the template manifest (e.g., kind: Pod metadata.labels).
        // Re-assert controller-owned debug labels afterwards so they cannot be overridden
        // by template manifests.
        <span class="cov0" title="0">labels = mergeStringMaps(labels, renderResult.PodLabels)
        labels[DebugSessionLabelKey] = ds.Name
        labels[DebugTemplateLabelKey] = ds.Spec.TemplateRef
        labels[DebugClusterLabelKey] = ds.Spec.Cluster
        labels["app.kubernetes.io/managed-by"] = "breakglass"

        annotations := mergeStringMaps(nil, template.Spec.Annotations, bindingAnnotations(binding), podTemplateAnnotations(podTemplate))
        if len(ds.Annotations) &gt; 0 </span><span class="cov0" title="0">{
                if annotations == nil </span><span class="cov0" title="0">{
                        annotations = make(map[string]string)
                }</span>
                <span class="cov0" title="0">for k, v := range ds.Annotations </span><span class="cov0" title="0">{
                        annotations[k] = v
                }</span>
        }

        // Merge pod-level annotations from the template manifest
        <span class="cov0" title="0">annotations = mergeStringMaps(annotations, renderResult.PodAnnotations)

        workloadType := template.Spec.WorkloadType
        if workloadType == "" </span><span class="cov0" title="0">{
                workloadType = v1alpha1.DebugWorkloadDaemonSet
        }</span>

        <span class="cov0" title="0">podSpec := renderResult.PodSpec

        // If the template produced a full workload manifest, validate and use it directly
        if renderResult.Workload != nil </span><span class="cov0" title="0">{
                return c.useTemplateWorkload(renderResult, workloadType, workloadName, targetNs, ds, template, labels, annotations)
        }</span>

        // Enforce RestartPolicy: Always for DaemonSets and Deployments
        // These workload types require Always restart policy
        <span class="cov0" title="0">if workloadType == v1alpha1.DebugWorkloadDaemonSet || workloadType == v1alpha1.DebugWorkloadDeployment </span><span class="cov0" title="0">{
                if podSpec.RestartPolicy != corev1.RestartPolicyAlways </span><span class="cov0" title="0">{
                        c.log.Debugw("Overriding RestartPolicy to Always for workload type",
                                "workloadType", workloadType,
                                "originalPolicy", podSpec.RestartPolicy,
                                "debugSession", ds.Name,
                        )
                        podSpec.RestartPolicy = corev1.RestartPolicyAlways
                }</span>
        }

        <span class="cov0" title="0">switch workloadType </span>{
        case v1alpha1.DebugWorkloadDaemonSet:<span class="cov0" title="0">
                return &amp;appsv1.DaemonSet{
                        TypeMeta: metav1.TypeMeta{
                                APIVersion: "apps/v1",
                                Kind:       "DaemonSet",
                        },
                        ObjectMeta: metav1.ObjectMeta{
                                Name:        workloadName,
                                Namespace:   targetNs,
                                Labels:      labels,
                                Annotations: annotations,
                        },
                        Spec: appsv1.DaemonSetSpec{
                                Selector: &amp;metav1.LabelSelector{
                                        MatchLabels: map[string]string{
                                                DebugSessionLabelKey: ds.Name,
                                        },
                                },
                                Template: corev1.PodTemplateSpec{
                                        ObjectMeta: metav1.ObjectMeta{
                                                Labels:      labels,
                                                Annotations: annotations,
                                        },
                                        Spec: podSpec,
                                },
                        },
                }, renderResult.AdditionalResources, nil</span>

        case v1alpha1.DebugWorkloadDeployment:<span class="cov0" title="0">
                replicas := int32(1)
                if template.Spec.Replicas != nil </span><span class="cov0" title="0">{
                        replicas = *template.Spec.Replicas
                }</span>
                <span class="cov0" title="0">if template.Spec.ResourceQuota != nil &amp;&amp; template.Spec.ResourceQuota.MaxPods != nil &amp;&amp; replicas &gt; *template.Spec.ResourceQuota.MaxPods </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("replicas (%d) exceed resourceQuota.maxPods (%d)", replicas, *template.Spec.ResourceQuota.MaxPods)
                }</span>
                <span class="cov0" title="0">return &amp;appsv1.Deployment{
                        TypeMeta: metav1.TypeMeta{
                                APIVersion: "apps/v1",
                                Kind:       "Deployment",
                        },
                        ObjectMeta: metav1.ObjectMeta{
                                Name:        workloadName,
                                Namespace:   targetNs,
                                Labels:      labels,
                                Annotations: annotations,
                        },
                        Spec: appsv1.DeploymentSpec{
                                Replicas: &amp;replicas,
                                Selector: &amp;metav1.LabelSelector{
                                        MatchLabels: map[string]string{
                                                DebugSessionLabelKey: ds.Name,
                                        },
                                },
                                Template: corev1.PodTemplateSpec{
                                        ObjectMeta: metav1.ObjectMeta{
                                                Labels:      labels,
                                                Annotations: annotations,
                                        },
                                        Spec: podSpec,
                                },
                        },
                }, renderResult.AdditionalResources, nil</span>

        default:<span class="cov0" title="0">
                return nil, nil, fmt.Errorf("unsupported workload type: %s", workloadType)</span>
        }
}

// useTemplateWorkload processes a full workload manifest from a templateString.
// It validates the kind matches the configured workloadType, overrides name/namespace/labels,
// and enforces breakglass policies (RestartPolicy, selectors, replicas).
func (c *DebugSessionController) useTemplateWorkload(
        renderResult *PodTemplateRenderResult,
        workloadType v1alpha1.DebugWorkloadType,
        workloadName, targetNs string,
        ds *v1alpha1.DebugSession,
        template *v1alpha1.DebugSessionTemplate,
        labels, annotations map[string]string,
) (ctrlclient.Object, []*unstructured.Unstructured, error) <span class="cov0" title="0">{
        workload := renderResult.Workload
        gvk := workload.GetObjectKind().GroupVersionKind()

        // Validate workload kind matches the configured workloadType
        if v1alpha1.DebugWorkloadType(gvk.Kind) != workloadType </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf(
                        "templateString produces a %s but workloadType is %s: these must match",
                        gvk.Kind, workloadType,
                )
        }</span>

        <span class="cov0" title="0">selectorLabels := map[string]string{
                DebugSessionLabelKey: ds.Name,
        }

        switch w := workload.(type) </span>{
        case *appsv1.Deployment:<span class="cov0" title="0">
                // Override name, namespace, labels, annotations, selector
                w.Name = workloadName
                w.Namespace = targetNs
                w.Labels = labels
                w.Annotations = annotations
                w.Spec.Selector = &amp;metav1.LabelSelector{MatchLabels: selectorLabels}
                w.Spec.Template.Labels = mergeStringMaps(w.Spec.Template.Labels, labels)
                w.Spec.Template.Annotations = mergeStringMaps(w.Spec.Template.Annotations, annotations)

                // Apply the modified PodSpec back into the workload.
                // buildPodSpec applies overrides (schedulingConstraints, tolerations, affinity,
                // podOverrides, nodeSelector, resourceQuota enforcement, terminalSharing) to
                // renderResult.PodSpec. We must copy the modified PodSpec back into the workload
                // to ensure those overrides are not lost.
                w.Spec.Template.Spec = renderResult.PodSpec

                // Override replicas from session template if set
                if template.Spec.Replicas != nil </span><span class="cov0" title="0">{
                        w.Spec.Replicas = template.Spec.Replicas
                }</span>
                <span class="cov0" title="0">if w.Spec.Replicas == nil </span><span class="cov0" title="0">{
                        one := int32(1)
                        w.Spec.Replicas = &amp;one
                }</span>
                <span class="cov0" title="0">if template.Spec.ResourceQuota != nil &amp;&amp; template.Spec.ResourceQuota.MaxPods != nil &amp;&amp; *w.Spec.Replicas &gt; *template.Spec.ResourceQuota.MaxPods </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("replicas (%d) exceed resourceQuota.maxPods (%d)", *w.Spec.Replicas, *template.Spec.ResourceQuota.MaxPods)
                }</span>

                // Enforce RestartPolicy (after PodSpec copy, since overrides may have changed it)
                <span class="cov0" title="0">if w.Spec.Template.Spec.RestartPolicy != corev1.RestartPolicyAlways </span><span class="cov0" title="0">{
                        w.Spec.Template.Spec.RestartPolicy = corev1.RestartPolicyAlways
                }</span>

                <span class="cov0" title="0">return w, renderResult.AdditionalResources, nil</span>

        case *appsv1.DaemonSet:<span class="cov0" title="0">
                // Override name, namespace, labels, annotations, selector
                w.Name = workloadName
                w.Namespace = targetNs
                w.Labels = labels
                w.Annotations = annotations
                w.Spec.Selector = &amp;metav1.LabelSelector{MatchLabels: selectorLabels}
                w.Spec.Template.Labels = mergeStringMaps(w.Spec.Template.Labels, labels)
                w.Spec.Template.Annotations = mergeStringMaps(w.Spec.Template.Annotations, annotations)

                // Apply the modified PodSpec back into the workload (see Deployment comment above).
                w.Spec.Template.Spec = renderResult.PodSpec

                // Enforce RestartPolicy (after PodSpec copy)
                if w.Spec.Template.Spec.RestartPolicy != corev1.RestartPolicyAlways </span><span class="cov0" title="0">{
                        w.Spec.Template.Spec.RestartPolicy = corev1.RestartPolicyAlways
                }</span>

                <span class="cov0" title="0">return w, renderResult.AdditionalResources, nil</span>

        default:<span class="cov0" title="0">
                return nil, nil, fmt.Errorf("unsupported workload type from template: %T", workload)</span>
        }
}

// deployPodTemplateResource deploys a single resource from a multi-document pod template.
// It applies standard labels/annotations for tracking and uses Server-Side Apply for idempotency.
func (c *DebugSessionController) deployPodTemplateResource(
        ctx context.Context,
        targetClient ctrlclient.Client,
        ds *v1alpha1.DebugSession,
        obj *unstructured.Unstructured,
        targetNs string,
) error <span class="cov0" title="0">{
        log := c.log.With("debugSession", ds.Name, "namespace", ds.Namespace)

        // Set namespace if not specified
        if obj.GetNamespace() == "" </span><span class="cov0" title="0">{
                obj.SetNamespace(targetNs)
        }</span>

        // Apply standard labels
        <span class="cov0" title="0">labels := obj.GetLabels()
        if labels == nil </span><span class="cov0" title="0">{
                labels = make(map[string]string)
        }</span>
        <span class="cov0" title="0">labels["app.kubernetes.io/managed-by"] = "breakglass"
        labels["breakglass.t-caas.telekom.com/session"] = ds.Name
        labels["breakglass.t-caas.telekom.com/session-cluster"] = ds.Spec.Cluster
        labels["breakglass.t-caas.telekom.com/pod-template-resource"] = "true"
        obj.SetLabels(labels)

        // Apply standard annotations
        annotations := obj.GetAnnotations()
        if annotations == nil </span><span class="cov0" title="0">{
                annotations = make(map[string]string)
        }</span>
        <span class="cov0" title="0">annotations["breakglass.t-caas.telekom.com/source-session"] = fmt.Sprintf("%s/%s", ds.Namespace, ds.Name)
        obj.SetAnnotations(annotations)

        // Deploy using Server-Side Apply for idempotency
        obj.SetManagedFields(nil)
        //nolint:staticcheck // SA1019: client.Apply for Patch is still required for unstructured objects
        if err := targetClient.Patch(ctx, obj, ctrlclient.Apply, ctrlclient.FieldOwner("breakglass-controller"), ctrlclient.ForceOwnership); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("SSA apply failed: %w", err)
        }</span>

        // Track in session status
        <span class="cov0" title="0">status := v1alpha1.PodTemplateResourceStatus{
                Kind:         obj.GetKind(),
                APIVersion:   obj.GetAPIVersion(),
                ResourceName: obj.GetName(),
                Namespace:    obj.GetNamespace(),
                Source:       "podTemplateString",
                Created:      true,
        }
        now := time.Now().UTC().Format(time.RFC3339)
        status.CreatedAt = &amp;now
        ds.Status.PodTemplateResourceStatuses = append(ds.Status.PodTemplateResourceStatuses, status)

        // Add to deployed resources list
        ds.Status.DeployedResources = append(ds.Status.DeployedResources, v1alpha1.DeployedResourceRef{
                APIVersion: obj.GetAPIVersion(),
                Kind:       obj.GetKind(),
                Name:       obj.GetName(),
                Namespace:  obj.GetNamespace(),
                Source:     "pod-template",
        })

        log.Infow("Deployed pod template resource",
                "kind", obj.GetKind(),
                "name", obj.GetName(),
                "namespace", obj.GetNamespace())

        return nil</span>
}

// buildPodSpec creates the pod spec from templates and overrides.
// Supports both structured podTemplate and Go-templated podTemplateString.
// Now supports multi-document YAML where the first document can be a bare PodSpec,
// a full Pod manifest, or a full Deployment/DaemonSet manifest.
// Returns a PodTemplateRenderResult containing the PodSpec, optional workload, and metadata.
func (c *DebugSessionController) buildPodSpec(ds *v1alpha1.DebugSession, template *v1alpha1.DebugSessionTemplate, podTemplate *v1alpha1.DebugPodTemplate) (*PodTemplateRenderResult, error) <span class="cov0" title="0">{
        var renderResult *PodTemplateRenderResult

        // Build render context for template rendering (podTemplateString, podOverridesTemplate)
        renderCtx := c.buildPodRenderContext(ds, template)

        // Determine pod spec source: podTemplateString takes priority over podTemplateRef
        if template.Spec.PodTemplateString != "" </span><span class="cov0" title="0">{
                // Render podTemplateString as Go template (from DebugSessionTemplate)
                result, err := c.renderPodTemplateStringMultiDoc(template.Spec.PodTemplateString, renderCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to render podTemplateString: %w", err)
                }</span>
                <span class="cov0" title="0">renderResult = result</span>
        } else<span class="cov0" title="0"> if podTemplate != nil </span><span class="cov0" title="0">{
                // Use DebugPodTemplate - check for templateString first, then structured template
                if podTemplate.Spec.TemplateString != "" </span><span class="cov0" title="0">{
                        // Render DebugPodTemplate's templateString as Go template
                        result, err := c.renderPodTemplateStringMultiDoc(podTemplate.Spec.TemplateString, renderCtx)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to render DebugPodTemplate templateString: %w", err)
                        }</span>
                        <span class="cov0" title="0">renderResult = result</span>
                } else<span class="cov0" title="0"> if podTemplate.Spec.Template != nil </span><span class="cov0" title="0">{
                        // Use structured pod template (no multi-doc support for structured templates)
                        renderResult = &amp;PodTemplateRenderResult{
                                PodSpec: c.convertDebugPodSpec(podTemplate.Spec.Template.Spec),
                        }
                }</span> else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("DebugPodTemplate %s has neither template nor templateString", podTemplate.Name)
                }</span>
        } else<span class="cov0" title="0"> {
                renderResult = &amp;PodTemplateRenderResult{}
        }</span>

        <span class="cov0" title="0">spec := &amp;renderResult.PodSpec

        // Apply podOverridesTemplate if specified (Go template producing overrides YAML)
        if template.Spec.PodOverridesTemplate != "" </span><span class="cov0" title="0">{
                overrides, err := c.renderPodOverridesTemplate(template.Spec.PodOverridesTemplate, renderCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to render podOverridesTemplate: %w", err)
                }</span>
                <span class="cov0" title="0">c.applyPodOverridesStruct(spec, overrides)</span>
        }

        // Apply static overrides from session template (legacy support)
        <span class="cov0" title="0">if template.Spec.PodOverrides != nil &amp;&amp; template.Spec.PodOverrides.Spec != nil </span><span class="cov0" title="0">{
                overrides := template.Spec.PodOverrides.Spec
                if overrides.HostNetwork != nil </span><span class="cov0" title="0">{
                        spec.HostNetwork = *overrides.HostNetwork
                }</span>
                <span class="cov0" title="0">if overrides.HostPID != nil </span><span class="cov0" title="0">{
                        spec.HostPID = *overrides.HostPID
                }</span>
                <span class="cov0" title="0">if overrides.HostIPC != nil </span><span class="cov0" title="0">{
                        spec.HostIPC = *overrides.HostIPC
                }</span>
        }

        // Apply affinity overrides
        <span class="cov0" title="0">if template.Spec.AffinityOverrides != nil </span><span class="cov0" title="0">{
                spec.Affinity = template.Spec.AffinityOverrides
        }</span>

        // Add tolerations
        <span class="cov0" title="0">if len(template.Spec.AdditionalTolerations) &gt; 0 </span><span class="cov0" title="0">{
                spec.Tolerations = append(spec.Tolerations, template.Spec.AdditionalTolerations...)
        }</span>

        // Merge node selector from session request
        <span class="cov0" title="0">if len(ds.Spec.NodeSelector) &gt; 0 </span><span class="cov0" title="0">{
                if spec.NodeSelector == nil </span><span class="cov0" title="0">{
                        spec.NodeSelector = make(map[string]string)
                }</span>
                <span class="cov0" title="0">for k, v := range ds.Spec.NodeSelector </span><span class="cov0" title="0">{
                        spec.NodeSelector[k] = v
                }</span>
        }

        // Apply resolved scheduling constraints from session
        // These are computed at session creation time and take precedence
        <span class="cov0" title="0">if ds.Spec.ResolvedSchedulingConstraints != nil </span><span class="cov0" title="0">{
                c.applySchedulingConstraints(spec, ds.Spec.ResolvedSchedulingConstraints)
        }</span> else<span class="cov0" title="0"> if template.Spec.SchedulingConstraints != nil </span><span class="cov0" title="0">{
                // Fallback to template constraints if session doesn't have resolved constraints
                c.applySchedulingConstraints(spec, template.Spec.SchedulingConstraints)
        }</span>

        <span class="cov0" title="0">if template.Spec.ResourceQuota != nil </span><span class="cov0" title="0">{
                if err := enforceContainerResources(template.Spec.ResourceQuota, spec.Containers, spec.InitContainers); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Verify if terminal sharing is enabled and inject multiplexer command
        <span class="cov0" title="0">if template.Spec.TerminalSharing != nil &amp;&amp; template.Spec.TerminalSharing.Enabled &amp;&amp; len(spec.Containers) &gt; 0 </span><span class="cov0" title="0">{
                container := &amp;spec.Containers[0]

                provider := template.Spec.TerminalSharing.Provider
                if provider == "" </span><span class="cov0" title="0">{
                        provider = "tmux"
                }</span>

                <span class="cov0" title="0">sessionName := ds.Name
                if len(sessionName) &gt; 32 </span><span class="cov0" title="0">{
                        sessionName = sessionName[:32]
                }</span>

                // Only wrap if explicit command is set, otherwise we risk masking entrypoint
                <span class="cov0" title="0">if len(container.Command) &gt; 0 </span><span class="cov0" title="0">{
                        // Construct child command
                        childCmd := make([]string, 0, len(container.Command)+len(container.Args))
                        childCmd = append(childCmd, container.Command...)
                        childCmd = append(childCmd, container.Args...)

                        if provider == "tmux" </span><span class="cov0" title="0">{
                                // tmux new-session -A -s &lt;name&gt; &lt;cmd...&gt;
                                // -A: attach to existing session if it exists
                                container.Command = []string{"tmux", "new-session", "-A", "-s", sessionName}
                                container.Args = childCmd
                        }</span> else<span class="cov0" title="0"> if provider == "screen" </span><span class="cov0" title="0">{
                                // screen -xRR -S &lt;name&gt; &lt;cmd...&gt;
                                // -xRR: Attach to existing, or create new (multi-display mode)
                                container.Command = []string{"screen", "-xRR", "-S", sessionName}
                                container.Args = childCmd
                        }</span>
                }
        }

        <span class="cov0" title="0">return renderResult, nil</span>
}

// buildPodRenderContext creates the render context for pod templates.
// This is a subset of AuxiliaryResourceContext, focused on pod rendering.
func (c *DebugSessionController) buildPodRenderContext(ds *v1alpha1.DebugSession, template *v1alpha1.DebugSessionTemplate) v1alpha1.AuxiliaryResourceContext <span class="cov0" title="0">{
        ctx := v1alpha1.AuxiliaryResourceContext{
                Session: v1alpha1.AuxiliaryResourceSessionContext{
                        Name:        ds.Name,
                        Namespace:   ds.Namespace,
                        Cluster:     ds.Spec.Cluster,
                        RequestedBy: ds.Spec.RequestedBy,
                        Reason:      ds.Spec.Reason,
                },
                Target: v1alpha1.AuxiliaryResourceTargetContext{
                        Namespace:   ds.Spec.TargetNamespace,
                        ClusterName: ds.Spec.Cluster,
                },
                Template: v1alpha1.AuxiliaryResourceTemplateContext{
                        Name:        ds.Spec.TemplateRef,
                        DisplayName: template.Spec.DisplayName,
                },
                Labels: map[string]string{
                        "app.kubernetes.io/managed-by":                  "breakglass",
                        "breakglass.t-caas.telekom.com/session":         ds.Name,
                        "breakglass.t-caas.telekom.com/session-cluster": ds.Spec.Cluster,
                },
                Annotations: map[string]string{
                        "breakglass.t-caas.telekom.com/created-by": ds.Spec.RequestedBy,
                },
                Now: time.Now().UTC().Format(time.RFC3339),
        }

        if ds.Status.Approval != nil </span><span class="cov0" title="0">{
                ctx.Session.ApprovedBy = ds.Status.Approval.ApprovedBy
        }</span>
        <span class="cov0" title="0">if ds.Status.ExpiresAt != nil </span><span class="cov0" title="0">{
                ctx.Session.ExpiresAt = ds.Status.ExpiresAt.Format(time.RFC3339)
        }</span>
        <span class="cov0" title="0">if template.Spec.TargetNamespace != "" &amp;&amp; ctx.Target.Namespace == "" </span><span class="cov0" title="0">{
                ctx.Target.Namespace = template.Spec.TargetNamespace
        }</span>

        // Build Vars from extraDeployValues with defaults from template
        <span class="cov0" title="0">ctx.Vars = c.buildVarsFromSession(ds, &amp;template.Spec)

        return ctx</span>
}

// buildVarsFromSession extracts user-provided variable values from session spec
// and applies defaults from template definition.
func (c *DebugSessionController) buildVarsFromSession(
        ds *v1alpha1.DebugSession,
        templateSpec *v1alpha1.DebugSessionTemplateSpec,
) map[string]string <span class="cov0" title="0">{
        vars := make(map[string]string)

        // Apply defaults from template variable definitions
        if templateSpec != nil </span><span class="cov0" title="0">{
                for _, varDef := range templateSpec.ExtraDeployVariables </span><span class="cov0" title="0">{
                        if varDef.Default != nil &amp;&amp; len(varDef.Default.Raw) &gt; 0 </span><span class="cov0" title="0">{
                                vars[varDef.Name] = extractJSONValueForPod(varDef.Default.Raw)
                        }</span>
                }
        }

        // Override with user-provided values
        <span class="cov0" title="0">for name, jsonVal := range ds.Spec.ExtraDeployValues </span><span class="cov0" title="0">{
                vars[name] = extractJSONValueForPod(jsonVal.Raw)
        }</span>

        <span class="cov0" title="0">return vars</span>
}

// extractJSONValueForPod extracts string representation from JSON.
// Local copy to avoid import cycles.
func extractJSONValueForPod(raw []byte) string <span class="cov0" title="0">{
        if len(raw) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">var strVal string
        if err := json.Unmarshal(raw, &amp;strVal); err == nil </span><span class="cov0" title="0">{
                return strVal
        }</span>

        <span class="cov0" title="0">var boolVal bool
        if err := json.Unmarshal(raw, &amp;boolVal); err == nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("%t", boolVal)
        }</span>

        <span class="cov0" title="0">var numVal float64
        if err := json.Unmarshal(raw, &amp;numVal); err == nil </span><span class="cov0" title="0">{
                if numVal == float64(int64(numVal)) </span><span class="cov0" title="0">{
                        return fmt.Sprintf("%d", int64(numVal))
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%g", numVal)</span>
        }

        <span class="cov0" title="0">var arrVal []string
        if err := json.Unmarshal(raw, &amp;arrVal); err == nil </span><span class="cov0" title="0">{
                return strings.Join(arrVal, ",")
        }</span>

        <span class="cov0" title="0">return string(raw)</span>
}

// PodTemplateRenderResult contains the result of rendering a multi-document pod template.
type PodTemplateRenderResult struct {
        // PodSpec is the parsed PodSpec from the first YAML document.
        PodSpec corev1.PodSpec

        // AdditionalResources are parsed K8s resources from subsequent YAML documents.
        AdditionalResources []*unstructured.Unstructured

        // Workload is non-nil when the first document is a full workload manifest
        // (kind: Deployment or kind: DaemonSet). In this case, PodSpec is extracted
        // from the workload's pod template spec.
        Workload ctrlclient.Object

        // PodLabels are labels extracted from the metadata of a kind: Pod manifest.
        // These are merged into the workload's pod template labels.
        PodLabels map[string]string

        // PodAnnotations are annotations extracted from the metadata of a kind: Pod manifest.
        // These are merged into the workload's pod template annotations.
        PodAnnotations map[string]string
}

// renderPodTemplateString renders a podTemplateString Go template and returns a PodSpec.
// For backward compatibility, this returns only the PodSpec (first document).
// Use renderPodTemplateStringMultiDoc for full multi-document support.
func (c *DebugSessionController) renderPodTemplateString(templateStr string, ctx v1alpha1.AuxiliaryResourceContext) (corev1.PodSpec, error) <span class="cov0" title="0">{
        result, err := c.renderPodTemplateStringMultiDoc(templateStr, ctx)
        if err != nil </span><span class="cov0" title="0">{
                return corev1.PodSpec{}, err
        }</span>
        <span class="cov0" title="0">return result.PodSpec, nil</span>
}

// renderPodTemplateStringMultiDoc renders a podTemplateString Go template with multi-document support.
// The first YAML document can be:
//   - A bare PodSpec (containers at top level)
//   - A full Pod manifest (kind: Pod)  PodSpec is extracted from .spec
//   - A full Deployment manifest (kind: Deployment)  PodSpec extracted from .spec.template.spec
//   - A full DaemonSet manifest (kind: DaemonSet)  PodSpec extracted from .spec.template.spec
//
// Subsequent documents can be any Kubernetes resource (ConfigMaps, Secrets, PVCs, etc.)
// that will be deployed alongside the debug pod.
func (c *DebugSessionController) renderPodTemplateStringMultiDoc(templateStr string, ctx v1alpha1.AuxiliaryResourceContext) (*PodTemplateRenderResult, error) <span class="cov0" title="0">{
        renderer := NewTemplateRenderer()
        documents, err := renderer.RenderMultiDocumentTemplate(templateStr, ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("template rendering failed: %w", err)
        }</span>

        <span class="cov0" title="0">if len(documents) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("pod template produced no documents")
        }</span>

        <span class="cov0" title="0">result := &amp;PodTemplateRenderResult{}

        // Probe the first document to determine its format
        var probe map[string]interface{}
        if err := yaml.Unmarshal(documents[0], &amp;probe); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse first document: %w", err)
        }</span>

        <span class="cov0" title="0">kind, _ := probe["kind"].(string)
        apiVersion, _ := probe["apiVersion"].(string)

        switch </span>{
        case kind == "Pod" &amp;&amp; apiVersion == "v1":<span class="cov0" title="0">
                // Full Pod manifest  extract .spec as PodSpec and .metadata labels/annotations
                if err := c.extractPodSpecFromPodManifest(documents[0], result); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse Pod manifest: %w", err)
                }</span>

        case kind == "Deployment" &amp;&amp; apiVersion == "apps/v1":<span class="cov0" title="0">
                // Full Deployment manifest  extract PodSpec from .spec.template.spec
                var deployment appsv1.Deployment
                if err := yaml.Unmarshal(documents[0], &amp;deployment); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse Deployment manifest: %w", err)
                }</span>
                <span class="cov0" title="0">result.PodSpec = deployment.Spec.Template.Spec
                result.PodLabels = deployment.Spec.Template.Labels
                result.PodAnnotations = deployment.Spec.Template.Annotations
                result.Workload = &amp;deployment</span>

        case kind == "DaemonSet" &amp;&amp; apiVersion == "apps/v1":<span class="cov0" title="0">
                // Full DaemonSet manifest  extract PodSpec from .spec.template.spec
                var daemonSet appsv1.DaemonSet
                if err := yaml.Unmarshal(documents[0], &amp;daemonSet); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse DaemonSet manifest: %w", err)
                }</span>
                <span class="cov0" title="0">result.PodSpec = daemonSet.Spec.Template.Spec
                result.PodLabels = daemonSet.Spec.Template.Labels
                result.PodAnnotations = daemonSet.Spec.Template.Annotations
                result.Workload = &amp;daemonSet</span>

        case kind != "" &amp;&amp; apiVersion != "":<span class="cov0" title="0">
                // Has apiVersion/kind but not a supported type  give specific error for known kinds with wrong apiVersion
                switch kind </span>{
                case "Pod":<span class="cov0" title="0">
                        return nil, fmt.Errorf("unsupported apiVersion %q for kind Pod: expected v1", apiVersion)</span>
                case "Deployment":<span class="cov0" title="0">
                        return nil, fmt.Errorf("unsupported apiVersion %q for kind Deployment: expected apps/v1", apiVersion)</span>
                case "DaemonSet":<span class="cov0" title="0">
                        return nil, fmt.Errorf("unsupported apiVersion %q for kind DaemonSet: expected apps/v1", apiVersion)</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("unsupported manifest kind %q (apiVersion %q) in templateString: only bare PodSpec, Pod (v1), Deployment (apps/v1), and DaemonSet (apps/v1) are supported", kind, apiVersion)</span>
                }

        default:<span class="cov0" title="0">
                // No apiVersion/kind  treat as bare PodSpec (backward compatible)
                if err := yaml.Unmarshal(documents[0], &amp;result.PodSpec); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse first document as PodSpec: %w", err)
                }</span>
        }

        // Validate that the extracted PodSpec has containers
        <span class="cov0" title="0">if len(result.PodSpec.Containers) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("pod template produced a PodSpec with no containers: ensure the template defines at least one container")
        }</span>

        // Subsequent documents are additional K8s resources
        <span class="cov0" title="0">for i := 1; i &lt; len(documents); i++ </span><span class="cov0" title="0">{
                obj := &amp;unstructured.Unstructured{}
                if err := yaml.Unmarshal(documents[i], &amp;obj.Object); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse document %d as Kubernetes resource: %w", i+1, err)
                }</span>

                // Validate it looks like a K8s resource
                <span class="cov0" title="0">if obj.GetAPIVersion() == "" || obj.GetKind() == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("document %d is not a valid Kubernetes resource (missing apiVersion or kind)", i+1)
                }</span>

                <span class="cov0" title="0">result.AdditionalResources = append(result.AdditionalResources, obj)</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

// extractPodSpecFromPodManifest extracts the PodSpec, labels, and annotations from a kind: Pod YAML document.
func (c *DebugSessionController) extractPodSpecFromPodManifest(document []byte, result *PodTemplateRenderResult) error <span class="cov0" title="0">{
        // Unmarshal as a map to extract the spec sub-object
        var podMap map[string]interface{}
        if err := yaml.Unmarshal(document, &amp;podMap); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse Pod manifest: %w", err)
        }</span>

        // Extract .spec and re-marshal it as PodSpec
        <span class="cov0" title="0">specRaw, ok := podMap["spec"]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("Pod manifest is missing 'spec' field")
        }</span>

        <span class="cov0" title="0">specBytes, err := yaml.Marshal(specRaw)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to re-marshal Pod spec: %w", err)
        }</span>

        <span class="cov0" title="0">if err := yaml.Unmarshal(specBytes, &amp;result.PodSpec); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse Pod spec as PodSpec: %w", err)
        }</span>

        // Extract metadata labels and annotations
        <span class="cov0" title="0">if metadata, ok := podMap["metadata"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if labels, ok := metadata["labels"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        result.PodLabels = make(map[string]string, len(labels))
                        for k, v := range labels </span><span class="cov0" title="0">{
                                if s, ok := v.(string); ok </span><span class="cov0" title="0">{
                                        result.PodLabels[k] = s
                                }</span>
                        }
                }
                <span class="cov0" title="0">if annotations, ok := metadata["annotations"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        result.PodAnnotations = make(map[string]string, len(annotations))
                        for k, v := range annotations </span><span class="cov0" title="0">{
                                if s, ok := v.(string); ok </span><span class="cov0" title="0">{
                                        result.PodAnnotations[k] = s
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// renderPodOverridesTemplate renders podOverridesTemplate and returns structured overrides.
func (c *DebugSessionController) renderPodOverridesTemplate(templateStr string, ctx v1alpha1.AuxiliaryResourceContext) (*v1alpha1.DebugPodSpecOverrides, error) <span class="cov0" title="0">{
        renderer := NewTemplateRenderer()
        rendered, err := renderer.RenderTemplateString(templateStr, ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("template rendering failed: %w", err)
        }</span>

        <span class="cov0" title="0">var overrides v1alpha1.DebugPodSpecOverrides
        if err := yaml.Unmarshal(rendered, &amp;overrides); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse rendered overrides YAML: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;overrides, nil</span>
}

// applyPodOverridesStruct applies rendered overrides to a pod spec.
func (c *DebugSessionController) applyPodOverridesStruct(spec *corev1.PodSpec, overrides *v1alpha1.DebugPodSpecOverrides) <span class="cov0" title="0">{
        if overrides == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if overrides.HostNetwork != nil </span><span class="cov0" title="0">{
                spec.HostNetwork = *overrides.HostNetwork
        }</span>
        <span class="cov0" title="0">if overrides.HostPID != nil </span><span class="cov0" title="0">{
                spec.HostPID = *overrides.HostPID
        }</span>
        <span class="cov0" title="0">if overrides.HostIPC != nil </span><span class="cov0" title="0">{
                spec.HostIPC = *overrides.HostIPC
        }</span>
}

func mergeStringMaps(base map[string]string, maps ...map[string]string) map[string]string <span class="cov0" title="0">{
        var merged map[string]string
        if len(base) &gt; 0 </span><span class="cov0" title="0">{
                merged = make(map[string]string, len(base))
                for k, v := range base </span><span class="cov0" title="0">{
                        merged[k] = v
                }</span>
        }
        <span class="cov0" title="0">for _, m := range maps </span><span class="cov0" title="0">{
                if len(m) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if merged == nil </span><span class="cov0" title="0">{
                        merged = make(map[string]string)
                }</span>
                <span class="cov0" title="0">for k, v := range m </span><span class="cov0" title="0">{
                        merged[k] = v
                }</span>
        }
        <span class="cov0" title="0">return merged</span>
}

func bindingLabels(binding *v1alpha1.DebugSessionClusterBinding) map[string]string <span class="cov0" title="0">{
        if binding == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return binding.Spec.Labels</span>
}

func bindingAnnotations(binding *v1alpha1.DebugSessionClusterBinding) map[string]string <span class="cov0" title="0">{
        if binding == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return binding.Spec.Annotations</span>
}

func podTemplateLabels(podTemplate *v1alpha1.DebugPodTemplate) map[string]string <span class="cov0" title="0">{
        if podTemplate == nil || podTemplate.Spec.Template == nil || podTemplate.Spec.Template.Metadata == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return podTemplate.Spec.Template.Metadata.Labels</span>
}

func podTemplateAnnotations(podTemplate *v1alpha1.DebugPodTemplate) map[string]string <span class="cov0" title="0">{
        if podTemplate == nil || podTemplate.Spec.Template == nil || podTemplate.Spec.Template.Metadata == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return podTemplate.Spec.Template.Metadata.Annotations</span>
}

func enforceContainerResources(cfg *v1alpha1.DebugResourceQuotaConfig, containers []corev1.Container, initContainers []corev1.Container) error <span class="cov0" title="0">{
        if cfg == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">needsRequests := cfg.EnforceResourceRequests
        needsLimits := cfg.EnforceResourceLimits
        if !needsRequests &amp;&amp; !needsLimits </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">requiredResources := []corev1.ResourceName{corev1.ResourceCPU, corev1.ResourceMemory}
        if cfg.MaxStorage != "" </span><span class="cov0" title="0">{
                requiredResources = append(requiredResources, corev1.ResourceEphemeralStorage)
        }</span>

        <span class="cov0" title="0">check := func(c corev1.Container) error </span><span class="cov0" title="0">{
                if needsRequests </span><span class="cov0" title="0">{
                        for _, r := range requiredResources </span><span class="cov0" title="0">{
                                if c.Resources.Requests == nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("container %s is missing resource requests", c.Name)
                                }</span>
                                <span class="cov0" title="0">if _, ok := c.Resources.Requests[r]; !ok </span><span class="cov0" title="0">{
                                        return fmt.Errorf("container %s is missing request for %s", c.Name, r)
                                }</span>
                        }
                }
                <span class="cov0" title="0">if needsLimits </span><span class="cov0" title="0">{
                        for _, r := range requiredResources </span><span class="cov0" title="0">{
                                if c.Resources.Limits == nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("container %s is missing resource limits", c.Name)
                                }</span>
                                <span class="cov0" title="0">if _, ok := c.Resources.Limits[r]; !ok </span><span class="cov0" title="0">{
                                        return fmt.Errorf("container %s is missing limit for %s", c.Name, r)
                                }</span>
                        }
                }
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">for _, c := range containers </span><span class="cov0" title="0">{
                if err := check(c); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">for _, c := range initContainers </span><span class="cov0" title="0">{
                if err := check(c); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (c *DebugSessionController) buildResourceQuota(ds *v1alpha1.DebugSession, template *v1alpha1.DebugSessionTemplate, binding *v1alpha1.DebugSessionClusterBinding, targetNs string) (*corev1.ResourceQuota, error) <span class="cov0" title="0">{
        if template.Spec.ResourceQuota == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">hard := corev1.ResourceList{}
        if template.Spec.ResourceQuota.MaxPods != nil </span><span class="cov0" title="0">{
                hard[corev1.ResourcePods] = *resource.NewQuantity(int64(*template.Spec.ResourceQuota.MaxPods), resource.DecimalSI)
        }</span>
        <span class="cov0" title="0">if template.Spec.ResourceQuota.MaxCPU != "" </span><span class="cov0" title="0">{
                qty, err := resource.ParseQuantity(template.Spec.ResourceQuota.MaxCPU)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid maxCPU: %w", err)
                }</span>
                <span class="cov0" title="0">hard[corev1.ResourceRequestsCPU] = qty
                hard[corev1.ResourceLimitsCPU] = qty</span>
        }
        <span class="cov0" title="0">if template.Spec.ResourceQuota.MaxMemory != "" </span><span class="cov0" title="0">{
                qty, err := resource.ParseQuantity(template.Spec.ResourceQuota.MaxMemory)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid maxMemory: %w", err)
                }</span>
                <span class="cov0" title="0">hard[corev1.ResourceRequestsMemory] = qty
                hard[corev1.ResourceLimitsMemory] = qty</span>
        }
        <span class="cov0" title="0">if template.Spec.ResourceQuota.MaxStorage != "" </span><span class="cov0" title="0">{
                qty, err := resource.ParseQuantity(template.Spec.ResourceQuota.MaxStorage)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid maxStorage: %w", err)
                }</span>
                <span class="cov0" title="0">hard[corev1.ResourceRequestsEphemeralStorage] = qty
                hard[corev1.ResourceLimitsEphemeralStorage] = qty</span>
        }
        <span class="cov0" title="0">if len(hard) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">labels := map[string]string{
                DebugSessionLabelKey:  ds.Name,
                DebugTemplateLabelKey: ds.Spec.TemplateRef,
                DebugClusterLabelKey:  ds.Spec.Cluster,
        }
        labels = mergeStringMaps(labels, template.Spec.Labels, bindingLabels(binding), ds.Labels)

        annotations := mergeStringMaps(nil, template.Spec.Annotations, bindingAnnotations(binding))
        if len(ds.Annotations) &gt; 0 </span><span class="cov0" title="0">{
                annotations = mergeStringMaps(annotations, ds.Annotations)
        }</span>

        <span class="cov0" title="0">return &amp;corev1.ResourceQuota{
                TypeMeta: metav1.TypeMeta{
                        APIVersion: "v1",
                        Kind:       "ResourceQuota",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:        fmt.Sprintf("debug-%s-rq", ds.Name),
                        Namespace:   targetNs,
                        Labels:      labels,
                        Annotations: annotations,
                },
                Spec: corev1.ResourceQuotaSpec{Hard: hard},
        }, nil</span>
}

func (c *DebugSessionController) buildPodDisruptionBudget(ds *v1alpha1.DebugSession, template *v1alpha1.DebugSessionTemplate, binding *v1alpha1.DebugSessionClusterBinding, targetNs string) (*policyv1.PodDisruptionBudget, error) <span class="cov0" title="0">{
        if template.Spec.PodDisruptionBudget == nil || !template.Spec.PodDisruptionBudget.Enabled </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if template.Spec.PodDisruptionBudget.MinAvailable == nil &amp;&amp; template.Spec.PodDisruptionBudget.MaxUnavailable == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">labels := map[string]string{
                DebugSessionLabelKey:  ds.Name,
                DebugTemplateLabelKey: ds.Spec.TemplateRef,
                DebugClusterLabelKey:  ds.Spec.Cluster,
        }
        labels = mergeStringMaps(labels, template.Spec.Labels, bindingLabels(binding), ds.Labels)

        annotations := mergeStringMaps(nil, template.Spec.Annotations, bindingAnnotations(binding))
        if len(ds.Annotations) &gt; 0 </span><span class="cov0" title="0">{
                annotations = mergeStringMaps(annotations, ds.Annotations)
        }</span>

        <span class="cov0" title="0">pdb := &amp;policyv1.PodDisruptionBudget{
                TypeMeta: metav1.TypeMeta{
                        APIVersion: "policy/v1",
                        Kind:       "PodDisruptionBudget",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:        fmt.Sprintf("debug-%s-pdb", ds.Name),
                        Namespace:   targetNs,
                        Labels:      labels,
                        Annotations: annotations,
                },
                Spec: policyv1.PodDisruptionBudgetSpec{
                        Selector: &amp;metav1.LabelSelector{
                                MatchLabels: map[string]string{
                                        DebugSessionLabelKey: ds.Name,
                                },
                        },
                },
        }

        if template.Spec.PodDisruptionBudget.MinAvailable != nil </span><span class="cov0" title="0">{
                pdb.Spec.MinAvailable = &amp;intstr.IntOrString{Type: intstr.Int, IntVal: *template.Spec.PodDisruptionBudget.MinAvailable}
        }</span>
        <span class="cov0" title="0">if template.Spec.PodDisruptionBudget.MaxUnavailable != nil </span><span class="cov0" title="0">{
                pdb.Spec.MaxUnavailable = &amp;intstr.IntOrString{Type: intstr.Int, IntVal: *template.Spec.PodDisruptionBudget.MaxUnavailable}
        }</span>

        <span class="cov0" title="0">return pdb, nil</span>
}

// applySchedulingConstraints applies SchedulingConstraints to a PodSpec.
// This merges the constraints with any existing scheduling configuration.
func (c *DebugSessionController) applySchedulingConstraints(spec *corev1.PodSpec, constraints *v1alpha1.SchedulingConstraints) <span class="cov0" title="0">{
        if constraints == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Apply node selector (merge, constraints take precedence)
        <span class="cov0" title="0">if len(constraints.NodeSelector) &gt; 0 </span><span class="cov0" title="0">{
                if spec.NodeSelector == nil </span><span class="cov0" title="0">{
                        spec.NodeSelector = make(map[string]string)
                }</span>
                <span class="cov0" title="0">for k, v := range constraints.NodeSelector </span><span class="cov0" title="0">{
                        spec.NodeSelector[k] = v
                }</span>
        }

        // Apply tolerations (additive)
        <span class="cov0" title="0">if len(constraints.Tolerations) &gt; 0 </span><span class="cov0" title="0">{
                spec.Tolerations = append(spec.Tolerations, constraints.Tolerations...)
        }</span>

        // Apply node affinity
        <span class="cov0" title="0">if constraints.RequiredNodeAffinity != nil || len(constraints.PreferredNodeAffinity) &gt; 0 </span><span class="cov0" title="0">{
                if spec.Affinity == nil </span><span class="cov0" title="0">{
                        spec.Affinity = &amp;corev1.Affinity{}
                }</span>
                <span class="cov0" title="0">if spec.Affinity.NodeAffinity == nil </span><span class="cov0" title="0">{
                        spec.Affinity.NodeAffinity = &amp;corev1.NodeAffinity{}
                }</span>

                // Merge required node affinity (AND logic)
                <span class="cov0" title="0">if constraints.RequiredNodeAffinity != nil </span><span class="cov0" title="0">{
                        if spec.Affinity.NodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution == nil </span><span class="cov0" title="0">{
                                spec.Affinity.NodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution = constraints.RequiredNodeAffinity.DeepCopy()
                        }</span> else<span class="cov0" title="0"> {
                                // AND the node selector terms
                                spec.Affinity.NodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution.NodeSelectorTerms = append(
                                        spec.Affinity.NodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution.NodeSelectorTerms,
                                        constraints.RequiredNodeAffinity.NodeSelectorTerms...,
                                )
                        }</span>
                }

                // Add preferred node affinity
                <span class="cov0" title="0">if len(constraints.PreferredNodeAffinity) &gt; 0 </span><span class="cov0" title="0">{
                        spec.Affinity.NodeAffinity.PreferredDuringSchedulingIgnoredDuringExecution = append(
                                spec.Affinity.NodeAffinity.PreferredDuringSchedulingIgnoredDuringExecution,
                                constraints.PreferredNodeAffinity...,
                        )
                }</span>
        }

        // Apply pod anti-affinity
        <span class="cov0" title="0">if len(constraints.RequiredPodAntiAffinity) &gt; 0 || len(constraints.PreferredPodAntiAffinity) &gt; 0 </span><span class="cov0" title="0">{
                if spec.Affinity == nil </span><span class="cov0" title="0">{
                        spec.Affinity = &amp;corev1.Affinity{}
                }</span>
                <span class="cov0" title="0">if spec.Affinity.PodAntiAffinity == nil </span><span class="cov0" title="0">{
                        spec.Affinity.PodAntiAffinity = &amp;corev1.PodAntiAffinity{}
                }</span>

                <span class="cov0" title="0">if len(constraints.RequiredPodAntiAffinity) &gt; 0 </span><span class="cov0" title="0">{
                        spec.Affinity.PodAntiAffinity.RequiredDuringSchedulingIgnoredDuringExecution = append(
                                spec.Affinity.PodAntiAffinity.RequiredDuringSchedulingIgnoredDuringExecution,
                                constraints.RequiredPodAntiAffinity...,
                        )
                }</span>
                <span class="cov0" title="0">if len(constraints.PreferredPodAntiAffinity) &gt; 0 </span><span class="cov0" title="0">{
                        spec.Affinity.PodAntiAffinity.PreferredDuringSchedulingIgnoredDuringExecution = append(
                                spec.Affinity.PodAntiAffinity.PreferredDuringSchedulingIgnoredDuringExecution,
                                constraints.PreferredPodAntiAffinity...,
                        )
                }</span>
        }

        // Apply topology spread constraints (additive)
        <span class="cov0" title="0">if len(constraints.TopologySpreadConstraints) &gt; 0 </span><span class="cov0" title="0">{
                spec.TopologySpreadConstraints = append(spec.TopologySpreadConstraints, constraints.TopologySpreadConstraints...)
        }</span>

        // Note: deniedNodes and deniedNodeLabels are advisory constraints
        // They should be enforced via admission webhooks or node anti-affinity rules
        // Here we convert them to node anti-affinity expressions
        <span class="cov0" title="0">if len(constraints.DeniedNodes) &gt; 0 || len(constraints.DeniedNodeLabels) &gt; 0 </span><span class="cov0" title="0">{
                c.log.Debugw("Denied nodes/labels configured",
                        "deniedNodes", constraints.DeniedNodes,
                        "deniedNodeLabels", constraints.DeniedNodeLabels)
                // These are enforced at the admission webhook level for hard blocks
                // For soft enforcement, we could add them as preferredNodeAffinity with negative weight
        }</span>
}

// convertDebugPodSpec converts our DebugPodSpecInner to corev1.PodSpec
func (c *DebugSessionController) convertDebugPodSpec(dps v1alpha1.DebugPodSpecInner) corev1.PodSpec <span class="cov0" title="0">{
        spec := corev1.PodSpec{
                Containers:                dps.Containers,
                InitContainers:            dps.InitContainers,
                Volumes:                   dps.Volumes,
                Tolerations:               dps.Tolerations,
                Affinity:                  dps.Affinity,
                NodeSelector:              dps.NodeSelector,
                HostNetwork:               dps.HostNetwork,
                HostPID:                   dps.HostPID,
                HostIPC:                   dps.HostIPC,
                DNSPolicy:                 dps.DNSPolicy,
                DNSConfig:                 dps.DNSConfig,
                RestartPolicy:             dps.RestartPolicy,
                TopologySpreadConstraints: dps.TopologySpreadConstraints,
                HostAliases:               dps.HostAliases,
                ImagePullSecrets:          dps.ImagePullSecrets,
                Overhead:                  dps.Overhead,
        }

        if dps.SecurityContext != nil </span><span class="cov0" title="0">{
                spec.SecurityContext = dps.SecurityContext
        }</span>
        <span class="cov0" title="0">if dps.AutomountServiceAccountToken != nil </span><span class="cov0" title="0">{
                spec.AutomountServiceAccountToken = dps.AutomountServiceAccountToken
        }</span>
        <span class="cov0" title="0">if dps.ServiceAccountName != "" </span><span class="cov0" title="0">{
                spec.ServiceAccountName = dps.ServiceAccountName
        }</span>
        <span class="cov0" title="0">if dps.TerminationGracePeriodSeconds != nil </span><span class="cov0" title="0">{
                spec.TerminationGracePeriodSeconds = dps.TerminationGracePeriodSeconds
        }</span>
        <span class="cov0" title="0">if dps.PriorityClassName != "" </span><span class="cov0" title="0">{
                spec.PriorityClassName = dps.PriorityClassName
        }</span>
        <span class="cov0" title="0">if dps.RuntimeClassName != nil </span><span class="cov0" title="0">{
                spec.RuntimeClassName = dps.RuntimeClassName
        }</span>
        <span class="cov0" title="0">if dps.PreemptionPolicy != nil </span><span class="cov0" title="0">{
                spec.PreemptionPolicy = dps.PreemptionPolicy
        }</span>
        <span class="cov0" title="0">if dps.ShareProcessNamespace != nil </span><span class="cov0" title="0">{
                spec.ShareProcessNamespace = dps.ShareProcessNamespace
        }</span>
        <span class="cov0" title="0">if dps.EnableServiceLinks != nil </span><span class="cov0" title="0">{
                spec.EnableServiceLinks = dps.EnableServiceLinks
        }</span>
        <span class="cov0" title="0">if dps.SchedulerName != "" </span><span class="cov0" title="0">{
                spec.SchedulerName = dps.SchedulerName
        }</span>

        <span class="cov0" title="0">return spec</span>
}

// updateAllowedPods updates the list of pods users can exec into and monitors pod health
func (c *DebugSessionController) updateAllowedPods(ctx context.Context, ds *v1alpha1.DebugSession) error <span class="cov0" title="0">{
        if c.ccProvider == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">log := c.log.With("debugSession", ds.Name, "namespace", ds.Namespace, "cluster", ds.Spec.Cluster)

        restCfg, err := c.ccProvider.GetRESTConfig(ctx, ds.Spec.Cluster)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">targetClient, err := ctrlclient.New(restCfg, ctrlclient.Options{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // List pods with debug session label
        <span class="cov0" title="0">podList := &amp;corev1.PodList{}
        labelSelector := labels.SelectorFromSet(map[string]string{
                DebugSessionLabelKey: ds.Name,
        })
        if err := targetClient.List(ctx, podList, &amp;ctrlclient.ListOptions{
                LabelSelector: labelSelector,
        }); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">allowedPods := make([]v1alpha1.AllowedPodRef, 0, len(podList.Items))
        for _, pod := range podList.Items </span><span class="cov0" title="0">{
                ready := false
                for _, cond := range pod.Status.Conditions </span><span class="cov0" title="0">{
                        if cond.Type == corev1.PodReady &amp;&amp; cond.Status == corev1.ConditionTrue </span><span class="cov0" title="0">{
                                ready = true
                                break</span>
                        }
                }

                // Monitor pod phase for failures
                <span class="cov0" title="0">c.monitorPodHealth(ctx, ds, &amp;pod, log)

                // Build container status for detailed information
                containerStatus := buildContainerStatus(&amp;pod)

                allowedPods = append(allowedPods, v1alpha1.AllowedPodRef{
                        Namespace:       pod.Namespace,
                        Name:            pod.Name,
                        NodeName:        pod.Spec.NodeName,
                        Ready:           ready,
                        Phase:           string(pod.Status.Phase),
                        ContainerStatus: containerStatus,
                })</span>
        }

        <span class="cov0" title="0">ds.Status.AllowedPods = allowedPods
        return applyDebugSessionStatus(ctx, c.client, ds)</span>
}

// monitorPodHealth checks pod status and emits audit events for failures/restarts
func (c *DebugSessionController) monitorPodHealth(ctx context.Context, ds *v1alpha1.DebugSession, pod *corev1.Pod, log *zap.SugaredLogger) <span class="cov0" title="0">{
        // Check for pod phase failures
        if pod.Status.Phase == corev1.PodFailed </span><span class="cov0" title="0">{
                reason := pod.Status.Reason
                message := pod.Status.Message
                if reason == "" </span><span class="cov0" title="0">{
                        reason = "Unknown"
                }</span>
                <span class="cov0" title="0">if message == "" </span><span class="cov0" title="0">{
                        message = "Pod failed without message"
                }</span>

                <span class="cov0" title="0">log.Warnw("Debug session pod failed",
                        "pod", pod.Name,
                        "podNamespace", pod.Namespace,
                        "reason", reason,
                        "message", message,
                        "node", pod.Spec.NodeName,
                )

                if c.shouldEmitAudit(ds) &amp;&amp; c.auditManager != nil </span><span class="cov0" title="0">{
                        c.auditManager.DebugSessionPodFailed(ctx, ds.Name, ds.Namespace, pod.Name, pod.Namespace, reason, message)
                        c.sendToWebhookDestinations(ctx, ds, "DebugSessionPodFailed", map[string]interface{}{
                                "pod":       pod.Name,
                                "namespace": pod.Namespace,
                                "reason":    reason,
                                "message":   message,
                        })
                }</span>
                <span class="cov0" title="0">metrics.DebugSessionPodFailures.WithLabelValues(ds.Spec.Cluster, ds.Name, reason).Inc()</span>
        }

        // Check container statuses for restarts and failures
        <span class="cov0" title="0">for _, cs := range pod.Status.ContainerStatuses </span><span class="cov0" title="0">{
                // Check for container restarts
                if cs.RestartCount &gt; 0 </span><span class="cov0" title="0">{
                        lastTerminationReason := ""
                        if cs.LastTerminationState.Terminated != nil </span><span class="cov0" title="0">{
                                lastTerminationReason = cs.LastTerminationState.Terminated.Reason
                                if lastTerminationReason == "" </span><span class="cov0" title="0">{
                                        lastTerminationReason = fmt.Sprintf("ExitCode=%d", cs.LastTerminationState.Terminated.ExitCode)
                                }</span>
                        }

                        <span class="cov0" title="0">log.Warnw("Debug session container has restarted",
                                "pod", pod.Name,
                                "podNamespace", pod.Namespace,
                                "container", cs.Name,
                                "restartCount", cs.RestartCount,
                                "lastTerminationReason", lastTerminationReason,
                        )

                        if c.shouldEmitAudit(ds) &amp;&amp; c.auditManager != nil </span><span class="cov0" title="0">{
                                c.auditManager.DebugSessionPodRestarted(ctx, ds.Name, ds.Namespace, pod.Name, pod.Namespace, cs.RestartCount, lastTerminationReason)
                                c.sendToWebhookDestinations(ctx, ds, "DebugSessionPodRestarted", map[string]interface{}{
                                        "pod":                   pod.Name,
                                        "namespace":             pod.Namespace,
                                        "container":             cs.Name,
                                        "restartCount":          cs.RestartCount,
                                        "lastTerminationReason": lastTerminationReason,
                                })
                        }</span>
                        <span class="cov0" title="0">metrics.DebugSessionPodRestarts.WithLabelValues(ds.Spec.Cluster, ds.Name).Inc()</span>
                }

                // Check for waiting state issues (CrashLoopBackOff, ImagePullBackOff, etc.)
                <span class="cov0" title="0">if cs.State.Waiting != nil </span><span class="cov0" title="0">{
                        waitingReason := cs.State.Waiting.Reason
                        waitingMessage := cs.State.Waiting.Message

                        // Log significant waiting states
                        if waitingReason == "CrashLoopBackOff" ||
                                waitingReason == "ImagePullBackOff" ||
                                waitingReason == "ErrImagePull" ||
                                waitingReason == "CreateContainerConfigError" ||
                                waitingReason == "CreateContainerError" </span><span class="cov0" title="0">{
                                log.Warnw("Debug session container in problematic waiting state",
                                        "pod", pod.Name,
                                        "podNamespace", pod.Namespace,
                                        "container", cs.Name,
                                        "waitingReason", waitingReason,
                                        "waitingMessage", waitingMessage,
                                )

                                if c.shouldEmitAudit(ds) &amp;&amp; c.auditManager != nil </span><span class="cov0" title="0">{
                                        c.auditManager.DebugSessionPodFailed(ctx, ds.Name, ds.Namespace, pod.Name, pod.Namespace, waitingReason, waitingMessage)
                                        c.sendToWebhookDestinations(ctx, ds, "DebugSessionPodFailed", map[string]interface{}{
                                                "pod":       pod.Name,
                                                "namespace": pod.Namespace,
                                                "container": cs.Name,
                                                "reason":    waitingReason,
                                                "message":   waitingMessage,
                                        })
                                }</span>
                                <span class="cov0" title="0">metrics.DebugSessionPodFailures.WithLabelValues(ds.Spec.Cluster, ds.Name, waitingReason).Inc()</span>
                        }
                }
        }
}

// buildContainerStatus extracts detailed container state information from a pod
func buildContainerStatus(pod *corev1.Pod) *v1alpha1.PodContainerStatus <span class="cov0" title="0">{
        if len(pod.Status.ContainerStatuses) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Look for the most interesting container status (one with problems)
        <span class="cov0" title="0">var status *v1alpha1.PodContainerStatus
        for _, cs := range pod.Status.ContainerStatuses </span><span class="cov0" title="0">{
                // Check for waiting state issues
                if cs.State.Waiting != nil </span><span class="cov0" title="0">{
                        waitingReason := cs.State.Waiting.Reason
                        // Prioritize problematic waiting states
                        if waitingReason == "CrashLoopBackOff" ||
                                waitingReason == "ImagePullBackOff" ||
                                waitingReason == "ErrImagePull" ||
                                waitingReason == "CreateContainerConfigError" ||
                                waitingReason == "CreateContainerError" ||
                                waitingReason == "ContainerCreating" </span><span class="cov0" title="0">{
                                status = &amp;v1alpha1.PodContainerStatus{
                                        WaitingReason:  waitingReason,
                                        WaitingMessage: cs.State.Waiting.Message,
                                        RestartCount:   cs.RestartCount,
                                }
                                // Get last termination reason if available
                                if cs.LastTerminationState.Terminated != nil </span><span class="cov0" title="0">{
                                        status.LastTerminationReason = cs.LastTerminationState.Terminated.Reason
                                        if status.LastTerminationReason == "" </span><span class="cov0" title="0">{
                                                status.LastTerminationReason = fmt.Sprintf("ExitCode=%d", cs.LastTerminationState.Terminated.ExitCode)
                                        }</span>
                                }
                                // CrashLoopBackOff is most important, return immediately
                                <span class="cov0" title="0">if waitingReason == "CrashLoopBackOff" </span><span class="cov0" title="0">{
                                        return status
                                }</span>
                        }
                }

                // Track restart counts even for running containers
                <span class="cov0" title="0">if cs.RestartCount &gt; 0 &amp;&amp; status == nil </span><span class="cov0" title="0">{
                        status = &amp;v1alpha1.PodContainerStatus{
                                RestartCount: cs.RestartCount,
                        }
                        if cs.LastTerminationState.Terminated != nil </span><span class="cov0" title="0">{
                                status.LastTerminationReason = cs.LastTerminationState.Terminated.Reason
                                if status.LastTerminationReason == "" </span><span class="cov0" title="0">{
                                        status.LastTerminationReason = fmt.Sprintf("ExitCode=%d", cs.LastTerminationState.Terminated.ExitCode)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return status</span>
}

// cleanupResources removes deployed resources from the target cluster
func (c *DebugSessionController) cleanupResources(ctx context.Context, ds *v1alpha1.DebugSession) error <span class="cov0" title="0">{
        log := c.log.With("debugSession", ds.Name, "cluster", ds.Spec.Cluster)

        if c.ccProvider == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Clean up kubectl-debug resources (if any)
        <span class="cov0" title="0">kubectlHandler := NewKubectlDebugHandler(c.client, &amp;clusterClientAdapter{ccProvider: c.ccProvider})
        if err := kubectlHandler.CleanupKubectlDebugResources(ctx, ds); err != nil </span><span class="cov0" title="0">{
                // Check if the error is due to missing ClusterConfig - if so, treat as cleanup complete
                if errors.Is(err, cluster.ErrClusterConfigNotFound) </span><span class="cov0" title="0">{
                        log.Warnw("ClusterConfig no longer exists, treating cleanup as complete (orphaned session)",
                                "cluster", ds.Spec.Cluster)
                        // Clear deployed resources since we can't clean them up anyway
                        ds.Status.DeployedResources = nil
                        ds.Status.AllowedPods = nil
                        return applyDebugSessionStatus(ctx, c.client, ds)
                }</span>
                <span class="cov0" title="0">log.Errorw("Failed to cleanup kubectl-debug resources", "error", err)</span>
                // Continue to clean up deployed resources even if this fails
        }

        // Get spoke cluster client for cleanup
        <span class="cov0" title="0">restCfg, err := c.ccProvider.GetRESTConfig(ctx, ds.Spec.Cluster)
        if err != nil </span><span class="cov0" title="0">{
                // Check if the error is due to missing ClusterConfig - if so, treat as cleanup complete
                if errors.Is(err, cluster.ErrClusterConfigNotFound) </span><span class="cov0" title="0">{
                        log.Warnw("ClusterConfig no longer exists, treating cleanup as complete (orphaned session)",
                                "cluster", ds.Spec.Cluster)
                        // Clear deployed resources since we can't clean them up anyway
                        ds.Status.DeployedResources = nil
                        ds.Status.AllowedPods = nil
                        return applyDebugSessionStatus(ctx, c.client, ds)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to get REST config: %w", err)</span>
        }
        <span class="cov0" title="0">targetClient, err := ctrlclient.New(restCfg, ctrlclient.Options{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create client: %w", err)
        }</span>

        // Cleanup auxiliary resources first using the manager
        <span class="cov0" title="0">if c.auxiliaryMgr != nil &amp;&amp; len(ds.Status.AuxiliaryResourceStatuses) &gt; 0 </span><span class="cov0" title="0">{
                if err := c.auxiliaryMgr.CleanupAuxiliaryResources(ctx, ds, targetClient); err != nil </span><span class="cov0" title="0">{
                        log.Warnw("Failed to cleanup auxiliary resources", "error", err)
                        // Continue to clean up main workloads
                }</span>
        }

        // Cleanup pod template resources (from multi-doc pod templates)
        <span class="cov0" title="0">if len(ds.Status.PodTemplateResourceStatuses) &gt; 0 </span><span class="cov0" title="0">{
                if err := c.cleanupPodTemplateResources(ctx, ds, targetClient); err != nil </span><span class="cov0" title="0">{
                        log.Warnw("Failed to cleanup pod template resources", "error", err)
                        // Continue to clean up main workloads
                }</span>
        }

        <span class="cov0" title="0">if len(ds.Status.DeployedResources) == 0 </span><span class="cov0" title="0">{
                // Persist any status changes from auxiliary/pod-template cleanup above
                return applyDebugSessionStatus(ctx, c.client, ds)
        }</span>

        // Cleanup main workloads (DaemonSet/Deployment)
        <span class="cov0" title="0">for _, ref := range ds.Status.DeployedResources </span><span class="cov0" title="0">{
                // Skip auxiliary resources - already cleaned up by manager
                if strings.HasPrefix(ref.Source, "auxiliary:") </span><span class="cov0" title="0">{
                        continue</span>
                }
                // Skip pod-template resources - already cleaned up above
                <span class="cov0" title="0">if ref.Source == "pod-template" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">var obj ctrlclient.Object

                switch ref.Kind </span>{
                case "DaemonSet":<span class="cov0" title="0">
                        obj = &amp;appsv1.DaemonSet{
                                ObjectMeta: metav1.ObjectMeta{
                                        Name:      ref.Name,
                                        Namespace: ref.Namespace,
                                },
                        }</span>
                case "Deployment":<span class="cov0" title="0">
                        obj = &amp;appsv1.Deployment{
                                ObjectMeta: metav1.ObjectMeta{
                                        Name:      ref.Name,
                                        Namespace: ref.Namespace,
                                },
                        }</span>
                case "ResourceQuota":<span class="cov0" title="0">
                        obj = &amp;corev1.ResourceQuota{
                                ObjectMeta: metav1.ObjectMeta{
                                        Name:      ref.Name,
                                        Namespace: ref.Namespace,
                                },
                        }</span>
                case "PodDisruptionBudget":<span class="cov0" title="0">
                        obj = &amp;policyv1.PodDisruptionBudget{
                                ObjectMeta: metav1.ObjectMeta{
                                        Name:      ref.Name,
                                        Namespace: ref.Namespace,
                                },
                        }</span>
                default:<span class="cov0" title="0">
                        log.Warnw("Unknown resource type, skipping cleanup", "kind", ref.Kind, "name", ref.Name)
                        continue</span>
                }

                <span class="cov0" title="0">if err := targetClient.Delete(ctx, obj); err != nil &amp;&amp; !apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        log.Warnw("Failed to delete debug resource", "kind", ref.Kind, "name", ref.Name, "error", err)
                }</span> else<span class="cov0" title="0"> {
                        log.Infow("Deleted debug resource", "kind", ref.Kind, "name", ref.Name)
                }</span>
        }

        // Clear deployed resources from status
        <span class="cov0" title="0">ds.Status.DeployedResources = nil
        ds.Status.AllowedPods = nil
        ds.Status.PodTemplateResourceStatuses = nil
        return applyDebugSessionStatus(ctx, c.client, ds)</span>
}

// cleanupPodTemplateResources removes resources deployed from multi-document pod templates.
func (c *DebugSessionController) cleanupPodTemplateResources(ctx context.Context, ds *v1alpha1.DebugSession, targetClient ctrlclient.Client) error <span class="cov0" title="0">{
        log := c.log.With("debugSession", ds.Name, "cluster", ds.Spec.Cluster)

        for i := range ds.Status.PodTemplateResourceStatuses </span><span class="cov0" title="0">{
                status := &amp;ds.Status.PodTemplateResourceStatuses[i]

                // Skip if already deleted
                if status.Deleted </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Skip if not created
                <span class="cov0" title="0">if !status.Created </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Create unstructured object for deletion
                <span class="cov0" title="0">gvk, err := parseGVK(status.APIVersion, status.Kind)
                if err != nil </span><span class="cov0" title="0">{
                        log.Warnw("Failed to parse GVK for pod template resource",
                                "apiVersion", status.APIVersion,
                                "kind", status.Kind,
                                "error", err)
                        status.Error = fmt.Sprintf("failed to parse GVK: %v", err)
                        continue</span>
                }

                <span class="cov0" title="0">obj := &amp;unstructured.Unstructured{}
                obj.SetGroupVersionKind(gvk)
                obj.SetName(status.ResourceName)
                obj.SetNamespace(status.Namespace)

                if err := targetClient.Delete(ctx, obj); err != nil </span><span class="cov0" title="0">{
                        if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                                log.Debugw("Pod template resource already deleted",
                                        "kind", status.Kind,
                                        "name", status.ResourceName)
                        }</span> else<span class="cov0" title="0"> {
                                log.Warnw("Failed to delete pod template resource",
                                        "kind", status.Kind,
                                        "name", status.ResourceName,
                                        "error", err)
                                status.Error = fmt.Sprintf("delete failed: %v", err)
                                continue</span>
                        }
                } else<span class="cov0" title="0"> {
                        log.Infow("Deleted pod template resource",
                                "kind", status.Kind,
                                "name", status.ResourceName,
                                "namespace", status.Namespace)
                }</span>

                <span class="cov0" title="0">status.Deleted = true
                now := time.Now().UTC().Format(time.RFC3339)
                status.DeletedAt = &amp;now</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// parseDuration parses the requested duration with template constraints.
// Supports day units (e.g., "1d", "7d") in addition to standard Go duration units.
func (c *DebugSessionController) parseDuration(requested string, constraints *v1alpha1.DebugSessionConstraints) time.Duration <span class="cov0" title="0">{
        defaultDur := time.Hour
        maxDur := 4 * time.Hour

        if constraints != nil </span><span class="cov0" title="0">{
                if d, err := v1alpha1.ParseDuration(constraints.DefaultDuration); err == nil </span><span class="cov0" title="0">{
                        defaultDur = d
                }</span>
                <span class="cov0" title="0">if d, err := v1alpha1.ParseDuration(constraints.MaxDuration); err == nil </span><span class="cov0" title="0">{
                        maxDur = d
                }</span>
        }

        <span class="cov0" title="0">if requested == "" </span><span class="cov0" title="0">{
                return defaultDur
        }</span>

        <span class="cov0" title="0">dur, err := v1alpha1.ParseDuration(requested)
        if err != nil </span><span class="cov0" title="0">{
                return defaultDur
        }</span>

        <span class="cov0" title="0">if dur &gt; maxDur </span><span class="cov0" title="0">{
                return maxDur
        }</span>
        <span class="cov0" title="0">return dur</span>
}

// setupTerminalSharing configures terminal sharing status for the session
func (c *DebugSessionController) setupTerminalSharing(ds *v1alpha1.DebugSession, template *v1alpha1.DebugSessionTemplate) *v1alpha1.TerminalSharingStatus <span class="cov0" title="0">{
        if template.Spec.TerminalSharing == nil || !template.Spec.TerminalSharing.Enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">provider := template.Spec.TerminalSharing.Provider
        if provider == "" </span><span class="cov0" title="0">{
                provider = "tmux"
        }</span>

        // Generate a unique session name
        <span class="cov0" title="0">sessionName := ds.Name
        if len(sessionName) &gt; 32 </span><span class="cov0" title="0">{
                sessionName = sessionName[:32]
        }</span>

        // Build attach command based on provider
        <span class="cov0" title="0">var attachCommand string
        switch provider </span>{
        case "tmux":<span class="cov0" title="0">
                attachCommand = fmt.Sprintf("tmux attach-session -t %s", sessionName)</span>
        case "screen":<span class="cov0" title="0">
                attachCommand = fmt.Sprintf("screen -x %s", sessionName)</span>
        default:<span class="cov0" title="0">
                attachCommand = fmt.Sprintf("tmux attach-session -t %s", sessionName)</span>
        }

        <span class="cov0" title="0">c.log.Infow("Terminal sharing configured",
                "debugSession", ds.Name,
                "provider", provider,
                "sessionName", sessionName)

        return &amp;v1alpha1.TerminalSharingStatus{
                Enabled:       true,
                SessionName:   sessionName,
                AttachCommand: attachCommand,
        }</span>
}

// IsPodInDebugSession checks if a pod belongs to an active debug session
func IsPodInDebugSession(namespace, name string, allowedPods []v1alpha1.AllowedPodRef) bool <span class="cov0" title="0">{
        for _, pod := range allowedPods </span><span class="cov0" title="0">{
                if pod.Namespace == namespace &amp;&amp; pod.Name == name </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// updateTemplateStatus updates the DebugSessionTemplate and DebugPodTemplate status
// to reflect active session counts and usage tracking.
// incrementActive: true when activating a session, false when deactivating (cleanup/expiry)
func (c *DebugSessionController) updateTemplateStatus(ctx context.Context, template *v1alpha1.DebugSessionTemplate, incrementActive bool) error <span class="cov0" title="0">{
        log := c.log.With("template", template.Name)

        // Re-fetch template to get latest version
        currentTemplate := &amp;v1alpha1.DebugSessionTemplate{}
        if err := c.client.Get(ctx, ctrlclient.ObjectKey{Name: template.Name}, currentTemplate); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get template: %w", err)
        }</span>

        // Update active session count
        <span class="cov0" title="0">if incrementActive </span><span class="cov0" title="0">{
                currentTemplate.Status.ActiveSessionCount++
                now := metav1.Now()
                currentTemplate.Status.LastUsedAt = &amp;now
        }</span> else<span class="cov0" title="0"> {
                if currentTemplate.Status.ActiveSessionCount &gt; 0 </span><span class="cov0" title="0">{
                        currentTemplate.Status.ActiveSessionCount--
                }</span>
        }

        // Update the template status using SSA
        <span class="cov0" title="0">if err := ssa.ApplyDebugSessionTemplateStatus(ctx, c.client, currentTemplate); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update template status: %w", err)
        }</span>

        <span class="cov0" title="0">log.Debugw("Updated template status",
                "activeSessionCount", currentTemplate.Status.ActiveSessionCount,
                "lastUsedAt", currentTemplate.Status.LastUsedAt,
                "incrementActive", incrementActive)

        // Also update the DebugPodTemplate.status.usedBy if a pod template is referenced
        if currentTemplate.Spec.PodTemplateRef != nil &amp;&amp; currentTemplate.Spec.PodTemplateRef.Name != "" </span><span class="cov0" title="0">{
                if err := c.updatePodTemplateUsedBy(ctx, currentTemplate.Spec.PodTemplateRef.Name, template.Name); err != nil </span><span class="cov0" title="0">{
                        log.Warnw("Failed to update pod template usedBy", "podTemplate", currentTemplate.Spec.PodTemplateRef.Name, "error", err)
                        // Non-fatal
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// updatePodTemplateUsedBy ensures the DebugPodTemplate.status.usedBy list includes
// the given DebugSessionTemplate name.
func (c *DebugSessionController) updatePodTemplateUsedBy(ctx context.Context, podTemplateName, sessionTemplateName string) error <span class="cov0" title="0">{
        podTemplate := &amp;v1alpha1.DebugPodTemplate{}
        if err := c.client.Get(ctx, ctrlclient.ObjectKey{Name: podTemplateName}, podTemplate); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get pod template: %w", err)
        }</span>

        // Check if already in usedBy list
        <span class="cov0" title="0">for _, name := range podTemplate.Status.UsedBy </span><span class="cov0" title="0">{
                if name == sessionTemplateName </span><span class="cov0" title="0">{
                        return nil // Already tracked
                }</span>
        }

        // Add to usedBy list
        <span class="cov0" title="0">podTemplate.Status.UsedBy = append(podTemplate.Status.UsedBy, sessionTemplateName)

        // Update using SSA
        if err := ssa.ApplyDebugPodTemplateStatus(ctx, c.client, podTemplate); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update pod template status: %w", err)
        }</span>

        <span class="cov0" title="0">c.log.Debugw("Updated pod template usedBy",
                "podTemplate", podTemplateName,
                "addedSessionTemplate", sessionTemplateName,
                "usedBy", podTemplate.Status.UsedBy)

        return nil</span>
}

// Ensure DebugSessionController is a valid interface type
var _ interface {
        GetRESTConfig(ctx context.Context, name string) (*rest.Config, error)
} = (*cluster.ClientProvider)(nil)
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
Copyright 2026.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package breakglass

import (
        "time"

        "github.com/telekom/k8s-breakglass/api/v1alpha1"
        "go.uber.org/zap"
)

// ParseRetainFor parses the RetainFor duration from a session spec.
// Returns DefaultRetainForDuration if the value is empty or invalid.
// Logs a warning if the value is present but invalid.
func ParseRetainFor(spec v1alpha1.BreakglassSessionSpec, log *zap.SugaredLogger) time.Duration <span class="cov8" title="1">{
        return parseDurationWithDefault(spec.RetainFor, DefaultRetainForDuration, "RetainFor", log)
}</span>

// ParseMaxValidFor parses the MaxValidFor duration from a session spec.
// Returns DefaultValidForDuration if the value is empty or invalid.
// Logs a warning if the value is present but invalid.
func ParseMaxValidFor(spec v1alpha1.BreakglassSessionSpec, log *zap.SugaredLogger) time.Duration <span class="cov0" title="0">{
        return parseDurationWithDefault(spec.MaxValidFor, DefaultValidForDuration, "MaxValidFor", log)
}</span>

// ParseEscalationMaxValidFor parses the MaxValidFor duration from an escalation spec.
// Returns DefaultValidForDuration if the value is empty or invalid.
// Logs a warning if the value is present but invalid.
func ParseEscalationMaxValidFor(spec v1alpha1.BreakglassEscalationSpec, log *zap.SugaredLogger) time.Duration <span class="cov0" title="0">{
        return parseDurationWithDefault(spec.MaxValidFor, DefaultValidForDuration, "MaxValidFor", log)
}</span>

// ParseEscalationRetainFor parses the RetainFor duration from an escalation spec.
// Returns DefaultRetainForDuration if the value is empty or invalid.
// Logs a warning if the value is present but invalid.
func ParseEscalationRetainFor(spec v1alpha1.BreakglassEscalationSpec, log *zap.SugaredLogger) time.Duration <span class="cov0" title="0">{
        return parseDurationWithDefault(spec.RetainFor, DefaultRetainForDuration, "RetainFor", log)
}</span>

// ParseApprovalTimeout parses the ApprovalTimeout duration from an escalation spec.
// Returns the default approval timeout (1 hour) if the value is empty or invalid.
// Logs a warning if the value is present but invalid.
func ParseApprovalTimeout(spec v1alpha1.BreakglassEscalationSpec, log *zap.SugaredLogger) time.Duration <span class="cov0" title="0">{
        const defaultApprovalTimeout = time.Hour
        return parseDurationWithDefault(spec.ApprovalTimeout, defaultApprovalTimeout, "ApprovalTimeout", log)
}</span>

// parseDurationWithDefault is the internal helper that parses a duration string.
// If the value is empty, returns defaultValue without logging.
// If the value is present but invalid, logs a warning and returns defaultValue.
// If the value is valid but &lt;= 0, logs a warning and returns defaultValue.
// Supports extended duration units including days (e.g., "7d", "90d").
func parseDurationWithDefault(value string, defaultValue time.Duration, fieldName string, log *zap.SugaredLogger) time.Duration <span class="cov8" title="1">{
        if value == "" </span><span class="cov8" title="1">{
                return defaultValue
        }</span>

        <span class="cov0" title="0">d, err := v1alpha1.ParseDuration(value)
        if err != nil </span><span class="cov0" title="0">{
                if log != nil </span><span class="cov0" title="0">{
                        log.Warnw("Invalid "+fieldName+" in spec; falling back to default",
                                "value", value,
                                "error", err,
                                "default", defaultValue.String())
                }</span>
                <span class="cov0" title="0">return defaultValue</span>
        }

        <span class="cov0" title="0">if d &lt;= 0 </span><span class="cov0" title="0">{
                if log != nil </span><span class="cov0" title="0">{
                        log.Warnw("Non-positive "+fieldName+" in spec; falling back to default",
                                "value", value,
                                "parsedDuration", d,
                                "default", defaultValue.String())
                }</span>
                <span class="cov0" title="0">return defaultValue</span>
        }

        <span class="cov0" title="0">return d</span>
}

// ParseDurationOrDefault is a generic helper for parsing any duration string with a default.
// Useful for one-off duration parsing where the specific field helpers don't apply.
// If log is nil, no warning is logged for invalid values.
func ParseDurationOrDefault(value string, defaultValue time.Duration, fieldName string, log *zap.SugaredLogger) time.Duration <span class="cov0" title="0">{
        return parseDurationWithDefault(value, defaultValue, fieldName, log)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package breakglass

import (
        "context"
        "fmt"

        telekomv1alpha1 "github.com/telekom/k8s-breakglass/api/v1alpha1"
        "go.uber.org/zap"
        "golang.org/x/exp/slices"

        "github.com/telekom/k8s-breakglass/pkg/config"
)

// EscalationFiltering filters given breakglass escalations and sessions based on user their definition
// compared with user assigned groups.
// User assigned groups are extracted using injected function which probably corresponds to `kubectl auth whoami`.
type EscalationFiltering struct {
        Log              *zap.SugaredLogger
        FilterUserData   ClusterUserGroup
        UserGroupExtract func(context.Context, ClusterUserGroup) ([]string, error)
}

// FilterForUserPossibleEscalations filters provided escalations for those that are available based on user assigned
// extractable groups.
func (ef EscalationFiltering) FilterForUserPossibleEscalations(ctx context.Context,
        escalations []telekomv1alpha1.BreakglassEscalation,
) ([]telekomv1alpha1.BreakglassEscalation, error) <span class="cov0" title="0">{
        ef.Log.Debugw("Filtering for user possible escalations", "user", ef.FilterUserData.Username, "cluster", ef.FilterUserData.Clustername, "escalationCount", len(escalations))
        userGroups, err := ef.UserGroupExtract(ctx, ef.FilterUserData)
        if err != nil </span><span class="cov0" title="0">{
                ef.Log.Errorw("Failed to get user groups for escalation filtering", "error", err)
                return nil, fmt.Errorf("failed to get user groups: %w", err)
        }</span>
        <span class="cov0" title="0">ef.Log.Debugw("Retrieved user groups for escalation filtering", "userGroups", userGroups)
        // Load config to determine OIDC prefixes for normalization
        var oidcPrefixes []string
        if cfg, errCfg := config.Load(); errCfg == nil &amp;&amp; len(cfg.Kubernetes.OIDCPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                oidcPrefixes = cfg.Kubernetes.OIDCPrefixes
                // Normalize user groups (strip prefixes if configured)
                userGroups = stripOIDCPrefixes(userGroups, oidcPrefixes)
                ef.Log.Debugw("Normalized user groups with OIDC prefixes", "originalUserGroups", userGroups, "oidcPrefixes", oidcPrefixes)
        }</span>

        <span class="cov0" title="0">groups := make(map[string]any, len(userGroups))
        for _, group := range userGroups </span><span class="cov0" title="0">{
                groups[group] = struct{}{}
        }</span>

        <span class="cov0" title="0">isEscalationForUser := func(esc telekomv1alpha1.BreakglassEscalation) bool </span><span class="cov0" title="0">{
                clusterMatch := clusterMatchesPatterns(ef.FilterUserData.Clustername, esc.Spec.Allowed.Clusters)
                ef.Log.Debugw("Checking cluster match for escalation", "escalation", esc.Name, "requiredClusters", esc.Spec.Allowed.Clusters, "userCluster", ef.FilterUserData.Clustername, "clusterMatch", clusterMatch)
                return clusterMatch
        }</span>

        <span class="cov0" title="0">possible := make([]telekomv1alpha1.BreakglassEscalation, 0, len(escalations))
        for _, esc := range escalations </span><span class="cov0" title="0">{
                // Normalize escalation allowed groups the same way as user groups for fair comparison
                normalizedAllowedGroups := esc.Spec.Allowed.Groups
                if len(oidcPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                        normalizedAllowedGroups = stripOIDCPrefixes(normalizedAllowedGroups, oidcPrefixes)
                }</span>
                <span class="cov0" title="0">clusterEligible := isEscalationForUser(esc)
                groupEligible := intersects(groups, normalizedAllowedGroups)

                ef.Log.Debugw("Evaluating escalation eligibility",
                        "escalation", esc.Name,
                        "clusterEligible", clusterEligible,
                        "groupEligible", groupEligible,
                        "requiredGroups", esc.Spec.Allowed.Groups,
                        "normalizedRequiredGroups", normalizedAllowedGroups,
                        "userGroups", userGroups)

                if clusterEligible &amp;&amp; groupEligible </span><span class="cov0" title="0">{
                        ef.Log.Debugw("Escalation is possible for user", "escalation", esc.Name)
                        possible = append(possible, esc)
                }</span> else<span class="cov0" title="0"> {
                        ef.Log.Debugw("Escalation not possible for user",
                                "escalation", esc.Name,
                                "clusterEligible", clusterEligible,
                                "groupEligible", groupEligible)
                }</span>
        }

        <span class="cov0" title="0">ef.Log.Infow("Filtered possible escalations", "possibleCount", len(possible))
        return possible, nil</span>
}

// FilterSessionsForUserApprovable filters sessions for the ones that filter user
// could approve, based on provided escalations joined with user extracted groups.
func (ef EscalationFiltering) FilterSessionsForUserApprovable(ctx context.Context,
        sessions []telekomv1alpha1.BreakglassSession,
        escalations []telekomv1alpha1.BreakglassEscalation,
) ([]telekomv1alpha1.BreakglassSession, error) <span class="cov0" title="0">{
        ef.Log.Debugw("Filtering sessions for user approvable", "user", ef.FilterUserData.Username, "cluster", ef.FilterUserData.Clustername, "sessionCount", len(sessions), "escalationCount", len(escalations))
        userGroups, err := ef.UserGroupExtract(ctx, ef.FilterUserData)
        if err != nil </span><span class="cov0" title="0">{
                ef.Log.Errorw("Failed to get user rbac cluster groups for session filtering", "error", err)
                return nil, fmt.Errorf("failed to get user rbac cluster groups: %w", err)
        }</span>
        <span class="cov0" title="0">ef.Log.Debugw("Retrieved user groups for session filtering", "userGroups", userGroups)

        userCluserGroups := map[string]any{}
        for _, g := range userGroups </span><span class="cov0" title="0">{
                userCluserGroups[g] = struct{}{}
        }</span>

        <span class="cov0" title="0">displayable := []telekomv1alpha1.BreakglassSession{}

        for _, ses := range sessions </span><span class="cov0" title="0">{
                ef.Log.Debugw("Processing session for approvability", "session", ses.Name, "requestedGroup", ses.Spec.GrantedGroup)
                sessionApprovable := false

                for _, esc := range escalations </span><span class="cov0" title="0">{
                        if ses.Spec.GrantedGroup != esc.Spec.EscalatedGroup ||
                                !clusterMatchesPatterns(ses.Spec.Cluster, esc.Spec.Allowed.Clusters) </span><span class="cov0" title="0">{
                                ef.Log.Debugw("Session-escalation mismatch", "session", ses.Name, "escalation", esc.Name, "sessionGroup", ses.Spec.GrantedGroup, "escalationGroup", esc.Spec.EscalatedGroup)
                                continue</span>
                        }

                        <span class="cov0" title="0">if slices.Contains(esc.Spec.Approvers.Users, ef.FilterUserData.Username) </span><span class="cov0" title="0">{
                                ef.Log.Debugw("Session approvable by user directly", "session", ses.Name, "escalation", esc.Name, "user", ef.FilterUserData.Username)
                                displayable = append(displayable, ses)
                                sessionApprovable = true
                                break</span>
                        } else<span class="cov0" title="0"> if intersects(userCluserGroups, esc.Spec.Approvers.Groups) </span><span class="cov0" title="0">{
                                ef.Log.Debugw("Session approvable by user group", "session", ses.Name, "escalation", esc.Name, "userGroups", userGroups, "approverGroups", esc.Spec.Approvers.Groups)
                                displayable = append(displayable, ses)
                                sessionApprovable = true
                                break</span>
                        } else<span class="cov0" title="0"> {
                                ef.Log.Debugw("Session not approvable by user for this escalation", "session", ses.Name, "escalation", esc.Name, "userGroups", userGroups, "approverGroups", esc.Spec.Approvers.Groups)
                        }</span>
                }

                <span class="cov0" title="0">if !sessionApprovable </span><span class="cov0" title="0">{
                        ef.Log.Debugw("Session not approvable by user", "session", ses.Name)
                }</span>
        }
        <span class="cov0" title="0">ef.Log.Infow("Filtered approvable sessions", "approvableCount", len(displayable))
        return displayable, nil</span>
}

func intersects(amap map[string]any, b []string) bool <span class="cov0" title="0">{
        for _, v := range b </span><span class="cov0" title="0">{
                if _, has := amap[v]; has </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package breakglass

import (
        "context"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/telekom/k8s-breakglass/api/v1alpha1"
        apiresponses "github.com/telekom/k8s-breakglass/pkg/apiresponses"
        "github.com/telekom/k8s-breakglass/pkg/config"
        "github.com/telekom/k8s-breakglass/pkg/metrics"
        "github.com/telekom/k8s-breakglass/pkg/system"
        "go.uber.org/zap"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type BreakglassEscalationController struct {
        manager          *EscalationManager
        log              *zap.SugaredLogger
        middleware       gin.HandlerFunc
        identityProvider IdentityProvider
        getUserGroupsFn  GetUserGroupsFunction
        configPath       string // Path to breakglass config file for OIDC prefix stripping
}

// dropK8sInternalFieldsEscalation removes K8s internal fields from BreakglassEscalation for API response
func dropK8sInternalFieldsEscalation(e *v1alpha1.BreakglassEscalation) <span class="cov0" title="0">{
        if e == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">e.ManagedFields = nil
        e.UID = ""
        e.ResourceVersion = ""
        e.Generation = 0
        if e.Annotations != nil </span><span class="cov0" title="0">{
                delete(e.Annotations, "kubectl.kubernetes.io/last-applied-configuration")
        }</span>
        <span class="cov0" title="0">e.Status.ApproverGroupMembers = nil
        e.Status.IDPGroupMemberships = nil</span>
}

func dropK8sInternalFieldsEscalationList(list []v1alpha1.BreakglassEscalation) []v1alpha1.BreakglassEscalation <span class="cov0" title="0">{
        for i := range list </span><span class="cov0" title="0">{
                dropK8sInternalFieldsEscalation(&amp;list[i])
        }</span>
        <span class="cov0" title="0">return list</span>
}
func (ec *BreakglassEscalationController) Register(rg *gin.RouterGroup) error <span class="cov0" title="0">{
        basePath := ec.BasePath()
        ec.log.With("basePath", basePath).Info("Registering escalation controller endpoints (RESTful)")
        rg.GET("", instrumentedHandler("handleGetEscalations", ec.handleGetEscalations))
        ec.log.With("endpoint", basePath).Debug("Escalation endpoint registered successfully (RESTful)")
        return nil
}</span>

func (ec BreakglassEscalationController) handleGetEscalations(c *gin.Context) <span class="cov0" title="0">{
        // Get correlation ID for consistent logging
        reqLog := system.GetReqLogger(c, ec.log)
        reqLog = system.EnrichReqLoggerWithAuth(c, reqLog)
        reqLog.Info("Processing escalations request")
        metrics.APIEndpointRequests.WithLabelValues("handleGetEscalations").Inc()

        // Parse query parameters for filtering
        clusterFilter := c.Query("cluster")
        activeOnly := parseBoolQuery(c.Query("activeOnly"), false)

        email, err := ec.identityProvider.GetEmail(c)
        if err != nil </span><span class="cov0" title="0">{
                reqLog.With("error", err).Error("Failed to extract user email from authentication token")
                metrics.APIEndpointErrors.WithLabelValues("handleGetEscalations", "500").Inc()
                apiresponses.RespondInternalErrorSimple(c, "failed to extract user identity")
                return
        }</span>
        <span class="cov0" title="0">reqLog.With("email", email).Debug("Successfully extracted user email from token")

        // Attempt to resolve groups from token first (preferred) then fallback to cluster-based resolution
        var userGroups []string
        // Raw token groups (pre-normalization) for trace diagnostics
        if raw, exists := c.Get("groups"); exists </span><span class="cov0" title="0">{
                if arr, ok := raw.([]string); ok </span><span class="cov0" title="0">{
                        reqLog.With("rawTokenGroups", arr, "rawTokenGroupCount", len(arr)).Debug("Extracted raw token groups from JWT claims")
                }</span>
        }
        <span class="cov0" title="0">if tg, exists := c.Get("groups"); exists </span><span class="cov0" title="0">{
                if arr, ok := tg.([]string); ok </span><span class="cov0" title="0">{
                        userGroups = append(userGroups, arr...)
                }</span>
        }
        <span class="cov0" title="0">if len(userGroups) == 0 </span><span class="cov0" title="0">{ // fallback
                userContext := ClusterUserGroup{Username: email}
                var gerr error
                userGroups, gerr = ec.getUserGroupsFn(c.Request.Context(), userContext)
                if gerr != nil </span><span class="cov0" title="0">{
                        reqLog.With("error", gerr.Error(), "user", email).Error("Failed to retrieve user groups for escalation determination")
                        metrics.APIEndpointErrors.WithLabelValues("handleGetEscalations", "500").Inc()
                        apiresponses.RespondInternalErrorSimple(c, "failed to extract user groups")
                        return
                }</span>
        }

        // Apply OIDC prefix stripping if configured (token groups will not have the prefix; cluster groups might)
        <span class="cov0" title="0">if cfg, cerr := config.Load(ec.configPath); cerr == nil &amp;&amp; len(cfg.Kubernetes.OIDCPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                userGroups = stripOIDCPrefixes(userGroups, cfg.Kubernetes.OIDCPrefixes)
        }</span> else<span class="cov0" title="0"> if cerr != nil </span><span class="cov0" title="0">{
                // Avoid logging wrapped errors (which may include stack traces). Log a concise message only.
                reqLog.With("error", cerr.Error()).Debug("Continuing without OIDC prefix stripping")
        }</span>
        <span class="cov0" title="0">reqLog.With("userGroups", userGroups, "groupCount", len(userGroups)).Debug("Resolved user groups (token first)")

        escalations, err := ec.manager.GetGroupBreakglassEscalations(c.Request.Context(), userGroups)
        if err != nil </span><span class="cov0" title="0">{
                reqLog.With("error", err.Error()).Error("Failed to retrieve escalations from manager")
                metrics.APIEndpointErrors.WithLabelValues("handleGetEscalations", "500").Inc()
                apiresponses.RespondInternalErrorSimple(c, "failed to extract user escalations")
                return
        }</span>
        <span class="cov0" title="0">reqLog.With("escalationCount", len(escalations)).Debug("Successfully fetched escalations from manager")

        // Policy: hide "read-only" escalation if user already possesses the read-only group (no privilege gain)
        filtered := make([]v1alpha1.BreakglassEscalation, 0, len(escalations))
        userGroupSet := map[string]struct{}{}
        for _, g := range userGroups </span><span class="cov0" title="0">{
                userGroupSet[g] = struct{}{}
        }</span>

        // Apply cluster and activeOnly filters
        <span class="cov0" title="0">for _, esc := range escalations </span><span class="cov0" title="0">{
                // Filter by cluster if specified
                if clusterFilter != "" </span><span class="cov0" title="0">{
                        if !escalationMatchesCluster(esc, clusterFilter) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                // Filter by active status if requested
                <span class="cov0" title="0">if activeOnly </span><span class="cov0" title="0">{
                        if !isEscalationReady(&amp;esc) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                <span class="cov0" title="0">filtered = append(filtered, esc)</span>
        }

        // Return full objects including (future) status with approverGroupMembers for UI
        <span class="cov0" title="0">response := make([]v1alpha1.BreakglassEscalation, 0, len(filtered))
        response = append(response, filtered...)

        // Filter out hidden groups from the response - they should not be visible to users in the UI
        for i := range response </span><span class="cov0" title="0">{
                if len(response[i].Spec.Approvers.HiddenFromUI) &gt; 0 </span><span class="cov0" title="0">{
                        // Build set of hidden items for quick lookup
                        hiddenSet := make(map[string]bool)
                        for _, item := range response[i].Spec.Approvers.HiddenFromUI </span><span class="cov0" title="0">{
                                hiddenSet[item] = true
                        }</span>

                        // Filter out hidden groups and users from the visible approvers
                        <span class="cov0" title="0">filteredGroups := []string{}
                        for _, group := range response[i].Spec.Approvers.Groups </span><span class="cov0" title="0">{
                                if !hiddenSet[group] </span><span class="cov0" title="0">{
                                        filteredGroups = append(filteredGroups, group)
                                }</span>
                        }

                        <span class="cov0" title="0">filteredUsers := []string{}
                        for _, user := range response[i].Spec.Approvers.Users </span><span class="cov0" title="0">{
                                if !hiddenSet[user] </span><span class="cov0" title="0">{
                                        filteredUsers = append(filteredUsers, user)
                                }</span>
                        }

                        // Update the response with filtered approvers
                        <span class="cov0" title="0">response[i].Spec.Approvers.Groups = filteredGroups
                        response[i].Spec.Approvers.Users = filteredUsers

                        // Remove HiddenFromUI field from response (client doesn't need to see it)
                        response[i].Spec.Approvers.HiddenFromUI = nil</span>
                }
        }

        <span class="cov0" title="0">reqLog.With("responseCount", len(response)).Debug("Returning escalations response (filtered, hidden groups removed)")
        c.JSON(http.StatusOK, dropK8sInternalFieldsEscalationList(response))</span>
}

func (BreakglassEscalationController) BasePath() string <span class="cov0" title="0">{
        return "breakglassEscalations"
}</span>

func (b BreakglassEscalationController) Handlers() []gin.HandlerFunc <span class="cov0" title="0">{
        return []gin.HandlerFunc{b.middleware}
}</span>

func NewBreakglassEscalationController(log *zap.SugaredLogger,
        manager *EscalationManager,
        middleware gin.HandlerFunc,
        configPath string,
) *BreakglassEscalationController <span class="cov0" title="0">{
        log.Debug("Initializing BreakglassEscalationController with Keycloak identity provider")

        identityProvider := KeycloakIdentityProvider{log: log}
        log.Debug("KeycloakIdentityProvider configured for user identity extraction")

        controller := &amp;BreakglassEscalationController{
                log:              log,
                manager:          manager,
                middleware:       middleware,
                identityProvider: identityProvider,
                getUserGroupsFn: func(ctx context.Context, cug ClusterUserGroup) ([]string, error) </span><span class="cov0" title="0">{
                        return GetUserGroupsWithConfig(ctx, cug, configPath)
                }</span>,
                configPath: configPath,
        }

        <span class="cov0" title="0">log.Debug("BreakglassEscalationController initialization completed successfully")
        return controller</span>
}

// isEscalationReady checks if an escalation has Ready=True condition.
func isEscalationReady(esc *v1alpha1.BreakglassEscalation) bool <span class="cov0" title="0">{
        for _, cond := range esc.Status.Conditions </span><span class="cov0" title="0">{
                if cond.Type == "Ready" &amp;&amp; cond.Status == metav1.ConditionTrue </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package breakglass

import (
        "context"
        "fmt"
        "path/filepath"
        "slices"
        "sync"

        telekomv1alpha1 "github.com/telekom/k8s-breakglass/api/v1alpha1"
        "github.com/telekom/k8s-breakglass/pkg/system"
        "go.uber.org/zap"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/fields"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/client/config"

        cfgpkg "github.com/telekom/k8s-breakglass/pkg/config"
        "github.com/telekom/k8s-breakglass/pkg/metrics"
)

type EscalationManager struct {
        client.Client
        resolver     GroupMemberResolver  // Protected by resolverMu - use GetResolver/SetResolver
        resolverMu   sync.RWMutex         // Protects concurrent access to resolver field
        log          *zap.SugaredLogger   // Injected logger (falls back to global if nil)
        configLoader *cfgpkg.CachedLoader // Cached config loader to avoid disk reads per request
}

// GetResolver returns the current GroupMemberResolver in a thread-safe manner.
func (em *EscalationManager) GetResolver() GroupMemberResolver <span class="cov0" title="0">{
        em.resolverMu.RLock()
        defer em.resolverMu.RUnlock()
        return em.resolver
}</span>

// getLogger returns the injected logger or falls back to the global logger.
func (em *EscalationManager) getLogger() *zap.SugaredLogger <span class="cov0" title="0">{
        if em.log != nil </span><span class="cov0" title="0">{
                return em.log
        }</span>
        <span class="cov0" title="0">return zap.S()</span>
}

// getConfig returns config from the cached loader or falls back to disk read.
// Logs a warning when falling back to avoid per-request disk I/O.
func (em *EscalationManager) getConfig() (cfgpkg.Config, error) <span class="cov0" title="0">{
        if em.configLoader != nil </span><span class="cov0" title="0">{
                return em.configLoader.Get()
        }</span>
        // Fallback: log warning and load from disk (this should be avoided in production)
        <span class="cov0" title="0">em.getLogger().Warn("EscalationManager: configLoader not set, falling back to disk read (performance impact)")
        return cfgpkg.Load()</span>
}

// Get all stored BreakglassEscalations
func (em *EscalationManager) GetAllBreakglassEscalations(ctx context.Context) ([]telekomv1alpha1.BreakglassEscalation, error) <span class="cov0" title="0">{
        log := em.getLogger()
        log.Debug("Fetching all BreakglassEscalations")
        metrics.APIEndpointRequests.WithLabelValues("GetAllBreakglassEscalations").Inc()
        escal := telekomv1alpha1.BreakglassEscalationList{}
        if err := em.List(ctx, &amp;escal); err != nil </span><span class="cov0" title="0">{
                log.Errorw("Failed to get BreakglassEscalationList", "error", err)
                return nil, fmt.Errorf("failed to get BreakglassEscalationList: %w", err)
        }</span>
        <span class="cov0" title="0">log.Infow("Fetched BreakglassEscalations", "count", len(escal.Items))
        return escal.Items, nil</span>
}

func (em *EscalationManager) GetBreakglassEscalationsWithFilter(ctx context.Context,
        filter func(telekomv1alpha1.BreakglassEscalation) bool,
) ([]telekomv1alpha1.BreakglassEscalation, error) <span class="cov0" title="0">{
        log := em.getLogger()
        log.Debug("Fetching BreakglassEscalations with filter")
        metrics.APIEndpointRequests.WithLabelValues("GetBreakglassEscalationsWithFilter").Inc()
        ess := telekomv1alpha1.BreakglassEscalationList{}

        if err := em.List(ctx, &amp;ess); err != nil </span><span class="cov0" title="0">{
                log.Errorw("Failed to list BreakglassEscalation for filtered get", "error", err)
                return nil, fmt.Errorf("failed to list BreakglassEscalation for filtered get: %w", err)
        }</span>
        <span class="cov0" title="0">log.Debugw("Retrieved escalations for filtering", "totalCount", len(ess.Items))

        output := make([]telekomv1alpha1.BreakglassEscalation, 0, len(ess.Items))
        for _, it := range ess.Items </span><span class="cov0" title="0">{
                if filter(it) </span><span class="cov0" title="0">{
                        log.Debugw("Escalation matched filter", system.NamespacedFields(it.Name, it.Namespace)...)
                        output = append(output, it)
                }</span> else<span class="cov0" title="0"> {
                        log.Debugw("Escalation did not match filter", system.NamespacedFields(it.Name, it.Namespace)...)
                }</span>
        }

        <span class="cov0" title="0">log.Infow("Filtered BreakglassEscalations", "count", len(output), "totalEvaluated", len(ess.Items))
        return output, nil</span>
}

// GetBreakglassEscalationsWithSelector with custom field selector.
func (em *EscalationManager) GetBreakglassEscalationsWithSelector(ctx context.Context,
        fs fields.Selector,
) ([]telekomv1alpha1.BreakglassEscalation, error) <span class="cov0" title="0">{
        log := em.getLogger()
        log.Debugw("Fetching BreakglassEscalations with selector", "selector", fs.String())
        metrics.APIEndpointRequests.WithLabelValues("GetBreakglassEscalationsWithSelector").Inc()
        ess := telekomv1alpha1.BreakglassEscalationList{}

        if err := em.List(ctx, &amp;ess, &amp;client.ListOptions{FieldSelector: fs}); err != nil </span><span class="cov0" title="0">{
                log.Errorw("Failed to list BreakglassEscalation with selector", "selector", fs.String(), "error", err)
                return nil, fmt.Errorf("failed to list BreakglassEscalation with selector: %w", err)
        }</span>

        <span class="cov0" title="0">log.Infow("Fetched BreakglassEscalations with selector", "count", len(ess.Items), "selector", fs.String())
        return ess.Items, nil</span>
}

// GetBreakglassEscalation retrieves a single BreakglassEscalation by namespace/name using the cached controller-runtime client.
// Prefer this over filter-based scans when the owner reference is known to minimize cache iterations.
func (em *EscalationManager) GetBreakglassEscalation(ctx context.Context, namespace, name string) (*telekomv1alpha1.BreakglassEscalation, error) <span class="cov0" title="0">{
        log := em.getLogger()
        log.Debugw("Fetching BreakglassEscalation by name", "namespace", namespace, "name", name)
        metrics.APIEndpointRequests.WithLabelValues("GetBreakglassEscalation").Inc()
        got := &amp;telekomv1alpha1.BreakglassEscalation{}
        if err := em.Get(ctx, client.ObjectKey{Namespace: namespace, Name: name}, got); err != nil </span><span class="cov0" title="0">{
                status := "500"
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        status = "404"
                }</span>
                <span class="cov0" title="0">metrics.APIEndpointErrors.WithLabelValues("GetBreakglassEscalation", status).Inc()
                return nil, fmt.Errorf("failed to get BreakglassEscalation %s/%s: %w", namespace, name, err)</span>
        }
        <span class="cov0" title="0">return got, nil</span>
}

// GetGroupBreakglassEscalations returns escalations available to users in the specified groups
func (em *EscalationManager) GetGroupBreakglassEscalations(ctx context.Context,
        groups []string,
) ([]telekomv1alpha1.BreakglassEscalation, error) <span class="cov0" title="0">{
        log := em.getLogger()
        log.Debugw("Fetching group BreakglassEscalations", "groups", groups)
        metrics.APIEndpointRequests.WithLabelValues("GetGroupBreakglassEscalations").Inc()
        // First try index-based lookup for each group and collect results (deduped)
        collectedMap := map[string]telekomv1alpha1.BreakglassEscalation{}
        for _, g := range groups </span><span class="cov0" title="0">{
                list := telekomv1alpha1.BreakglassEscalationList{}
                if err := em.List(ctx, &amp;list, client.MatchingFields{"spec.allowed.group": g}); err == nil </span><span class="cov0" title="0">{
                        log.Debugw("Index lookup for group returned items", "group", g, "count", len(list.Items))
                        for _, it := range list.Items </span><span class="cov0" title="0">{
                                // apply group normalization check to be safe (fake client may ignore MatchingFields)
                                allowed := it.Spec.Allowed.Groups
                                // normalize OIDC prefixes for comparison
                                normAllowed := allowed
                                if cfg, err := em.getConfig(); err == nil &amp;&amp; len(cfg.Kubernetes.OIDCPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                                        normAllowed = stripOIDCPrefixes(allowed, cfg.Kubernetes.OIDCPrefixes)
                                }</span>
                                <span class="cov0" title="0">if slices.Contains(normAllowed, g) </span><span class="cov0" title="0">{
                                        collectedMap[it.Namespace+"/"+it.Name] = it
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">if len(collectedMap) &gt; 0 </span><span class="cov0" title="0">{
                collected := make([]telekomv1alpha1.BreakglassEscalation, 0, len(collectedMap))
                for _, v := range collectedMap </span><span class="cov0" title="0">{
                        collected = append(collected, v)
                }</span>
                <span class="cov0" title="0">return collected, nil</span>
        }

        // Fallback to full filter if indices not available or returned nothing
        <span class="cov0" title="0">var oidcPrefixes []string
        if cfg, err := em.getConfig(); err == nil &amp;&amp; len(cfg.Kubernetes.OIDCPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                oidcPrefixes = cfg.Kubernetes.OIDCPrefixes
                log.Debugw("Loaded OIDC prefixes for group normalization", "prefixes", oidcPrefixes)
        }</span>
        <span class="cov0" title="0">return em.GetBreakglassEscalationsWithFilter(ctx, func(be telekomv1alpha1.BreakglassEscalation) bool </span><span class="cov0" title="0">{
                allowedGroups := be.Spec.Allowed.Groups
                if len(oidcPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                        allowedGroups = stripOIDCPrefixes(allowedGroups, oidcPrefixes)
                }</span>
                <span class="cov0" title="0">for _, group := range groups </span><span class="cov0" title="0">{
                        if slices.Contains(allowedGroups, group) </span><span class="cov0" title="0">{
                                log.Debugw("Escalation matches user group", append(system.NamespacedFields(be.Name, ""), "matchingGroup", group, "allowedGroups", be.Spec.Allowed.Groups, "normalizedAllowedGroups", allowedGroups)...)
                                return true
                        }</span>
                }
                <span class="cov0" title="0">log.Debugw("Escalation does not match any user groups", append(system.NamespacedFields(be.Name, ""), "userGroups", groups, "allowedGroups", be.Spec.Allowed.Groups, "normalizedAllowedGroups", allowedGroups)...)
                return false</span>
        })
}

// collectClusterEscalations queries the index for escalations matching a specific cluster
// and global "*" patterns. Returns combined results (may be empty if no index hits).
func (em *EscalationManager) collectClusterEscalations(ctx context.Context, cluster string) []telekomv1alpha1.BreakglassEscalation <span class="cov0" title="0">{
        collected := make([]telekomv1alpha1.BreakglassEscalation, 0)
        seen := make(map[string]struct{})
        addUnique := func(items []telekomv1alpha1.BreakglassEscalation) </span><span class="cov0" title="0">{
                for _, item := range items </span><span class="cov0" title="0">{
                        key := item.Namespace + "/" + item.Name
                        if _, exists := seen[key]; !exists </span><span class="cov0" title="0">{
                                seen[key] = struct{}{}
                                collected = append(collected, item)
                        }</span>
                }
        }
        <span class="cov0" title="0">list := telekomv1alpha1.BreakglassEscalationList{}
        if err := em.List(ctx, &amp;list, client.MatchingFields{"spec.allowed.cluster": cluster}); err == nil &amp;&amp; len(list.Items) &gt; 0 </span><span class="cov0" title="0">{
                addUnique(list.Items)
        }</span>
        <span class="cov0" title="0">globalList := telekomv1alpha1.BreakglassEscalationList{}
        if err := em.List(ctx, &amp;globalList, client.MatchingFields{"spec.allowed.cluster": "*"}); err == nil &amp;&amp; len(globalList.Items) &gt; 0 </span><span class="cov0" title="0">{
                addUnique(globalList.Items)
        }</span>
        <span class="cov0" title="0">return collected</span>
}

// GetClusterBreakglassEscalations returns escalations that apply to a specific cluster.
// Supports glob patterns in both Allowed.Clusters and ClusterConfigRefs fields.
func (em *EscalationManager) GetClusterBreakglassEscalations(ctx context.Context, cluster string) ([]telekomv1alpha1.BreakglassEscalation, error) <span class="cov0" title="0">{
        em.getLogger().Debugw("Fetching cluster BreakglassEscalations", "cluster", cluster)
        metrics.APIEndpointRequests.WithLabelValues("GetClusterBreakglassEscalations").Inc()

        // Try index-based lookup for exact cluster match and global "*" pattern
        collected := em.collectClusterEscalations(ctx, cluster)

        // If index returned results, filter using shared helper and return
        if len(collected) &gt; 0 </span><span class="cov0" title="0">{
                out := make([]telekomv1alpha1.BreakglassEscalation, 0)
                for _, be := range collected </span><span class="cov0" title="0">{
                        if escalationMatchesCluster(be, cluster) </span><span class="cov0" title="0">{
                                out = append(out, be)
                        }</span>
                }
                <span class="cov0" title="0">if len(out) &gt; 0 </span><span class="cov0" title="0">{
                        return out, nil
                }</span>
        }

        // Fallback to filter-based scan for glob patterns
        <span class="cov0" title="0">return em.GetBreakglassEscalationsWithFilter(ctx, func(be telekomv1alpha1.BreakglassEscalation) bool </span><span class="cov0" title="0">{
                return escalationMatchesCluster(be, cluster)
        }</span>)
}

// matchesGlobPattern checks if a pattern matches a value using filepath.Match glob semantics.
// Returns false if the pattern is invalid.
func matchesGlobPattern(pattern, value string) bool <span class="cov0" title="0">{
        matched, err := filepath.Match(pattern, value)
        return err == nil &amp;&amp; matched
}</span>

// clusterMatchesPatterns checks if a cluster name matches any pattern in the list.
// Supports exact matches and glob patterns (*, ?, [abc], etc.).
func clusterMatchesPatterns(cluster string, patterns []string) bool <span class="cov0" title="0">{
        for _, pattern := range patterns </span><span class="cov0" title="0">{
                if pattern == cluster || matchesGlobPattern(pattern, cluster) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// escalationMatchesCluster checks if an escalation applies to a given cluster.
// Both Allowed.Clusters and ClusterConfigRefs are checked with glob pattern support.
// Empty values in both fields means the escalation applies to no clusters (use "*" for global).
func escalationMatchesCluster(be telekomv1alpha1.BreakglassEscalation, cluster string) bool <span class="cov0" title="0">{
        return clusterMatchesPatterns(cluster, be.Spec.Allowed.Clusters) ||
                clusterMatchesPatterns(cluster, be.Spec.ClusterConfigRefs)
}</span>

// getOIDCPrefixes retrieves OIDC prefixes from config, returning nil on error.
// This is a convenience helper that handles config loading errors gracefully.
func (em *EscalationManager) getOIDCPrefixes() []string <span class="cov0" title="0">{
        cfg, err := em.getConfig()
        if err == nil &amp;&amp; len(cfg.Kubernetes.OIDCPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                return cfg.Kubernetes.OIDCPrefixes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// normalizeAndMatchGroups checks if any of the user's groups match the escalation's allowed groups.
// Handles OIDC prefix stripping when configured.
func groupsMatch(userGroups, allowedGroups, oidcPrefixes []string) bool <span class="cov0" title="0">{
        normalized := allowedGroups
        if len(oidcPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                normalized = stripOIDCPrefixes(allowedGroups, oidcPrefixes)
        }</span>
        <span class="cov0" title="0">for _, g := range userGroups </span><span class="cov0" title="0">{
                if slices.Contains(normalized, g) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// GetClusterGroupBreakglassEscalations returns escalations for specific cluster and user groups
func (em *EscalationManager) GetClusterGroupBreakglassEscalations(ctx context.Context, cluster string, groups []string) ([]telekomv1alpha1.BreakglassEscalation, error) <span class="cov0" title="0">{
        em.getLogger().Debugw("Fetching cluster-group BreakglassEscalations", "cluster", cluster, "groups", groups)
        metrics.APIEndpointRequests.WithLabelValues("GetClusterGroupBreakglassEscalations").Inc()

        // Try index-based lookup first for exact cluster matches and global "*" pattern
        collected := em.collectClusterEscalations(ctx, cluster)

        // If index returned nothing, fall back to scanning all escalations for glob patterns
        if len(collected) == 0 </span><span class="cov0" title="0">{
                all, err := em.GetAllBreakglassEscalations(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">collected = all</span>
        }

        // Filter collected by cluster matching and groups using shared helpers
        <span class="cov0" title="0">oidcPrefixes := em.getOIDCPrefixes()
        out := make([]telekomv1alpha1.BreakglassEscalation, 0)
        for _, be := range collected </span><span class="cov0" title="0">{
                if !escalationMatchesCluster(be, cluster) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if groupsMatch(groups, be.Spec.Allowed.Groups, oidcPrefixes) </span><span class="cov0" title="0">{
                        out = append(out, be)
                }</span>
        }
        <span class="cov0" title="0">return out, nil</span>
}

// GetClusterGroupTargetBreakglassEscalation returns escalations for specific cluster, user groups, and target group
func (em *EscalationManager) GetClusterGroupTargetBreakglassEscalation(ctx context.Context, cluster string, userGroups []string, targetGroup string) ([]telekomv1alpha1.BreakglassEscalation, error) <span class="cov0" title="0">{
        em.getLogger().Debugw("Fetching cluster-group-target BreakglassEscalations", "cluster", cluster, "userGroups", userGroups, "targetGroup", targetGroup)
        metrics.APIEndpointRequests.WithLabelValues("GetClusterGroupTargetBreakglassEscalation").Inc()
        // Try index-based lookup by escalatedGroup first
        collected := make([]telekomv1alpha1.BreakglassEscalation, 0)
        list := telekomv1alpha1.BreakglassEscalationList{}
        if err := em.List(ctx, &amp;list, client.MatchingFields{"spec.escalatedGroup": targetGroup}); err == nil &amp;&amp; len(list.Items) &gt; 0 </span><span class="cov0" title="0">{
                collected = append(collected, list.Items...)
        }</span>
        // If not found via index, fall back to scanning all escalations
        <span class="cov0" title="0">if len(collected) == 0 </span><span class="cov0" title="0">{
                all, err := em.GetAllBreakglassEscalations(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">collected = append(collected, all...)</span>
        }

        // Filter collected by cluster and allowed groups using shared helpers
        <span class="cov0" title="0">oidcPrefixes := em.getOIDCPrefixes()
        out := make([]telekomv1alpha1.BreakglassEscalation, 0)
        for _, be := range collected </span><span class="cov0" title="0">{
                if be.Spec.EscalatedGroup != targetGroup </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if !escalationMatchesCluster(be, cluster) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if groupsMatch(userGroups, be.Spec.Allowed.Groups, oidcPrefixes) </span><span class="cov0" title="0">{
                        out = append(out, be)
                }</span>
        }
        <span class="cov0" title="0">return out, nil</span>
}

func NewEscalationManager(contextName string, resolver GroupMemberResolver) (EscalationManager, error) <span class="cov0" title="0">{
        log := zap.S()
        log.Infow("Initializing EscalationManager", "context", contextName)
        cfg, err := config.GetConfigWithContext(contextName)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorw("Failed to get config with context", "context", contextName, "error", err)
                return EscalationManager{}, fmt.Errorf("failed to get config with context %q: %w", contextName, err)
        }</span>

        <span class="cov0" title="0">c, err := client.New(cfg, client.Options{
                Scheme: Scheme,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Errorw("Failed to create new client", "error", err)
                return EscalationManager{}, fmt.Errorf("failed to create new client: %w", err)
        }</span>

        <span class="cov0" title="0">log.Info("EscalationManager initialized successfully")
        return EscalationManager{Client: c, resolver: resolver, log: log}, nil</span>
}

// EscalationManagerOption configures an EscalationManager during construction.
type EscalationManagerOption func(*EscalationManager)

// WithLogger sets a custom logger for the EscalationManager.
// If not provided, the global zap.S() logger is used as fallback.
// Passing nil is a no-op (the existing logger is retained).
func WithLogger(log *zap.SugaredLogger) EscalationManagerOption <span class="cov0" title="0">{
        return func(em *EscalationManager) </span><span class="cov0" title="0">{
                if log != nil </span><span class="cov0" title="0">{
                        em.log = log
                }</span>
        }
}

// WithConfigLoader sets a cached config loader for the EscalationManager.
// If not provided, the manager falls back to cfgpkg.Load() for each config read.
// Passing nil is a no-op (the existing loader is retained).
func WithConfigLoader(loader *cfgpkg.CachedLoader) EscalationManagerOption <span class="cov0" title="0">{
        return func(em *EscalationManager) </span><span class="cov0" title="0">{
                if loader != nil </span><span class="cov0" title="0">{
                        em.configLoader = loader
                }</span>
        }
}

// NewEscalationManagerWithClient constructs an EscalationManager backed by the provided controller-runtime client.
// Use this when a shared manager client (with cache/indexes) should be reused instead of creating a new rest.Config.
// Configuration is applied via functional options (WithLogger, WithConfigLoader).
func NewEscalationManagerWithClient(c client.Client, resolver GroupMemberResolver, opts ...EscalationManagerOption) *EscalationManager <span class="cov0" title="0">{
        em := &amp;EscalationManager{Client: c, resolver: resolver}
        for _, opt := range opts </span><span class="cov0" title="0">{
                if opt != nil </span><span class="cov0" title="0">{
                        opt(em)
                }</span>
        }
        <span class="cov0" title="0">return em</span>
}

// SetResolver updates the GroupMemberResolver used for resolving group members.
// This should be called when the IdentityProvider configuration changes to ensure
// the EscalationManager uses the latest Keycloak group sync configuration.
// Thread-safe: Uses mutex to protect concurrent access to the resolver field.
func (em *EscalationManager) SetResolver(resolver GroupMemberResolver) <span class="cov0" title="0">{
        em.resolverMu.Lock()
        defer em.resolverMu.Unlock()
        em.resolver = resolver
        em.getLogger().Infow("EscalationManager resolver updated")
}</span>

// UpdateBreakglassEscalationStatus updates the given escalation resource status
func (em *EscalationManager) UpdateBreakglassEscalationStatus(ctx context.Context, esc telekomv1alpha1.BreakglassEscalation) error <span class="cov0" title="0">{
        log := em.getLogger()
        log.Infow("Updating BreakglassEscalation status", "name", esc.Name)
        if err := applyBreakglassEscalationStatus(ctx, em, &amp;esc); err != nil </span><span class="cov0" title="0">{
                log.Errorw("Failed to update BreakglassEscalation status", "name", esc.Name, "error", err)
                return fmt.Errorf("failed to update BreakglassEscalation status %s: %w", esc.Name, err)
        }</span>
        <span class="cov0" title="0">log.Infow("BreakglassEscalation status updated", "name", esc.Name)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package breakglass

import (
        "context"
        "crypto/tls"
        "crypto/x509"
        "fmt"
        "sort"
        "strings"
        "sync"
        "time"

        "github.com/Nerzal/gocloak/v13"
        telekomv1alpha1 "github.com/telekom/k8s-breakglass/api/v1alpha1"
        "github.com/telekom/k8s-breakglass/api/v1alpha1/applyconfiguration/ssa"
        cfgpkg "github.com/telekom/k8s-breakglass/pkg/config"
        "go.uber.org/zap"
        "k8s.io/client-go/tools/events"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

const (
        DefaultEscalationStatusUpdateInterval = 10 * time.Minute
        DefaultClusterConfigCheckInterval     = 10 * time.Minute
)

// GroupMemberResolver abstracts IdP (Keycloak) group membership queries.
// Implementations should return slice of user identifiers (emails/usernames) for provided group.
type GroupMemberResolver interface {
        Members(ctx context.Context, group string) ([]string, error)
}

// KeycloakGroupMemberResolver uses GoCloak client to fetch group members from Keycloak admin API.
type KeycloakGroupMemberResolver struct {
        log       *zap.SugaredLogger
        cfg       cfgpkg.KeycloakRuntimeConfig
        gocloak   *gocloak.GoCloak
        cache     *kcCache
        token     string
        tokenTime time.Time
        tokenLock sync.RWMutex
}

type kcCache struct {
        mu    sync.RWMutex
        items map[string]kcEntry
        ttl   time.Duration
}
type kcEntry struct {
        members []string
        expires time.Time
}

func newKCCache(ttl time.Duration) *kcCache <span class="cov0" title="0">{ return &amp;kcCache{items: map[string]kcEntry{}, ttl: ttl} }</span>
func (c *kcCache) get(k string) ([]string, bool) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        e, ok := c.items[k]
        if !ok || time.Now().After(e.expires) </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">return append([]string(nil), e.members...), true</span>
}
func (c *kcCache) set(k string, v []string) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.items[k] = kcEntry{members: append([]string(nil), v...), expires: time.Now().Add(c.ttl)}
}</span>

func NewKeycloakGroupMemberResolver(log *zap.SugaredLogger, cfg cfgpkg.KeycloakRuntimeConfig) *KeycloakGroupMemberResolver <span class="cov0" title="0">{
        ttl := 10 * time.Minute
        if d, err := telekomv1alpha1.ParseDuration(cfg.CacheTTL); err == nil &amp;&amp; d &gt; 0 </span><span class="cov0" title="0">{
                ttl = d
        }</span>
        <span class="cov0" title="0">gc := gocloak.NewClient(cfg.BaseURL)

        // Configure TLS settings for the gocloak client
        // This is necessary for self-signed certificates in test/dev environments
        if cfg.InsecureSkipVerify </span><span class="cov0" title="0">{
                restyClient := gc.RestyClient()
                restyClient.SetTLSClientConfig(&amp;tls.Config{
                        InsecureSkipVerify: true, //nolint:gosec // This is intentional for E2E testing with self-signed certs
                })
                if log != nil </span><span class="cov0" title="0">{
                        log.Debugw("Keycloak client configured with InsecureSkipVerify=true",
                                "baseURL", cfg.BaseURL, "realm", cfg.Realm)
                }</span>
        } else<span class="cov0" title="0"> if cfg.CertificateAuthority != "" </span><span class="cov0" title="0">{
                // Start from system cert pool so publicly trusted CAs remain valid,
                // then append the custom CA.
                certPool, err := x509.SystemCertPool()
                if err != nil </span><span class="cov0" title="0">{
                        if log != nil </span><span class="cov0" title="0">{
                                log.Warnw("Failed to load system cert pool; only the custom CA will be trusted",
                                        "error", err)
                        }</span>
                        <span class="cov0" title="0">certPool = x509.NewCertPool()</span>
                }
                <span class="cov0" title="0">if ok := certPool.AppendCertsFromPEM([]byte(cfg.CertificateAuthority)); ok </span><span class="cov0" title="0">{
                        restyClient := gc.RestyClient()
                        restyClient.SetTLSClientConfig(&amp;tls.Config{
                                RootCAs: certPool,
                        })
                        if log != nil </span><span class="cov0" title="0">{
                                log.Debugw("Keycloak client configured with custom CA certificate",
                                        "baseURL", cfg.BaseURL, "realm", cfg.Realm)
                        }</span>
                } else<span class="cov0" title="0"> if log != nil </span><span class="cov0" title="0">{
                        log.Warnw("Failed to parse CA certificate PEM; falling back to system certificates",
                                "baseURL", cfg.BaseURL, "realm", cfg.Realm)
                }</span>
        }

        <span class="cov0" title="0">return &amp;KeycloakGroupMemberResolver{log: log, cfg: cfg, gocloak: gc, cache: newKCCache(ttl)}</span>
}

func (k *KeycloakGroupMemberResolver) getToken(ctx context.Context) (string, error) <span class="cov0" title="0">{
        // Use configured service account token if available
        if k.cfg.ServiceAccountToken != "" </span><span class="cov0" title="0">{
                if k.log != nil </span><span class="cov0" title="0">{
                        k.log.Debugw("Using pre-configured service account token", "tokenLen", len(k.cfg.ServiceAccountToken))
                }</span>
                <span class="cov0" title="0">return k.cfg.ServiceAccountToken, nil</span>
        }

        // Check cached token
        <span class="cov0" title="0">k.tokenLock.RLock()
        if k.token != "" &amp;&amp; time.Now().Before(k.tokenTime.Add(5*time.Minute)) </span><span class="cov0" title="0">{
                defer k.tokenLock.RUnlock()
                if k.log != nil </span><span class="cov0" title="0">{
                        k.log.Debugw("Using cached token", "expiresIn", time.Until(k.tokenTime.Add(5*time.Minute)).Seconds())
                }</span>
                <span class="cov0" title="0">return k.token, nil</span>
        }
        <span class="cov0" title="0">k.tokenLock.RUnlock()

        // Acquire new token using client credentials
        tokenURL := fmt.Sprintf("%s/realms/%s/protocol/openid-connect/token", k.cfg.BaseURL, k.cfg.Realm)
        if k.log != nil </span><span class="cov0" title="0">{
                k.log.Debugw("Acquiring token via client credentials",
                        "clientID", k.cfg.ClientID,
                        "baseURL", k.cfg.BaseURL,
                        "realm", k.cfg.Realm,
                        "endpoint", tokenURL,
                        "grantType", "client_credentials",
                        "clientSecretProvided", k.cfg.ClientSecret != "")
        }</span>
        <span class="cov0" title="0">token, err := k.gocloak.GetToken(ctx, k.cfg.Realm, gocloak.TokenOptions{
                ClientID:     &amp;k.cfg.ClientID,
                ClientSecret: &amp;k.cfg.ClientSecret,
                GrantType:    gocloak.StringP("client_credentials"),
        })
        if err != nil </span><span class="cov0" title="0">{
                if k.log != nil </span><span class="cov0" title="0">{
                        k.log.Errorw("Failed to acquire token",
                                "clientID", k.cfg.ClientID,
                                "error", err,
                                "endpoint", tokenURL,
                                "grantType", "client_credentials")
                }</span>
                <span class="cov0" title="0">return "", err</span>
        }

        // Cache token
        <span class="cov0" title="0">k.tokenLock.Lock()
        k.token = token.AccessToken
        k.tokenTime = time.Now()
        k.tokenLock.Unlock()

        if k.log != nil </span><span class="cov0" title="0">{
                k.log.Debugw("Token acquired successfully",
                        "clientID", k.cfg.ClientID,
                        "tokenLen", len(token.AccessToken),
                        "expiresIn", token.ExpiresIn,
                        "tokenType", token.TokenType)
        }</span>
        <span class="cov0" title="0">return token.AccessToken, nil</span>
}

func (k *KeycloakGroupMemberResolver) Members(ctx context.Context, group string) ([]string, error) <span class="cov0" title="0">{
        if k == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">log := k.log
        if k.cfg.BaseURL == "" || k.cfg.Realm == "" || k.cfg.ClientID == "" </span><span class="cov0" title="0">{
                if log != nil </span><span class="cov0" title="0">{
                        log.Errorw("Keycloak resolver has incomplete configuration; cannot resolve groups",
                                "group", group,
                                "baseURL", k.cfg.BaseURL,
                                "realm", k.cfg.Realm,
                                "clientID", k.cfg.ClientID)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("keycloak resolver incomplete config: baseURL=%s, realm=%s, clientID=%s",
                        k.cfg.BaseURL, k.cfg.Realm, k.cfg.ClientID)</span>
        }
        <span class="cov0" title="0">if v, ok := k.cache.get(group); ok </span><span class="cov0" title="0">{
                if log != nil </span><span class="cov0" title="0">{
                        log.Debugw("Keycloak cache hit for group", "group", group, "membersCount", len(v), "members", v)
                }</span>
                <span class="cov0" title="0">return v, nil</span>
        }
        <span class="cov0" title="0">if log != nil </span><span class="cov0" title="0">{
                log.Debugw("Keycloak cache miss for group; will perform lookup", "group", group)
        }</span>

        // Get token
        <span class="cov0" title="0">token, err := k.getToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                if log != nil </span><span class="cov0" title="0">{
                        log.Errorw("Failed to get Keycloak token", "group", group, "error", err)
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // 1. Search for group by name
        <span class="cov0" title="0">if log != nil </span><span class="cov0" title="0">{
                log.Debugw("Starting group search step", "group", group)
                log.Debugw("GetGroups API call details",
                        "baseURL", k.cfg.BaseURL,
                        "realm", k.cfg.Realm,
                        "searchParam", group,
                        "tokenLen", len(token),
                        "endpoint", fmt.Sprintf("%s/admin/realms/%s/groups", k.cfg.BaseURL, k.cfg.Realm))
        }</span>
        <span class="cov0" title="0">params := gocloak.GetGroupsParams{Search: gocloak.StringP(group)}
        groups, err := k.gocloak.GetGroups(ctx, token, k.cfg.Realm, params)
        if err != nil </span><span class="cov0" title="0">{
                if log != nil </span><span class="cov0" title="0">{
                        log.Errorw("Keycloak groups search failed",
                                "group", group,
                                "error", err,
                                "errorType", fmt.Sprintf("%T", err),
                                "tokenLen", len(token),
                                "endpoint", fmt.Sprintf("%s/admin/realms/%s/groups", k.cfg.BaseURL, k.cfg.Realm),
                                "params", fmt.Sprintf("search=%s", group))
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">if log != nil </span><span class="cov0" title="0">{
                log.Debugw("Keycloak groups search completed", "group", group, "returnedGroupCount", len(groups))
                if len(groups) &gt; 0 </span><span class="cov0" title="0">{
                        for i, g := range groups </span><span class="cov0" title="0">{
                                log.Debugw("Group search result",
                                        "index", i,
                                        "groupID", g.ID,
                                        "groupName", g.Name,
                                        "hasSubgroups", g.SubGroups != nil &amp;&amp; len(*g.SubGroups) &gt; 0)
                        }</span>
                }
        }

        // Find matching group by name
        <span class="cov0" title="0">var groupID *string
        for _, g := range groups </span><span class="cov0" title="0">{
                if g.Name != nil &amp;&amp; strings.EqualFold(*g.Name, group) </span><span class="cov0" title="0">{
                        groupID = g.ID
                        if log != nil </span><span class="cov0" title="0">{
                                log.Debugw("Found matching group by name", "group", group, "groupID", *groupID, "matchedName", *g.Name)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }
        <span class="cov0" title="0">if groupID == nil </span><span class="cov0" title="0">{
                if log != nil </span><span class="cov0" title="0">{
                        log.Warnw("Group not found in search results", "group", group)
                }</span>
                <span class="cov0" title="0">k.cache.set(group, []string{})
                return []string{}, nil</span>
        }

        // 2. Get direct group members
        <span class="cov0" title="0">if log != nil </span><span class="cov0" title="0">{
                log.Debugw("Starting direct members fetch step", "group", group, "groupID", *groupID)
                log.Debugw("GetGroupMembers API call details",
                        "baseURL", k.cfg.BaseURL,
                        "realm", k.cfg.Realm,
                        "groupID", *groupID,
                        "tokenLen", len(token),
                        "endpoint", fmt.Sprintf("%s/admin/realms/%s/groups/%s/members", k.cfg.BaseURL, k.cfg.Realm, *groupID))
        }</span>
        <span class="cov0" title="0">params2 := gocloak.GetGroupsParams{}
        members, err := k.gocloak.GetGroupMembers(ctx, token, k.cfg.Realm, *groupID, params2)
        if err != nil </span><span class="cov0" title="0">{
                if log != nil </span><span class="cov0" title="0">{
                        log.Errorw("Keycloak members fetch failed",
                                "group", group,
                                "groupID", *groupID,
                                "error", err,
                                "errorType", fmt.Sprintf("%T", err),
                                "tokenLen", len(token),
                                "endpoint", fmt.Sprintf("%s/admin/realms/%s/groups/%s/members", k.cfg.BaseURL, k.cfg.Realm, *groupID))
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">if log != nil </span><span class="cov0" title="0">{
                log.Debugw("Direct members fetch completed", "group", group, "directMemberCount", len(members))
                for i, m := range members </span><span class="cov0" title="0">{
                        log.Debugw("Direct group member",
                                "index", i,
                                "userID", m.ID,
                                "username", m.Username,
                                "email", m.Email)
                }</span>
        }

        // Collect member identifiers
        <span class="cov0" title="0">out := make([]string, 0, len(members))
        for i, m := range members </span><span class="cov0" title="0">{
                identifier := ""
                if m.Email != nil &amp;&amp; *m.Email != "" </span><span class="cov0" title="0">{
                        identifier = *m.Email
                        if log != nil </span><span class="cov0" title="0">{
                                log.Debugw("Added direct member by email", "group", group, "index", i, "email", identifier)
                        }</span>
                } else<span class="cov0" title="0"> if m.Username != nil &amp;&amp; *m.Username != "" </span><span class="cov0" title="0">{
                        identifier = *m.Username
                        if log != nil </span><span class="cov0" title="0">{
                                log.Debugw("Added direct member by username", "group", group, "index", i, "username", identifier)
                        }</span>
                }
                <span class="cov0" title="0">if identifier != "" </span><span class="cov0" title="0">{
                        out = append(out, identifier)
                }</span>
        }

        // 3. Get group detail to retrieve subgroups
        <span class="cov0" title="0">if log != nil </span><span class="cov0" title="0">{
                log.Debugw("Starting subgroups fetch step", "group", group, "groupID", *groupID, "currentMemberCount", len(out))
                log.Debugw("GetGroup API call details",
                        "baseURL", k.cfg.BaseURL,
                        "realm", k.cfg.Realm,
                        "groupID", *groupID,
                        "tokenLen", len(token),
                        "endpoint", fmt.Sprintf("%s/admin/realms/%s/groups/%s", k.cfg.BaseURL, k.cfg.Realm, *groupID))
        }</span>
        <span class="cov0" title="0">groupDetail, err := k.gocloak.GetGroup(ctx, token, k.cfg.Realm, *groupID)
        if err != nil </span><span class="cov0" title="0">{
                if log != nil </span><span class="cov0" title="0">{
                        log.Warnw("Keycloak group detail fetch failed",
                                "group", group,
                                "error", err,
                                "errorType", fmt.Sprintf("%T", err),
                                "tokenLen", len(token),
                                "endpoint", fmt.Sprintf("%s/admin/realms/%s/groups/%s", k.cfg.BaseURL, k.cfg.Realm, *groupID))
                }</span>
                // Continue with just direct members
        } else<span class="cov0" title="0"> if groupDetail != nil &amp;&amp; groupDetail.SubGroups != nil </span><span class="cov0" title="0">{
                if log != nil </span><span class="cov0" title="0">{
                        log.Debugw("Subgroups fetch completed", "group", group, "subgroupCount", len(*groupDetail.SubGroups))
                }</span>
                <span class="cov0" title="0">for sgIdx, sg := range *groupDetail.SubGroups </span><span class="cov0" title="0">{
                        if sg.ID == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if log != nil </span><span class="cov0" title="0">{
                                log.Debugw("Processing subgroup", "group", group, "parentGroupID", *groupID, "subgroupIndex", sgIdx, "subgroupID", *sg.ID, "subgroupName", sg.Name)
                        }</span>

                        // Fetch members of each subgroup
                        <span class="cov0" title="0">if log != nil </span><span class="cov0" title="0">{
                                log.Debugw("GetGroupMembers API call for subgroup",
                                        "baseURL", k.cfg.BaseURL,
                                        "realm", k.cfg.Realm,
                                        "subgroupID", *sg.ID,
                                        "tokenLen", len(token),
                                        "endpoint", fmt.Sprintf("%s/admin/realms/%s/groups/%s/members", k.cfg.BaseURL, k.cfg.Realm, *sg.ID))
                        }</span>
                        <span class="cov0" title="0">params3 := gocloak.GetGroupsParams{}
                        sgMembers, err := k.gocloak.GetGroupMembers(ctx, token, k.cfg.Realm, *sg.ID, params3)
                        if err != nil </span><span class="cov0" title="0">{
                                if log != nil </span><span class="cov0" title="0">{
                                        log.Warnw("Subgroup members fetch failed",
                                                "group", group,
                                                "subgroupID", *sg.ID,
                                                "error", err,
                                                "errorType", fmt.Sprintf("%T", err),
                                                "tokenLen", len(token),
                                                "endpoint", fmt.Sprintf("%s/admin/realms/%s/groups/%s/members", k.cfg.BaseURL, k.cfg.Realm, *sg.ID))
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }

                        <span class="cov0" title="0">if log != nil </span><span class="cov0" title="0">{
                                log.Debugw("Subgroup members fetch completed", "subgroupID", *sg.ID, "memberCount", len(sgMembers))
                        }</span>

                        <span class="cov0" title="0">for sgmIdx, m := range sgMembers </span><span class="cov0" title="0">{
                                identifier := ""
                                if m.Email != nil &amp;&amp; *m.Email != "" </span><span class="cov0" title="0">{
                                        identifier = *m.Email
                                        if log != nil </span><span class="cov0" title="0">{
                                                log.Debugw("Added subgroup member by email", "group", group, "subgroupID", *sg.ID, "memberIndex", sgmIdx, "email", identifier)
                                        }</span>
                                } else<span class="cov0" title="0"> if m.Username != nil &amp;&amp; *m.Username != "" </span><span class="cov0" title="0">{
                                        identifier = *m.Username
                                        if log != nil </span><span class="cov0" title="0">{
                                                log.Debugw("Added subgroup member by username", "group", group, "subgroupID", *sg.ID, "memberIndex", sgmIdx, "username", identifier)
                                        }</span>
                                }
                                <span class="cov0" title="0">if identifier != "" </span><span class="cov0" title="0">{
                                        out = append(out, identifier)
                                }</span>
                        }
                }
        }

        // 4. Normalize and deduplicate members
        <span class="cov0" title="0">if log != nil </span><span class="cov0" title="0">{
                log.Debugw("Starting member list normalization", "group", group, "beforeNormalizationCount", len(out))
        }</span>
        <span class="cov0" title="0">out = normalizeMembers(out)
        if log != nil </span><span class="cov0" title="0">{
                log.Infow("Keycloak group member resolution completed successfully", "group", group, "finalResolvedCount", len(out), "members", out)
        }</span>

        // 5. Cache and return results
        <span class="cov0" title="0">k.cache.set(group, out)
        if log != nil </span><span class="cov0" title="0">{
                log.Debugw("Group member resolution returning successfully", "group", group, "memberCount", len(out))
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// EscalationStatusUpdater periodically expands approver groups into member lists and stores in status.
type EscalationStatusUpdater struct {
        Log           *zap.SugaredLogger
        K8sClient     client.Client
        Resolver      GroupMemberResolver
        Interval      time.Duration
        LeaderElected &lt;-chan struct{} // Optional: signal when leadership acquired (nil = start immediately for backward compatibility)
        EventRecorder events.EventRecorder
        IDPLoader     *cfgpkg.IdentityProviderLoader // For multi-IDP group fetching
}

func (u EscalationStatusUpdater) Start(ctx context.Context) <span class="cov0" title="0">{
        // ensure logger present
        log := u.Log

        log = log.With("component", "EscalationStatusUpdater")

        // Wait for leadership signal if provided (enables multi-replica scaling with leader election)
        if u.LeaderElected != nil </span><span class="cov0" title="0">{
                log.Info("Escalation status updater waiting for leadership signal before starting...")
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        log.Infow("Escalation status updater stopping before acquiring leadership (context canceled)")
                        return</span>
                case &lt;-u.LeaderElected:<span class="cov0" title="0">
                        log.Info("Leadership acquired - starting escalation status updater")</span>
                }
        }

        <span class="cov0" title="0">if u.Interval &lt;= 0 </span><span class="cov0" title="0">{
                u.Interval = 5 * time.Minute
        }</span>
        <span class="cov0" title="0">ticker := time.NewTicker(u.Interval)
        defer ticker.Stop()
        log.Infow("Starting escalation status updater", "interval", u.Interval.String())
        u.runOnce(ctx, log)
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        log.Infow("Escalation status updater stopping (context done)")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        u.runOnce(ctx, log)</span>
                }
        }
}

func (u EscalationStatusUpdater) runOnce(ctx context.Context, log *zap.SugaredLogger) <span class="cov0" title="0">{
        log.Debugw("Starting escalation status update cycle", "resolver", fmt.Sprintf("%T", u.Resolver))
        escList := telekomv1alpha1.BreakglassEscalationList{}
        if err := u.K8sClient.List(ctx, &amp;escList); err != nil </span><span class="cov0" title="0">{
                log.Errorw("Failed listing BreakglassEscalations for status update", "error", err)
                return
        }</span>
        <span class="cov0" title="0">log.Debugw("Fetched escalations for status update", "count", len(escList.Items))

        for _, esc := range escList.Items </span><span class="cov0" title="0">{
                // Collect approver groups
                groups := esc.Spec.Approvers.Groups
                if len(groups) == 0 </span><span class="cov0" title="0">{
                        log.Debugw("Escalation has no approver groups; skipping", "escalation", esc.Name)
                        continue</span>
                }
                <span class="cov0" title="0">log.Debugw("Processing escalation with approver groups", "escalation", esc.Name, "groupCount", len(groups), "groups", groups)

                updated := esc.DeepCopy()
                if updated.Status.ApproverGroupMembers == nil </span><span class="cov0" title="0">{
                        updated.Status.ApproverGroupMembers = map[string][]string{}
                }</span>

                // Determine which IDPs to use for group resolution
                // If allowedIdentityProvidersForApprovers is explicitly set, use those IDPs
                // Otherwise, if IDPLoader is available and has multiple enabled IDPs, use all of them (auto multi-IDP mode)
                // Otherwise, fall back to legacy single-resolver mode
                <span class="cov0" title="0">var idpsToUse []string
                if len(esc.Spec.AllowedIdentityProvidersForApprovers) &gt; 0 </span><span class="cov0" title="0">{
                        // Explicitly configured IDPs
                        idpsToUse = esc.Spec.AllowedIdentityProvidersForApprovers
                        log.Debugw("Using explicitly configured IDPs", "escalation", esc.Name, "idps", idpsToUse)
                }</span> else<span class="cov0" title="0"> if u.IDPLoader != nil </span><span class="cov0" title="0">{
                        // Auto-detect: use all enabled IDPs
                        allIDPs, err := u.IDPLoader.LoadAllIdentityProviders(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Warnw("Failed to load IDPs for auto-detection, falling back to legacy mode", "error", err, "escalation", esc.Name)
                        }</span> else<span class="cov0" title="0"> if len(allIDPs) &gt; 0 </span><span class="cov0" title="0">{
                                idpsToUse = make([]string, 0, len(allIDPs))
                                for name := range allIDPs </span><span class="cov0" title="0">{
                                        idpsToUse = append(idpsToUse, name)
                                }</span>
                                <span class="cov0" title="0">log.Debugw("Auto-detected multiple IDPs, using multi-IDP mode", "escalation", esc.Name, "idpCount", len(idpsToUse), "idps", idpsToUse)</span>
                        }
                }

                <span class="cov0" title="0">changed := false

                if len(idpsToUse) &gt; 0 </span><span class="cov0" title="0">{
                        // Multi-IDP mode: Use multi-IDP group sync with IDP hierarchy storage
                        log.Debugw("Using multi-IDP group sync", "escalation", esc.Name, "idps", idpsToUse)

                        hierarchy, _, _ := u.fetchGroupMembersFromMultipleIDPs(
                                ctx,
                                &amp;esc,
                                idpsToUse,
                                groups,
                                log,
                        )

                        // Store full IDP hierarchy in status (NOT deduplicated)
                        if !equalIDPHierarchy(hierarchy, updated.Status.IDPGroupMemberships) </span><span class="cov0" title="0">{
                                updated.Status.IDPGroupMemberships = hierarchy
                                changed = true
                        }</span>

                        // Store deduplicated members in ApproverGroupMembers for immediate use
                        // These are deduplicated across all IDPs by email/username and ready for:
                        // - Email notifications (approvers list)
                        // - Session approval validation
                        // - Request validation
                        // The full per-IDP hierarchy is preserved in IDPGroupMemberships for debugging/auditing
                        <span class="cov0" title="0">for _, g := range groups </span><span class="cov0" title="0">{
                                dedupMembers := deduplicateMembersFromHierarchy(hierarchy, g)
                                if !equalStringSlices(dedupMembers, updated.Status.ApproverGroupMembers[g]) </span><span class="cov0" title="0">{
                                        updated.Status.ApproverGroupMembers[g] = dedupMembers
                                        changed = true
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Legacy single-resolver mode for backward compatibility
                        log.Debugw("Using legacy single resolver mode", "escalation", esc.Name)

                        for _, g := range groups </span><span class="cov0" title="0">{
                                log.Debugw("Resolving group for escalation", "escalation", esc.Name, "group", g, "resolverType", fmt.Sprintf("%T", u.Resolver))
                                var norm []string
                                if u.Resolver != nil </span><span class="cov0" title="0">{
                                        log.Debugw("Calling group member resolver", "group", g, "escalation", esc.Name, "resolverType", fmt.Sprintf("%T", u.Resolver))
                                        members, err := u.Resolver.Members(ctx, g)
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Errorw("Failed resolving group members from resolver", "group", g, "escalation", esc.Name, "error", err, "resolverType", fmt.Sprintf("%T", u.Resolver))
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">log.Debugw("Group member resolver returned members", "group", g, "escalation", esc.Name, "rawMemberCount", len(members), "members", members)
                                        norm = normalizeMembers(members)
                                        log.Infow("Resolved approver group members (normalized)", "group", g, "escalation", esc.Name, "rawCount", len(members), "normalizedCount", len(norm), "normalizedMembers", norm)</span>
                                } else<span class="cov0" title="0"> {
                                        log.Warnw("No group member resolver configured; skipping group resolution", "group", g, "escalation", esc.Name)
                                        continue</span>
                                }
                                <span class="cov0" title="0">if !equalStringSlices(norm, updated.Status.ApproverGroupMembers[g]) </span><span class="cov0" title="0">{
                                        log.Debugw("Group members changed; marking for update", "group", g, "escalation", esc.Name, "oldCount", len(updated.Status.ApproverGroupMembers[g]), "newCount", len(norm))
                                        updated.Status.ApproverGroupMembers[g] = norm
                                        changed = true
                                }</span>
                        }
                }

                <span class="cov0" title="0">if changed </span><span class="cov0" title="0">{
                        log.Infow("Updating escalation status with resolved group members", "escalation", esc.Name, "groupCount", len(groups))
                        if err := u.applyStatus(ctx, updated); err != nil </span><span class="cov0" title="0">{
                                log.Errorw("Failed updating escalation status", "escalation", esc.Name, "error", err)
                                // Emit error event
                                if u.EventRecorder != nil </span><span class="cov0" title="0">{
                                        u.EventRecorder.Eventf(updated, nil, "Warning", "GroupMembersUpdateFailed", "GroupMembersUpdateFailed",
                                                "Failed to update group members: %v", err)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                log.Debugw("Updated escalation successfully", "escalation", esc.Name, "groups", groups)
                                // Emit success event with details about what was synced
                                if u.EventRecorder != nil </span><span class="cov0" title="0">{
                                        if len(idpsToUse) &gt; 0 </span><span class="cov0" title="0">{
                                                // Multi-IDP mode
                                                eventMsg := fmt.Sprintf("Group members synced successfully from %d IDPs. Updated %d group(s) with approvers.",
                                                        len(idpsToUse), len(groups))
                                                u.EventRecorder.Eventf(updated, nil, "Normal", "GroupMembersSynced", "GroupMembersSynced", "%s", eventMsg)
                                        }</span> else<span class="cov0" title="0"> {
                                                // Legacy single resolver mode
                                                totalMembers := 0
                                                for _, members := range updated.Status.ApproverGroupMembers </span><span class="cov0" title="0">{
                                                        totalMembers += len(members)
                                                }</span>
                                                <span class="cov0" title="0">u.EventRecorder.Eventf(updated, nil, "Normal", "GroupMembersSynced", "GroupMembersSynced",
                                                        "Group members resolved successfully. Total approvers from %d group(s): %d members.",
                                                        len(groups), totalMembers)</span>
                                        }
                                }
                        }
                }
        }
        <span class="cov0" title="0">log.Debugw("Completed escalation status update cycle")</span>
}

func (u EscalationStatusUpdater) applyStatus(ctx context.Context, escalation *telekomv1alpha1.BreakglassEscalation) error <span class="cov0" title="0">{
        return ssa.ApplyBreakglassEscalationStatus(ctx, u.K8sClient, escalation)
}</span>

// fetchGroupMembersFromMultipleIDPs fetches group members from multiple IDPs and stores in IDP hierarchy structure.
// Returns: map[idpName]map[groupName][]memberList, syncStatus, and error list (never blocks escalation creation)
func (u EscalationStatusUpdater) fetchGroupMembersFromMultipleIDPs(
        ctx context.Context,
        escalation *telekomv1alpha1.BreakglassEscalation,
        idpNames []string,
        groups []string,
        log *zap.SugaredLogger,
) (map[string]map[string][]string, string, []string) <span class="cov0" title="0">{
        // Structure: map[idpName]map[groupName][]memberList
        hierarchy := make(map[string]map[string][]string)
        var syncErrors []string
        successCount := 0
        failureCount := 0

        if u.IDPLoader == nil </span><span class="cov0" title="0">{
                log.Debugw("IDPLoader not configured; using single resolver fallback", "escalation", escalation.Name)
                // Fallback: use legacy single resolver for backward compatibility
                groupMembers := make(map[string][]string)
                for _, g := range groups </span><span class="cov0" title="0">{
                        if u.Resolver != nil </span><span class="cov0" title="0">{
                                members, err := u.Resolver.Members(ctx, g)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Errorw("Failed to resolve group members", "escalation", escalation.Name, "group", g, "error", err)
                                        continue</span>
                                }
                                <span class="cov0" title="0">groupMembers[g] = normalizeMembers(members)</span>
                        }
                }
                // Store in hierarchy under empty IDP name for backward compat
                <span class="cov0" title="0">if len(groupMembers) &gt; 0 </span><span class="cov0" title="0">{
                        hierarchy[""] = groupMembers
                }</span>
                <span class="cov0" title="0">return hierarchy, "Success", nil</span>
        }

        // Multi-IDP sync: fetch from each IDP for each group
        <span class="cov0" title="0">for _, idpName := range idpNames </span><span class="cov0" title="0">{
                log.Debugw("Fetching group members from IDP", "escalation", escalation.Name, "idp", idpName, "groups", groups)

                idpConfig, err := u.IDPLoader.LoadIdentityProviderByName(ctx, idpName)
                if err != nil </span><span class="cov0" title="0">{
                        errorMsg := fmt.Sprintf("Failed to load IDP config: %v", err)
                        log.Errorw("Failed to load IDP configuration", "escalation", escalation.Name, "idp", idpName, "error", err)
                        syncErrors = append(syncErrors, errorMsg)
                        failureCount++

                        // Emit event on IdentityProvider resource
                        if u.EventRecorder != nil </span><span class="cov0" title="0">{
                                idp := &amp;telekomv1alpha1.IdentityProvider{}
                                idp.SetName(idpName)
                                u.EventRecorder.Eventf(idp, nil, "Warning", "GroupSyncConfigLoadFailed", "GroupSyncConfigLoadFailed",
                                        "Failed to load IDP config for escalation %s/%s: %v",
                                        escalation.Namespace, escalation.Name, err)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // Create resolver for this IDP
                <span class="cov0" title="0">resolver := u.createResolverForIDP(idpConfig, log)
                if resolver == nil </span><span class="cov0" title="0">{
                        errorMsg := fmt.Sprintf("Failed to create resolver for IDP: %s", idpName)
                        log.Warnw("Failed to create resolver for IDP", "escalation", escalation.Name, "idp", idpName)
                        syncErrors = append(syncErrors, errorMsg)
                        failureCount++

                        // Emit event on IdentityProvider resource
                        if u.EventRecorder != nil </span><span class="cov0" title="0">{
                                idp := &amp;telekomv1alpha1.IdentityProvider{}
                                idp.SetName(idpName)
                                u.EventRecorder.Eventf(idp, nil, "Warning", "GroupSyncResolverCreationFailed", "GroupSyncResolverCreationFailed",
                                        "Failed to create group sync resolver for escalation %s/%s",
                                        escalation.Namespace, escalation.Name)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // Fetch group members for this IDP
                <span class="cov0" title="0">idpGroupMembers := make(map[string][]string)
                idpSuccess := true

                for _, g := range groups </span><span class="cov0" title="0">{
                        members, err := resolver.Members(ctx, g)
                        if err != nil </span><span class="cov0" title="0">{
                                errorMsg := fmt.Sprintf("IDP %s: timeout/error fetching group %s: %v", idpName, g, err)
                                log.Warnw("Failed to resolve group members from IDP", "escalation", escalation.Name, "idp", idpName, "group", g, "error", err)
                                syncErrors = append(syncErrors, errorMsg)
                                idpSuccess = false

                                // Emit event on IdentityProvider resource
                                if u.EventRecorder != nil </span><span class="cov0" title="0">{
                                        idp := &amp;telekomv1alpha1.IdentityProvider{}
                                        idp.SetName(idpName)
                                        u.EventRecorder.Eventf(idp, nil, "Warning", "GroupFetchFailed", "GroupFetchFailed",
                                                "Failed to fetch group %s for escalation %s/%s: %v",
                                                g, escalation.Namespace, escalation.Name, err)
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }
                        <span class="cov0" title="0">idpGroupMembers[g] = normalizeMembers(members)</span>
                }

                <span class="cov0" title="0">if idpSuccess </span><span class="cov0" title="0">{
                        successCount++
                }</span> else<span class="cov0" title="0"> {
                        failureCount++
                }</span>

                // Store members under IDP name in hierarchy
                <span class="cov0" title="0">hierarchy[idpName] = idpGroupMembers</span>
        }

        // Determine sync status
        <span class="cov0" title="0">var syncStatus string
        if failureCount == 0 </span><span class="cov0" title="0">{
                syncStatus = "Success"
        }</span> else<span class="cov0" title="0"> if successCount &gt; 0 &amp;&amp; failureCount &gt; 0 </span><span class="cov0" title="0">{
                syncStatus = "PartialFailure"
        }</span> else<span class="cov0" title="0"> {
                syncStatus = "Failed"
        }</span>

        <span class="cov0" title="0">log.Infow("Multi-IDP group sync completed",
                "escalation", escalation.Name,
                "idpCount", len(idpNames),
                "successCount", successCount,
                "failureCount", failureCount,
                "syncStatus", syncStatus,
                "errorCount", len(syncErrors))

        // Emit event on BreakglassEscalation if there were failures
        if failureCount &gt; 0 &amp;&amp; u.EventRecorder != nil </span><span class="cov0" title="0">{
                u.EventRecorder.Eventf(escalation, nil, "Warning", "GroupSyncPartialFailure", "GroupSyncPartialFailure",
                        "Multi-IDP group sync partially failed: %d IDPs succeeded, %d failed. See status.groupSyncErrors for details.",
                        successCount, failureCount)
        }</span>

        <span class="cov0" title="0">return hierarchy, syncStatus, syncErrors</span>
}

// createResolverForIDP creates an appropriate resolver for the given IDP config
func (u EscalationStatusUpdater) createResolverForIDP(idpConfig *cfgpkg.IdentityProviderConfig, log *zap.SugaredLogger) GroupMemberResolver <span class="cov0" title="0">{
        if idpConfig == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Currently only Keycloak is supported
        <span class="cov0" title="0">if idpConfig.Keycloak == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return NewKeycloakGroupMemberResolver(log, *idpConfig.Keycloak)</span>
}

func normalizeMembers(in []string) []string <span class="cov0" title="0">{
        out := make([]string, 0, len(in))
        seen := map[string]struct{}{}
        for _, m := range in </span><span class="cov0" title="0">{
                m = strings.TrimSpace(strings.ToLower(m))
                if m == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if _, ok := seen[m]; ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">seen[m] = struct{}{}
                out = append(out, m)</span>
        }
        // stable order not critical here; could sort if needed
        <span class="cov0" title="0">return out</span>
}

func equalStringSlices(a, b []string) bool <span class="cov0" title="0">{
        if len(a) != len(b) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">amap := map[string]int{}
        for _, v := range a </span><span class="cov0" title="0">{
                amap[v]++
        }</span>
        <span class="cov0" title="0">for _, v := range b </span><span class="cov0" title="0">{
                if amap[v] == 0 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">amap[v]--</span>
        }
        <span class="cov0" title="0">for _, c := range amap </span><span class="cov0" title="0">{
                if c != 0 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// equalIDPHierarchy compares two IDP hierarchies for equality
func equalIDPHierarchy(a, b map[string]map[string][]string) bool <span class="cov0" title="0">{
        if len(a) != len(b) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for idpName, groupMembers := range a </span><span class="cov0" title="0">{
                bGroupMembers, ok := b[idpName]
                if !ok </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">if len(groupMembers) != len(bGroupMembers) </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">for groupName, members := range groupMembers </span><span class="cov0" title="0">{
                        bMembers, ok := bGroupMembers[groupName]
                        if !ok </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov0" title="0">if !equalStringSlices(members, bMembers) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }
        <span class="cov0" title="0">return true</span>
}

// deduplicateMembersFromHierarchy extracts and deduplicates members from IDP hierarchy for a specific group
// Returns the deduplicated list of members for that group from all IDPs, sorted for deterministic output
func deduplicateMembersFromHierarchy(hierarchy map[string]map[string][]string, group string) []string <span class="cov0" title="0">{
        seen := make(map[string]struct{})
        var result []string

        // Iterate through each IDP in hierarchy
        for _, groupMembers := range hierarchy </span><span class="cov0" title="0">{
                if members, ok := groupMembers[group]; ok </span><span class="cov0" title="0">{
                        for _, member := range members </span><span class="cov0" title="0">{
                                // Normalize and deduplicate
                                normalized := strings.TrimSpace(strings.ToLower(member))
                                if normalized == "" </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">if _, alreadySeen := seen[normalized]; !alreadySeen </span><span class="cov0" title="0">{
                                        seen[normalized] = struct{}{}
                                        result = append(result, normalized)
                                }</span>
                        }
                }
        }

        // Sort for deterministic output (map iteration order is non-deterministic)
        <span class="cov0" title="0">sort.Strings(result)

        return result</span>
}

// End of EscalationStatusUpdater methods

func SetupResolver(idpConfig *cfgpkg.IdentityProviderConfig, log *zap.SugaredLogger) GroupMemberResolver <span class="cov0" title="0">{
        // Setup GroupMemberResolver for escalation approver expansion
        var resolver GroupMemberResolver
        if idpConfig != nil &amp;&amp; idpConfig.Keycloak != nil &amp;&amp; idpConfig.Keycloak.BaseURL != "" &amp;&amp; idpConfig.Keycloak.Realm != "" </span><span class="cov0" title="0">{
                resolver = NewKeycloakGroupMemberResolver(log, *idpConfig.Keycloak)
                log.Infow("Keycloak group sync enabled", "baseURL", idpConfig.Keycloak.BaseURL, "realm", idpConfig.Keycloak.Realm)
        }</span> else<span class="cov0" title="0"> {
                resolver = &amp;KeycloakGroupMemberResolver{} // no-op
                log.Infow("Keycloak group sync disabled or not fully configured; using no-op resolver")
        }</span>
        <span class="cov0" title="0">return resolver</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package breakglass

import (
        "context"
        "fmt"
        "time"

        "go.uber.org/zap"

        corev1 "k8s.io/api/core/v1"
        eventsv1 "k8s.io/api/events/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/tools/events"
        "k8s.io/client-go/tools/reference"

        "github.com/telekom/k8s-breakglass/pkg/system"
)

// K8sEventRecorder implements events.EventRecorder and writes Events via the provided clientset.
// Clientset is the kubernetes client to use for creating Events. Use the
// kubernetes.Interface here so unit tests can inject the fake clientset.
type K8sEventRecorder struct {
        Clientset kubernetes.Interface
        Source    corev1.EventSource
        Scheme    *runtime.Scheme
        // Namespace where events should be created (controller pod namespace)
        Namespace string
        // optional logger for reporting event creation problems
        Logger *zap.SugaredLogger
}

func (r *K8sEventRecorder) Eventf(regarding runtime.Object, related runtime.Object, eventtype, reason, action, note string, args ...interface{}) <span class="cov0" title="0">{
        metaObj, ok := regarding.(metav1.Object)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        // Per new policy: always emit events into the same namespace the object
        // lives in. Only for cluster-scoped objects (object namespace empty) we
        // fall back to the controller's pod namespace (from r.Namespace field).
        // If neither the object's namespace nor the controller's namespace is available,
        // do not create an Event (best-effort, but avoids writing into an unrelated namespace).
        <span class="cov0" title="0">objNS := metaObj.GetNamespace()
        podNS := r.Namespace

        var ns string
        var involvedNS string
        if objNS != "" </span><span class="cov0" title="0">{
                ns = objNS
                involvedNS = objNS
        }</span> else<span class="cov0" title="0"> if podNS != "" </span><span class="cov0" title="0">{
                ns = podNS
                involvedNS = podNS
        }</span> else<span class="cov0" title="0"> {
                if r.Logger != nil </span><span class="cov0" title="0">{
                        r.Logger.Infow("skipping kubernetes Event creation: object has no namespace and controller namespace is not set", "object", metaObj.GetName())
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">regardingRef := &amp;corev1.ObjectReference{
                Namespace: involvedNS,
                Name:      metaObj.GetName(),
                UID:       metaObj.GetUID(),
        }
        if r.Scheme != nil </span><span class="cov0" title="0">{
                if ref, err := reference.GetReference(r.Scheme, regarding); err == nil </span><span class="cov0" title="0">{
                        regardingRef = ref
                }</span>
        }

        <span class="cov0" title="0">var relatedRef *corev1.ObjectReference
        if related != nil </span><span class="cov0" title="0">{
                if r.Scheme != nil </span><span class="cov0" title="0">{
                        if ref, err := reference.GetReference(r.Scheme, related); err == nil </span><span class="cov0" title="0">{
                                relatedRef = ref
                        }</span>
                }
        }

        <span class="cov0" title="0">noteMessage := note
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                noteMessage = fmt.Sprintf(note, args...)
        }</span>

        // For events.k8s.io/v1 API:
        // - ReportingInstance is required and must be non-empty
        // - Deprecated fields (firstTimestamp, lastTimestamp, count, source) must NOT be set
        <span class="cov0" title="0">reportingInstance := r.Source.Host
        if reportingInstance == "" </span><span class="cov0" title="0">{
                // Use component name as fallback if host is not set
                reportingInstance = r.Source.Component
        }</span>

        <span class="cov0" title="0">ev := &amp;eventsv1.Event{
                ObjectMeta: metav1.ObjectMeta{
                        GenerateName: metaObj.GetName() + "-",
                        Namespace:    ns,
                },
                Regarding:           *regardingRef,
                Related:             relatedRef,
                Reason:              reason,
                Note:                noteMessage,
                Type:                eventtype,
                Action:              action,
                ReportingController: r.Source.Component,
                ReportingInstance:   reportingInstance,
                EventTime:           metav1.MicroTime{Time: time.Now()},
                // NOTE: Do NOT set deprecated fields (DeprecatedSource, DeprecatedFirstTimestamp,
                // DeprecatedLastTimestamp, DeprecatedCount) - events.k8s.io/v1 API rejects them
        }
        // NOTE: Using Events().Create() instead of SSA.
        // Reason: Kubernetes Events are ephemeral, best-effort resources. They are
        // automatically garbage-collected by the API server (default TTL: 1 hour).
        // SSA would add unnecessary overhead for resources that are never updated.
        if created, err := r.Clientset.EventsV1().Events(ns).Create(context.Background(), ev, metav1.CreateOptions{}); err != nil </span><span class="cov0" title="0">{
                if r.Logger != nil </span><span class="cov0" title="0">{
                        // include namespace information for the involved object
                        fields := system.NamespacedFields(metaObj.GetName(), ns)
                        r.Logger.Warnw("failed to create kubernetes Event", append(fields, "reason", reason, "note", noteMessage, "error", err)...)
                }</span>
        } else<span class="cov0" title="0"> {
                if r.Logger != nil </span><span class="cov0" title="0">{
                        // created is namespaced where Namespace == ns
                        fields := system.NamespacedFields(created.GetName(), created.GetNamespace())
                        r.Logger.Debugw("kubernetes Event created", append(fields, "reason", reason, "note", noteMessage)...)
                }</span>
        }
}

// Ensure K8sEventRecorder satisfies events.EventRecorder
var _ events.EventRecorder = &amp;K8sEventRecorder{}
</pre>
		
		<pre class="file" id="file17" style="display: none">package breakglass

import (
        "context"
        "fmt"
        "time"

        telekomv1alpha1 "github.com/telekom/k8s-breakglass/api/v1alpha1"
        "github.com/telekom/k8s-breakglass/pkg/mail"
        "github.com/telekom/k8s-breakglass/pkg/metrics"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// ExpireApprovedSessions sets state to Expired for approved sessions that have passed ExpiresAt
func (wc *BreakglassSessionController) ExpireApprovedSessions() <span class="cov0" title="0">{
        // Use indexed query to fetch only approved sessions
        sessions, err := wc.sessionManager.GetSessionsByState(context.Background(), telekomv1alpha1.SessionStateApproved)
        if err != nil </span><span class="cov0" title="0">{
                wc.log.Error("error listing breakglass sessions for approved expiry", err)
                return
        }</span>
        <span class="cov0" title="0">for _, ses := range sessions </span><span class="cov0" title="0">{
                if IsSessionExpired(ses) </span><span class="cov0" title="0">{
                        // Log intent and timestamps for easier debugging
                        now := time.Now()
                        wc.log.Infow("Expiring approved session due to reached ExpiresAt", "session", ses.Name, "expiresAt", ses.Status.ExpiresAt.Time, "now", now)

                        // Prepare status transition
                        ses.Status.State = telekomv1alpha1.SessionStateExpired
                        ses.Status.Conditions = append(ses.Status.Conditions, metav1.Condition{
                                Type:               string(telekomv1alpha1.SessionConditionTypeExpired),
                                Status:             metav1.ConditionTrue,
                                LastTransitionTime: metav1.Now(),
                                Reason:             "ExpiredByTime",
                                Message:            "Session expired because its ExpiresAt has been reached.",
                        })
                        // set short reason for UI consumption
                        ses.Status.ReasonEnded = "timeExpired"

                        // Ensure we have the correct namespace/resourceVersion from the stored object before updating status.
                        if stored, gerr := wc.sessionManager.GetBreakglassSessionByName(context.Background(), ses.Name); gerr == nil </span><span class="cov0" title="0">{
                                // copy any necessary metadata so client can locate the object
                                ses.Namespace = stored.Namespace
                                ses.ResourceVersion = stored.ResourceVersion
                        }</span> else<span class="cov0" title="0"> {
                                // If we cannot refetch, log and proceed; Update may still fail and will be retried below
                                wc.log.Debugw("could not refetch session before status update; will attempt update anyway", "session", ses.Name, "error", gerr)
                        }</span>

                        // Persist the status change using SSA against the status subresource and retry on conflict.
                        <span class="cov0" title="0">var lastErr error
                        for attempt := range 3 </span><span class="cov0" title="0">{
                                if err := wc.sessionManager.UpdateBreakglassSessionStatus(context.Background(), ses); err == nil </span><span class="cov0" title="0">{
                                        lastErr = nil
                                        // count as expired when status update succeeds
                                        metrics.SessionExpired.WithLabelValues(ses.Spec.Cluster).Inc()
                                        // Emit audit event for session expiration
                                        wc.emitSessionExpiredAuditEvent(context.Background(), &amp;ses, "timeExpired")
                                        break</span>
                                } else<span class="cov0" title="0"> {
                                        lastErr = fmt.Errorf("status update attempt %d failed: %w", attempt+1, err)
                                        wc.log.Warnw("failed to update expired session status (will retry)", "session", ses.Name, "attempt", attempt+1, "error", err)

                                        // On conflict or other recoverable errors, re-fetch the latest object and reapply status changes
                                        if updated, gerr := wc.sessionManager.GetBreakglassSessionByName(context.Background(), ses.Name); gerr == nil </span><span class="cov0" title="0">{
                                                // copy status changes onto updated object and retry
                                                updated.Status.State = ses.Status.State
                                                updated.Status.Conditions = ses.Status.Conditions
                                                updated.Status.ReasonEnded = ses.Status.ReasonEnded
                                                ses = updated
                                        }</span> else<span class="cov0" title="0"> {
                                                // If we cannot re-fetch, short-circuit and surface error
                                                wc.log.Errorw("failed to refetch session after failed status update", "session", ses.Name, "error", gerr)
                                                break</span>
                                        }
                                        // small backoff between retries
                                        <span class="cov0" title="0">time.Sleep(200 * time.Millisecond)</span>
                                }
                        }
                        <span class="cov0" title="0">if lastErr != nil </span><span class="cov0" title="0">{
                                wc.log.Errorw("failed to update expired session after retries", "session", ses.Name, "error", lastErr)
                        }</span> else<span class="cov0" title="0"> {
                                // Send expiration email on successful status update
                                wc.sendSessionExpiredEmail(ses, "timeExpired")
                        }</span>
                }
        }
}

// sendSessionExpiredEmail sends a notification when a session expires
func (wc *BreakglassSessionController) sendSessionExpiredEmail(session telekomv1alpha1.BreakglassSession, expirationReason string) <span class="cov0" title="0">{
        if wc.disableEmail || wc.mailService == nil || !wc.mailService.IsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">reasonText := "Session expired"
        switch expirationReason </span>{
        case "timeExpired":<span class="cov0" title="0">
                reasonText = "Session validity period has ended"</span>
        case "approvalTimeout":<span class="cov0" title="0">
                reasonText = "Session approval timed out before being approved"</span>
        }

        <span class="cov0" title="0">params := mail.SessionExpiredMailParams{
                SubjectEmail:     session.Spec.User,
                RequestedRole:    session.Spec.GrantedGroup,
                Cluster:          session.Spec.Cluster,
                Username:         session.Spec.User,
                SessionID:        session.Name,
                StartedAt:        session.Status.ActualStartTime.Time.Format("2006-01-02 15:04:05 UTC"),
                ExpiredAt:        time.Now().Format("2006-01-02 15:04:05 UTC"),
                ExpirationReason: reasonText,
                BrandingName:     wc.config.Frontend.BrandingName,
        }

        body, err := mail.RenderSessionExpired(params)
        if err != nil </span><span class="cov0" title="0">{
                wc.log.Errorw("failed to render session expired email",
                        "session", session.Name,
                        "namespace", session.Namespace,
                        "error", err)
                return
        }</span>

        <span class="cov0" title="0">subject := fmt.Sprintf("[%s] Session Expired: %s", wc.config.Frontend.BrandingName, session.Name)
        if err := wc.mailService.Enqueue(session.Name, []string{session.Spec.User}, subject, body); err != nil </span><span class="cov0" title="0">{
                wc.log.Errorw("failed to enqueue session expired email",
                        "session", session.Name,
                        "namespace", session.Namespace,
                        "error", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package breakglass

import (
        "context"
        "time"

        telekomv1alpha1 "github.com/telekom/k8s-breakglass/api/v1alpha1"
        "github.com/telekom/k8s-breakglass/pkg/metrics"

        // ExpirePendingSessions sets state to Timeout for pending sessions that have expired (approval timeout)

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func (wc *BreakglassSessionController) ExpirePendingSessions() <span class="cov0" title="0">{
        // Use indexed query to fetch only pending sessions (matching ExpireApprovedSessions pattern)
        sessions, err := wc.sessionManager.GetSessionsByState(context.Background(), telekomv1alpha1.SessionStatePending)
        if err != nil </span><span class="cov0" title="0">{
                wc.log.Error("error listing breakglass sessions for pending expiry", err)
                return
        }</span>
        <span class="cov0" title="0">for _, ses := range sessions </span><span class="cov0" title="0">{
                if IsSessionApprovalTimedOut(ses) </span><span class="cov0" title="0">{
                        wc.log.Infow("Expiring pending session due to approval timeout", "session", ses.Name)
                        ses.Status.State = telekomv1alpha1.SessionStateTimeout

                        // Set RetainedUntil for timeout sessions
                        retainFor := ParseRetainFor(ses.Spec, wc.log)
                        ses.Status.RetainedUntil = metav1.NewTime(time.Now().Add(retainFor))

                        ses.Status.Conditions = append(ses.Status.Conditions, metav1.Condition{
                                Type:               string(telekomv1alpha1.SessionConditionTypeExpired),
                                Status:             metav1.ConditionTrue,
                                LastTransitionTime: metav1.Now(),
                                Reason:             "ApprovalTimeout",
                                Message:            "Session approval timed out.",
                        })
                        if err := wc.sessionManager.UpdateBreakglassSessionStatus(context.Background(), ses); err == nil </span><span class="cov0" title="0">{
                                // count the session as expired when status update succeeds
                                metrics.SessionExpired.WithLabelValues(ses.Spec.Cluster).Inc()
                                // Emit audit event for approval timeout
                                wc.emitSessionExpiredAuditEvent(context.Background(), &amp;ses, "approvalTimeout")
                                // Send expiration email for approval timeout
                                wc.sendSessionExpiredEmail(ses, "approvalTimeout")
                        }</span> else<span class="cov0" title="0"> {
                                wc.log.Errorw("failed to update session status while expiring pending session", "error", err)
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package breakglass

import (
        "context"
        "errors"
        "fmt"
        "strings"

        "go.uber.org/zap"
        authenticationv1 "k8s.io/api/authentication/v1"
        authenticationv1alpha1 "k8s.io/api/authentication/v1alpha1"
        authenticationv1beta1 "k8s.io/api/authentication/v1beta1"
        authorizationv1 "k8s.io/api/authorization/v1"
        k8serrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
        "sigs.k8s.io/controller-runtime/pkg/client/config"

        pkgconfig "github.com/telekom/k8s-breakglass/pkg/config"
)

type CanGroupsDoFunction func(ctx context.Context,
        rc *rest.Config,
        groups []string,
        sar authorizationv1.SubjectAccessReview,
        clustername string) (bool, error)

type GetUserGroupsFunction func(ctx context.Context, cug ClusterUserGroup) ([]string, error)

// Checks if operations defined in access review could be performed if user belongs to given groups on a given cluster.
func getConfigForClusterName(name string) (*rest.Config, error) <span class="cov0" title="0">{
        // try direct context name first
        cfg, err := config.GetConfigWithContext(name)
        if err == nil </span><span class="cov0" title="0">{
                zap.S().Debugw("Loaded rest.Config for cluster context", "cluster", name, "context", name)
                return cfg, nil
        }</span>
        <span class="cov0" title="0">kindCtx := fmt.Sprintf("kind-%s", name)
        if kindCfg, kerr := config.GetConfigWithContext(kindCtx); kerr == nil </span><span class="cov0" title="0">{
                zap.S().Debugw("Loaded rest.Config via kind- fallback", "cluster", name, "context", kindCtx)
                return kindCfg, nil
        }</span>
        <span class="cov0" title="0">zap.S().Warnw("Failed to load rest.Config for cluster", "cluster", name, "error", err.Error())
        return nil, err</span>
}

// CanGroupsDo impersonates given groups against provided rest.Config (target cluster kubeconfig), not the hub.
func CanGroupsDo(ctx context.Context,
        rc *rest.Config,
        groups []string,
        sar authorizationv1.SubjectAccessReview,
        clustername string,
) (bool, error) <span class="cov0" title="0">{
        if rc == nil </span><span class="cov0" title="0">{
                return false, errors.New("rest config is nil")
        }</span>
        <span class="cov0" title="0">zap.S().Debugw("Checking if groups can perform SAR operation", "groups", groups, "cluster", clustername)
        // Copy to avoid mutating shared config
        cfg := rest.CopyConfig(rc)
        cfg.Impersonate = rest.ImpersonationConfig{UserName: "system:auth-checker", Groups: groups}
        client, err := kubernetes.NewForConfig(cfg)
        if err != nil </span><span class="cov0" title="0">{
                zap.S().Errorw("Failed to create client for CanGroupsDo", "error", err.Error())
                return false, fmt.Errorf("failed to create client: %w", err)
        }</span>

        // Build SelfSubjectAccessReview spec based on whether we have resource or non-resource attributes
        <span class="cov0" title="0">var v1SarSpec authorizationv1.SelfSubjectAccessReviewSpec
        if sar.Spec.ResourceAttributes != nil </span><span class="cov0" title="0">{
                v1SarSpec.ResourceAttributes = &amp;authorizationv1.ResourceAttributes{
                        Namespace:   sar.Spec.ResourceAttributes.Namespace,
                        Verb:        sar.Spec.ResourceAttributes.Verb,
                        Group:       sar.Spec.ResourceAttributes.Group,
                        Resource:    sar.Spec.ResourceAttributes.Resource,
                        Subresource: sar.Spec.ResourceAttributes.Subresource,
                        Name:        sar.Spec.ResourceAttributes.Name,
                }
        }</span> else<span class="cov0" title="0"> if sar.Spec.NonResourceAttributes != nil </span><span class="cov0" title="0">{
                v1SarSpec.NonResourceAttributes = &amp;authorizationv1.NonResourceAttributes{
                        Path: sar.Spec.NonResourceAttributes.Path,
                        Verb: sar.Spec.NonResourceAttributes.Verb,
                }
        }</span> else<span class="cov0" title="0"> {
                return false, errors.New("sar spec must have either resourceAttributes or nonResourceAttributes")
        }</span>

        <span class="cov0" title="0">v1Sar := authorizationv1.SelfSubjectAccessReview{Spec: v1SarSpec}
        // NOTE: SelfSubjectAccessReview uses Create() to "submit" the review.
        // This is not a write operation in the traditional sense - it's a readonly query
        // to check permissions. The K8s API uses POST/Create for SubjectAccessReviews
        // because they are ephemeral request/response resources, not stored objects.
        response, err := client.AuthorizationV1().SelfSubjectAccessReviews().Create(ctx, &amp;v1Sar, metav1.CreateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                zap.S().Errorw("Failed to create SelfSubjectAccessReview", "error", err.Error())
                return false, err
        }</span>
        <span class="cov0" title="0">zap.S().Infow("SelfSubjectAccessReview result", "allowed", response.Status.Allowed)
        return response.Status.Allowed, nil</span>
}

// Legacy wrapper kept for compatibility (uses local context); prefer CanGroupsDo with explicit rest.Config.
func CanGroupsDoLegacy(ctx context.Context, groups []string, sar authorizationv1.SubjectAccessReview, clustername string) (bool, error) <span class="cov0" title="0">{
        rc, err := getConfigForClusterName(clustername)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return CanGroupsDo(ctx, rc, groups, sar, clustername)</span>
}

// stripOIDCPrefixes removes configured OIDC prefixes from user groups to allow matching with cluster groups
func stripOIDCPrefixes(groups []string, oidcPrefixes []string) []string <span class="cov0" title="0">{
        if len(oidcPrefixes) == 0 </span><span class="cov0" title="0">{
                zap.S().Debug("No OIDC prefixes configured, returning groups unchanged")
                return groups
        }</span>

        <span class="cov0" title="0">var strippedGroups []string
        zap.S().Debugw("Stripping OIDC prefixes from groups", "originalGroups", groups, "prefixes", oidcPrefixes)

        for _, group := range groups </span><span class="cov0" title="0">{
                strippedGroup := group
                for _, prefix := range oidcPrefixes </span><span class="cov0" title="0">{
                        if strings.HasPrefix(group, prefix) </span><span class="cov0" title="0">{
                                strippedGroup = strings.TrimPrefix(group, prefix)
                                zap.S().Debugw("Stripped OIDC prefix from group", "originalGroup", group, "prefix", prefix, "strippedGroup", strippedGroup)
                                break</span>
                        }
                }
                <span class="cov0" title="0">strippedGroups = append(strippedGroups, strippedGroup)</span>
        }

        // Ensure we return an empty slice instead of nil for consistency
        <span class="cov0" title="0">if strippedGroups == nil </span><span class="cov0" title="0">{
                strippedGroups = []string{}
        }</span>

        <span class="cov0" title="0">zap.S().Debugw("OIDC prefix stripping complete", "originalGroups", groups, "strippedGroups", strippedGroups)
        return strippedGroups</span>
}

// getUserGroupsInternal is a shared helper function for GetUserGroups and GetUserGroupsWithConfig.
// It fetches user groups assigned in a cluster (duplicating kubectl auth whoami logic) with optional OIDC prefix stripping.
// If configPath is empty, uses the default config path.
func getUserGroupsInternal(ctx context.Context, cug ClusterUserGroup, configPath string) ([]string, error) <span class="cov0" title="0">{
        // Load config to get OIDC prefixes
        cfg, err := pkgconfig.Load(configPath)
        configLoaded := true
        if err != nil </span><span class="cov0" title="0">{
                zap.S().Errorw("Failed to load config for OIDC prefixes", "error", err.Error())
                // Continue without OIDC prefix stripping if config loading fails
                configLoaded = false
        }</span>

        <span class="cov0" title="0">kubeCfg, err := getConfigForClusterName(cug.Clustername)
        if err != nil </span><span class="cov0" title="0">{
                zap.S().Errorw("GetUserGroups: rest.Config load failed", "cluster", cug.Clustername, "error", err.Error())
                return nil, fmt.Errorf("failed to get config: %w", err)
        }</span>

        <span class="cov0" title="0">kubeCfg.Impersonate = rest.ImpersonationConfig{
                UserName: cug.Username,
        }

        client, err := kubernetes.NewForConfig(kubeCfg)
        if err != nil </span><span class="cov0" title="0">{
                zap.S().Errorw("GetUserGroups: client construction failed", "cluster", cug.Clustername, "error", err.Error())
                return nil, fmt.Errorf("failed to create client: %w", err)
        }</span>

        <span class="cov0" title="0">var res runtime.Object
        res, err = client.AuthenticationV1().SelfSubjectReviews().Create(ctx, &amp;authenticationv1.SelfSubjectReview{}, metav1.CreateOptions{})

        if err != nil &amp;&amp; k8serrors.IsNotFound(err) </span><span class="cov0" title="0">{
                zap.S().Warn("Falling back to Beta API for SelfSubjectReview")
                res, err = client.AuthenticationV1beta1().SelfSubjectReviews().Create(ctx, &amp;authenticationv1beta1.SelfSubjectReview{}, metav1.CreateOptions{})
                if err != nil &amp;&amp; k8serrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        zap.S().Warn("Falling back to Alpha API for SelfSubjectReview")
                        res, err = client.AuthenticationV1alpha1().SelfSubjectReviews().Create(ctx, &amp;authenticationv1alpha1.SelfSubjectReview{}, metav1.CreateOptions{})
                }</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                zap.S().Errorw("Failed to get user's subject review", "error", err.Error())
                return nil, fmt.Errorf("failed to get users subject review: %w", err)
        }</span>

        <span class="cov0" title="0">ui, err := getUserInfo(res)
        if err != nil </span><span class="cov0" title="0">{
                zap.S().Errorw("Failed to get user info from response", "error", err.Error())
                return nil, fmt.Errorf("failed to get user info from response: %w", err)
        }</span>

        // Apply OIDC prefix stripping if config was loaded successfully
        <span class="cov0" title="0">originalGroups := ui.Groups
        finalGroups := originalGroups
        if configLoaded &amp;&amp; len(cfg.Kubernetes.OIDCPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                finalGroups = stripOIDCPrefixes(originalGroups, cfg.Kubernetes.OIDCPrefixes)
                zap.S().Infow("Applied OIDC prefix stripping", "originalGroups", originalGroups, "finalGroups", finalGroups, "oidcPrefixes", cfg.Kubernetes.OIDCPrefixes)
        }</span> else<span class="cov0" title="0"> {
                zap.S().Debug("No OIDC prefixes configured, using original groups")
        }</span>

        <span class="cov0" title="0">return finalGroups, nil</span>
}

func GetUserGroups(ctx context.Context, cug ClusterUserGroup) ([]string, error) <span class="cov0" title="0">{
        zap.S().Debugw("Getting user groups for cluster user group", "cluster", cug.Clustername, "username", cug.Username)

        finalGroups, err := getUserGroupsInternal(ctx, cug, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Removed BREAKGLASS_E2E_ASSUME_GROUPS fallback to ensure real cluster auth is always required.

        <span class="cov0" title="0">zap.S().Infow("GetUserGroups complete", "cluster", cug.Clustername, "username", cug.Username, "groups", finalGroups, "count", len(finalGroups))
        return finalGroups, nil</span>
}

// GetUserGroupsWithConfig returns users groups assigned in cluster with custom config path for OIDC prefix stripping.
func GetUserGroupsWithConfig(ctx context.Context, cug ClusterUserGroup, configPath string) ([]string, error) <span class="cov0" title="0">{
        zap.S().Debugw("Getting user groups for cluster user group with custom config", "cluster", cug.Clustername, "username", cug.Username, "configPath", configPath)

        finalGroups, err := getUserGroupsInternal(ctx, cug, configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">zap.S().Infow("GetUserGroupsWithConfig complete", "cluster", cug.Clustername, "username", cug.Username, "groups", finalGroups, "count", len(finalGroups))
        return finalGroups, nil</span>
}

func getUserInfo(obj runtime.Object) (authenticationv1.UserInfo, error) <span class="cov0" title="0">{
        switch val := obj.(type) </span>{
        case *authenticationv1alpha1.SelfSubjectReview:<span class="cov0" title="0">
                zap.S().Debug("Parsing user info from v1alpha1.SelfSubjectReview")
                return val.Status.UserInfo, nil</span>
        case *authenticationv1beta1.SelfSubjectReview:<span class="cov0" title="0">
                zap.S().Debug("Parsing user info from v1beta1.SelfSubjectReview")
                return val.Status.UserInfo, nil</span>
        case *authenticationv1.SelfSubjectReview:<span class="cov0" title="0">
                zap.S().Debug("Parsing user info from v1.SelfSubjectReview")
                return val.Status.UserInfo, nil</span>
        default:<span class="cov0" title="0">
                zap.S().Errorw("Unexpected response type for user info extraction", "type", fmt.Sprintf("%T", obj))
                return authenticationv1.UserInfo{}, fmt.Errorf("unexpected response type %T, expected SelfSubjectReview", obj)</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package breakglass

import (
        "errors"

        "github.com/gin-gonic/gin"
        v1alpha1 "github.com/telekom/k8s-breakglass/api/v1alpha1"
        "go.uber.org/zap"
)

type IdentityProvider interface {
        GetEmail(*gin.Context) (string, error)
        GetUsername(*gin.Context) string
        GetIdentity(*gin.Context) string
        // GetUserIdentifier returns the user identifier based on the configured claim type.
        // This is used to match the OIDC claim configuration on spoke clusters.
        GetUserIdentifier(*gin.Context, v1alpha1.UserIdentifierClaimType) (string, error)
}

type KeycloakIdentityProvider struct {
        log *zap.SugaredLogger
}

// getLogger returns the injected logger or falls back to the global logger.
func (kip KeycloakIdentityProvider) getLogger() *zap.SugaredLogger <span class="cov0" title="0">{
        if kip.log != nil </span><span class="cov0" title="0">{
                return kip.log
        }</span>
        <span class="cov0" title="0">return zap.S()</span>
}

func (kip KeycloakIdentityProvider) GetEmail(c *gin.Context) (email string, err error) <span class="cov0" title="0">{
        email = c.GetString("email")
        if email == "" </span><span class="cov0" title="0">{
                kip.getLogger().Warn("Keycloak provider failed to retrieve email identity from context")
                err = errors.New("keycloak provider failed to retrieve email identity")
        }</span> else<span class="cov0" title="0"> {
                kip.getLogger().Debugw("Keycloak provider retrieved email", "email", email)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (kip KeycloakIdentityProvider) GetIdentity(c *gin.Context) string <span class="cov0" title="0">{
        id := c.GetString("user_id")
        kip.getLogger().Debugw("Keycloak provider retrieved user_id", "user_id", id)
        return id
}</span>

func (kip KeycloakIdentityProvider) GetUsername(c *gin.Context) string <span class="cov0" title="0">{
        username := c.GetString("username")
        kip.getLogger().Debugw("Keycloak provider retrieved username", "username", username)
        return username
}</span>

// GetUserIdentifier returns the user identifier based on the configured claim type.
// It maps the UserIdentifierClaimType to the corresponding JWT claim value stored in context.
func (kip KeycloakIdentityProvider) GetUserIdentifier(c *gin.Context, claimType v1alpha1.UserIdentifierClaimType) (string, error) <span class="cov0" title="0">{
        var identifier string
        switch claimType </span>{
        case v1alpha1.UserIdentifierClaimEmail:<span class="cov0" title="0">
                identifier = c.GetString("email")
                if identifier == "" </span><span class="cov0" title="0">{
                        return "", errors.New("email claim not found in token")
                }</span>
        case v1alpha1.UserIdentifierClaimPreferredUsername:<span class="cov0" title="0">
                identifier = c.GetString("username")
                if identifier == "" </span><span class="cov0" title="0">{
                        return "", errors.New("preferred_username claim not found in token")
                }</span>
        case v1alpha1.UserIdentifierClaimSub:<span class="cov0" title="0">
                identifier = c.GetString("user_id")
                if identifier == "" </span><span class="cov0" title="0">{
                        return "", errors.New("sub claim not found in token")
                }</span>
        default:<span class="cov0" title="0">
                // Default to email for backward compatibility
                identifier = c.GetString("email")
                if identifier == "" </span><span class="cov0" title="0">{
                        return "", errors.New("email claim not found in token (default)")
                }</span>
        }
        <span class="cov0" title="0">kip.getLogger().Debugw("Keycloak provider retrieved user identifier", "claimType", claimType, "identifier", identifier)
        return identifier, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">/*
Copyright 2026.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package breakglass

import (
        "context"
        "fmt"
        "time"

        v1 "github.com/telekom/k8s-breakglass/api/v1alpha1"
        "github.com/telekom/k8s-breakglass/pkg/mail"
        "github.com/telekom/k8s-breakglass/pkg/metrics"
        "go.uber.org/zap"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// ScheduledSessionActivator handles activation of scheduled sessions.
// When a session's ScheduledStartTime is reached, it transitions from WaitingForScheduledTime to Approved
// and becomes available for use (RBAC group is applied).
type ScheduledSessionActivator struct {
        log            *zap.SugaredLogger
        sessionManager *SessionManager
        mailService    MailEnqueuer
        brandingName   string
        disableEmail   bool
}

// NewScheduledSessionActivator creates a new activator instance
func NewScheduledSessionActivator(log *zap.SugaredLogger, sessionManager *SessionManager) *ScheduledSessionActivator <span class="cov0" title="0">{
        return &amp;ScheduledSessionActivator{
                log:            log,
                sessionManager: sessionManager,
        }
}</span>

// WithMailService sets the mail service for sending activation notifications
func (ssa *ScheduledSessionActivator) WithMailService(mailService MailEnqueuer, brandingName string, disableEmail bool) *ScheduledSessionActivator <span class="cov0" title="0">{
        ssa.mailService = mailService
        ssa.brandingName = brandingName
        ssa.disableEmail = disableEmail
        return ssa
}</span>

// ActivateScheduledSessions checks for sessions in WaitingForScheduledTime state
// whose ScheduledStartTime has arrived, and transitions them to Approved state.
// This allows the RBAC group to be applied and the session to become usable.
func (ssa *ScheduledSessionActivator) ActivateScheduledSessions() <span class="cov0" title="0">{
        // Use indexed query to fetch only sessions waiting for scheduled time
        sessions, err := ssa.sessionManager.GetSessionsByState(context.Background(), v1.SessionStateWaitingForScheduledTime)
        if err != nil </span><span class="cov0" title="0">{
                ssa.log.Error("error listing sessions for scheduled activation", zap.String("error", err.Error()))
                return
        }</span>

        <span class="cov0" title="0">now := time.Now()
        for _, ses := range sessions </span><span class="cov0" title="0">{
                // Sanity check: session should have a scheduledStartTime
                if ses.Spec.ScheduledStartTime == nil || ses.Spec.ScheduledStartTime.IsZero() </span><span class="cov0" title="0">{
                        ssa.log.Warnw("session in WaitingForScheduledTime state has no ScheduledStartTime",
                                "session", ses.Name,
                                "namespace", ses.Namespace)
                        continue</span>
                }

                <span class="cov0" title="0">scheduledTime := ses.Spec.ScheduledStartTime.Time
                if now.Before(scheduledTime) </span><span class="cov0" title="0">{
                        // Not yet time for this session
                        continue</span>
                }

                // Time to activate!
                <span class="cov0" title="0">ssa.log.Infow("Activating scheduled session",
                        "session", ses.Name,
                        "namespace", ses.Namespace,
                        "scheduledStartTime", scheduledTime,
                        "now", now)

                // Transition to Approved state
                ses.Status.State = v1.SessionStateApproved
                ses.Status.ActualStartTime = metav1.Now()

                // Add condition for audit trail
                ses.Status.Conditions = append(ses.Status.Conditions, metav1.Condition{
                        Type:               "ScheduledStartTimeReached",
                        Status:             metav1.ConditionTrue,
                        LastTransitionTime: metav1.Now(),
                        Reason:             "ActivationTriggered",
                        Message:            "Session activated at scheduled start time",
                })

                // Update session status in cluster
                if err := ssa.sessionManager.UpdateBreakglassSessionStatus(context.Background(), ses); err != nil </span><span class="cov0" title="0">{
                        ssa.log.Errorw("failed to activate scheduled session",
                                "session", ses.Name,
                                "namespace", ses.Namespace,
                                "error", err)
                        continue</span>
                }

                <span class="cov0" title="0">ssa.log.Infow("Successfully activated scheduled session",
                        "session", ses.Name,
                        "namespace", ses.Namespace,
                        "actualStartTime", ses.Status.ActualStartTime.Time)

                // Record metric for successful activation
                metrics.SessionActivated.WithLabelValues(ses.Spec.Cluster).Inc()

                // Send activation notification email
                ssa.sendSessionActivatedEmail(ses)</span>

                // RBAC group will now be applied by the authorization controller
                // (same mechanism as immediate sessions)
        }
}

// sendSessionActivatedEmail sends a notification when a scheduled session becomes active
func (ssa *ScheduledSessionActivator) sendSessionActivatedEmail(session v1.BreakglassSession) <span class="cov0" title="0">{
        if ssa.disableEmail || ssa.mailService == nil || !ssa.mailService.IsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">params := mail.SessionActivatedMailParams{
                SubjectEmail:   session.Spec.User,
                RequestedRole:  session.Spec.GrantedGroup,
                Cluster:        session.Spec.Cluster,
                Username:       session.Spec.User,
                SessionID:      session.Name,
                ActivatedAt:    session.Status.ActualStartTime.Time.Format("2006-01-02 15:04:05 UTC"),
                ExpirationTime: session.Status.ExpiresAt.Time.Format("2006-01-02 15:04:05 UTC"),
                ApproverEmail:  session.Status.Approver,
                IDPName:        session.Spec.IdentityProviderName,
                IDPIssuer:      session.Spec.IdentityProviderIssuer,
                BrandingName:   ssa.brandingName,
        }

        body, err := mail.RenderSessionActivated(params)
        if err != nil </span><span class="cov0" title="0">{
                ssa.log.Errorw("failed to render session activated email",
                        "session", session.Name,
                        "namespace", session.Namespace,
                        "error", err)
                return
        }</span>

        <span class="cov0" title="0">subject := fmt.Sprintf("[%s] Session Activated: %s", ssa.brandingName, session.Name)
        if err := ssa.mailService.Enqueue(session.Name, []string{session.Spec.User}, subject, body); err != nil </span><span class="cov0" title="0">{
                ssa.log.Errorw("failed to enqueue session activated email",
                        "session", session.Name,
                        "namespace", session.Namespace,
                        "error", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package breakglass

import (
        telekomv1alpha1 "github.com/telekom/k8s-breakglass/api/v1alpha1"
        "k8s.io/apimachinery/pkg/runtime"
        utilruntime "k8s.io/apimachinery/pkg/util/runtime"
        clientgoscheme "k8s.io/client-go/kubernetes/scheme"
)

var Scheme = runtime.NewScheme()

func init() <span class="cov8" title="1">{
        utilruntime.Must(clientgoscheme.AddToScheme(Scheme))

        utilruntime.Must(telekomv1alpha1.AddToScheme(Scheme))
        // +kubebuilder:scaffold:scheme
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">// IsSessionApprovalTimedOut returns true if the session is still pending and TimeoutAt has passed.
package breakglass

import (
        "time"

        "github.com/telekom/k8s-breakglass/api/v1alpha1"
)

func IsSessionApprovalTimedOut(session v1alpha1.BreakglassSession) bool <span class="cov0" title="0">{
        // If session is already in timeout state, it's not "approval timed out" anymore - it's already timed out
        if session.Status.State == v1alpha1.SessionStateTimeout </span><span class="cov0" title="0">{
                return false
        }</span>
        // Session must be pending (not approved or rejected)
        <span class="cov0" title="0">if !session.Status.ApprovedAt.IsZero() || !session.Status.RejectedAt.IsZero() </span><span class="cov0" title="0">{
                return false
        }</span>
        // Timeout must be set and must have passed
        <span class="cov0" title="0">return !session.Status.TimeoutAt.IsZero() &amp;&amp; time.Now().After(session.Status.TimeoutAt.Time)</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package breakglass

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "slices"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/telekom/k8s-breakglass/api/v1alpha1"
        "github.com/telekom/k8s-breakglass/pkg/apiresponses"
        "github.com/telekom/k8s-breakglass/pkg/audit"
        "github.com/telekom/k8s-breakglass/pkg/config"
        "github.com/telekom/k8s-breakglass/pkg/mail"
        "github.com/telekom/k8s-breakglass/pkg/metrics"
        "github.com/telekom/k8s-breakglass/pkg/naming"
        "github.com/telekom/k8s-breakglass/pkg/system"
        "github.com/telekom/k8s-breakglass/pkg/utils"
        "go.uber.org/zap"
        authenticationv1 "k8s.io/api/authentication/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/fields"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

const (
        MonthDuration            = time.Hour * 24 * 30
        WeekDuration             = time.Hour * 24 * 7
        DefaultValidForDuration  = time.Hour
        DefaultRetainForDuration = MonthDuration
        APIContextTimeout        = 30 * time.Second // Timeout for API operations like session listing

        // MaxApproverGroupMembers limits the number of members resolved from a single approver group.
        // This prevents resource exhaustion from malicious or misconfigured groups with millions of members.
        // A warning is logged when truncation occurs.
        // NOTE: If you change this constant, also update the documentation in:
        //   - docs/configuration-reference.md (Approver Resolution Limits section)
        MaxApproverGroupMembers = 1000

        // MaxTotalApprovers limits the total number of unique approvers collected across all groups.
        // This provides an overall cap regardless of how many groups are configured. When this limit is
        // exceeded, additional approvers are ignored and a warning is logged to prevent resource exhaustion.
        // NOTE: If you change this constant, also update the documentation in:
        //   - docs/configuration-reference.md (Approver Resolution Limits section)
        MaxTotalApprovers = 5000
)

var ErrSessionNotFound error = errors.New("session not found")

// ApprovalCheckResult encapsulates the result of checking whether a user can approve a session.
// It provides specific denial reasons to enable proper error responses (401 vs 403) and user-friendly messages.
type ApprovalCheckResult struct {
        // Allowed is true if the user is authorized to approve/reject the session.
        Allowed bool
        // Reason describes why approval was denied (empty if Allowed is true).
        Reason ApprovalDenialReason
        // Message is a human-readable explanation for the denial.
        Message string
}

// ApprovalDenialReason categorizes why a user cannot approve a session.
type ApprovalDenialReason string

const (
        // ApprovalDenialNone indicates approval is allowed.
        ApprovalDenialNone ApprovalDenialReason = ""
        // ApprovalDenialUnauthenticated indicates the user's identity could not be verified.
        ApprovalDenialUnauthenticated ApprovalDenialReason = "UNAUTHENTICATED"
        // ApprovalDenialSelfApprovalBlocked indicates self-approval is blocked for this escalation/cluster.
        ApprovalDenialSelfApprovalBlocked ApprovalDenialReason = "SELF_APPROVAL_BLOCKED"
        // ApprovalDenialDomainNotAllowed indicates the approver's email domain is not in the allowed list.
        ApprovalDenialDomainNotAllowed ApprovalDenialReason = "DOMAIN_NOT_ALLOWED"
        // ApprovalDenialNotAnApprover indicates the user is not in any approver group/list for matching escalations.
        ApprovalDenialNotAnApprover ApprovalDenialReason = "NOT_AN_APPROVER"
        // ApprovalDenialNoMatchingEscalation indicates no escalation was found for the session's granted group.
        ApprovalDenialNoMatchingEscalation ApprovalDenialReason = "NO_MATCHING_ESCALATION"
)

// BreakglassSessionRequest is defined in clusteruser.go and includes an optional Reason field.

type BreakglassSessionController struct {
        log               *zap.SugaredLogger
        config            config.Config
        configPath        string               // Path to breakglass config file for OIDC prefix stripping
        configLoader      *config.CachedLoader // Cached config loader to avoid disk reads per request
        sessionManager    *SessionManager
        escalationManager *EscalationManager
        middleware        gin.HandlerFunc
        identityProvider  IdentityProvider
        mail              mail.Sender
        mailQueue         *mail.Queue
        mailService       MailEnqueuer
        auditService      AuditEmitter
        getUserGroupsFn   GetUserGroupsFunction
        disableEmail      bool
        ccProvider        interface {
                GetRESTConfig(ctx context.Context, name string) (*rest.Config, error)
        }
        clusterConfigManager *ClusterConfigManager

        // inFlightCreates prevents TOCTOU race conditions during session creation.
        // Without this guard, two concurrent requests for the same (cluster, user, group)
        // triple could both pass the duplicate check and create duplicate sessions.
        // The map key is "cluster/user/group". Effective for single-replica deployments;
        // multi-replica setups should additionally rely on webhook-based uniqueness enforcement.
        // Must be a pointer so it survives value-receiver method copies.
        inFlightCreates *sync.Map
}

// MailEnqueuer is an interface for enqueueing emails
type MailEnqueuer interface {
        Enqueue(sessionID string, recipients []string, subject, body string) error
        IsEnabled() bool
}

// AuditEmitter is an interface for emitting audit events
type AuditEmitter interface {
        Emit(ctx context.Context, event *audit.Event)
        IsEnabled() bool
}

// IsSessionPendingApproval returns true if the session is in Pending state (state-first validation)
// State takes absolute priority over timestamps. Terminal states (Rejected, Withdrawn, Expired, Timeout)
// are never pending, regardless of timestamp values.
func IsSessionPendingApproval(session v1alpha1.BreakglassSession) bool <span class="cov0" title="0">{
        // CRITICAL: Check STATE FIRST - terminal states are never pending
        if session.Status.State == v1alpha1.SessionStateRejected ||
                session.Status.State == v1alpha1.SessionStateWithdrawn ||
                session.Status.State == v1alpha1.SessionStateExpired ||
                session.Status.State == v1alpha1.SessionStateTimeout </span><span class="cov0" title="0">{
                return false
        }</span>

        // CRITICAL: Only Pending state is pending (not WaitingForScheduledTime or Approved)
        <span class="cov0" title="0">if session.Status.State != v1alpha1.SessionStatePending </span><span class="cov0" title="0">{
                return false
        }</span>

        // Now verify timeout status (secondary check after state verification)
        // If TimeoutAt is set and has passed, session is in timeout state (not pending)
        <span class="cov0" title="0">if !session.Status.TimeoutAt.IsZero() &amp;&amp; time.Now().After(session.Status.TimeoutAt.Time) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

func (BreakglassSessionController) BasePath() string <span class="cov0" title="0">{
        return "breakglassSessions"
}</span>

func (wc *BreakglassSessionController) Register(rg *gin.RouterGroup) error <span class="cov0" title="0">{
        // RESTful endpoints for breakglass sessions (no leading slash)
        rg.GET("", instrumentedHandler("handleGetBreakglassSessionStatus", wc.handleGetBreakglassSessionStatus))           // List/filter sessions
        rg.GET(":name", instrumentedHandler("handleGetBreakglassSessionByName", wc.handleGetBreakglassSessionByName))      // Get single session by name
        rg.POST("", instrumentedHandler("handleRequestBreakglassSession", wc.handleRequestBreakglassSession))              // Create session
        rg.POST(":name/approve", instrumentedHandler("handleApproveBreakglassSession", wc.handleApproveBreakglassSession)) // Approve session
        rg.POST(":name/reject", instrumentedHandler("handleRejectBreakglassSession", wc.handleRejectBreakglassSession))    // Reject session
        rg.POST(":name/withdraw", instrumentedHandler("handleWithdrawMyRequest", wc.handleWithdrawMyRequest))              // Withdraw session (by requester)
        rg.POST(":name/drop", instrumentedHandler("handleDropMySession", wc.handleDropMySession))                          // Drop session (owner can drop active or pending)
        rg.POST(":name/cancel", instrumentedHandler("handleApproverCancel", wc.handleApproverCancel))                      // Approver cancels a running/approved session
        return nil
}</span>

// decodeJSONStrict decodes JSON from an io.Reader into dest with DisallowUnknownFields
// enabled. This ensures that requests with unknown/typo'd field names are rejected
// rather than silently ignored, helping catch client bugs and typos early.
// It also ensures that the body contains exactly one JSON value and no trailing
// non-whitespace content.
func decodeJSONStrict(r io.Reader, dest interface{}) error <span class="cov0" title="0">{
        dec := json.NewDecoder(r)
        dec.DisallowUnknownFields()

        if err := dec.Decode(dest); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Ensure there is no extra non-whitespace data after the first JSON value.
        <span class="cov0" title="0">var extra struct{}
        if err := dec.Decode(&amp;extra); err != io.EOF </span><span class="cov0" title="0">{
                if err == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected extra JSON input")
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateSessionRequest validates the session request input
func (wc *BreakglassSessionController) validateSessionRequest(request BreakglassSessionRequest) error <span class="cov0" title="0">{
        if request.Clustername == "" </span><span class="cov0" title="0">{
                return errors.New("cluster is required")
        }</span>
        <span class="cov0" title="0">if request.Username == "" </span><span class="cov0" title="0">{
                return errors.New("user is required")
        }</span>
        <span class="cov0" title="0">if request.GroupName == "" </span><span class="cov0" title="0">{
                return errors.New("group is required")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// addIfNotPresent appends value to the slice only if it's not already present.
// Uses slices.Contains for efficiency.
func addIfNotPresent[T comparable](slice []T, value T) []T <span class="cov0" title="0">{
        if !slices.Contains(slice, value) </span><span class="cov0" title="0">{
                slice = append(slice, value)
        }</span>
        <span class="cov0" title="0">return slice</span>
}

func (wc *BreakglassSessionController) handleRequestBreakglassSession(c *gin.Context) <span class="cov0" title="0">{
        // Get correlation ID for consistent logging
        // request-scoped logger (includes cid, method, path)
        reqLog := system.GetReqLogger(c, wc.log)
        reqLog = system.EnrichReqLoggerWithAuth(c, reqLog)
        reqLog.Info("Processing breakglass session request")

        var request BreakglassSessionRequest
        if err := decodeJSONStrict(c.Request.Body, &amp;request); err != nil </span><span class="cov0" title="0">{
                reqLog.With("error", err).Error("Failed to decode JSON request body")
                apiresponses.RespondUnprocessableEntity(c, "failed to decode JSON request body (invalid JSON or unknown fields)")
                return
        }</span>

        // Debug: log decoded request to help trace missing or malformed fields in e2e
        <span class="cov0" title="0">reqLog.Debugw("Decoded breakglass session request", "request", request)

        // Resolve authenticated identities and enforce request user matching
        authEmail, emailErr := wc.identityProvider.GetEmail(c)
        authUsername := wc.identityProvider.GetUsername(c)
        authUserID := wc.identityProvider.GetIdentity(c)
        authIdentifiers := collectAuthIdentifiers(authEmail, authUsername, authUserID)
        if len(authIdentifiers) == 0 </span><span class="cov0" title="0">{
                reqLog.Error("No authenticated identity claims found in request context")
                apiresponses.RespondUnauthorizedWithMessage(c, "user identity not found")
                return
        }</span>
        <span class="cov0" title="0">if request.Username == "" </span><span class="cov0" title="0">{
                // default to authenticated identity to avoid spoofing
                request.Username = firstNonEmpty(authEmail, authUsername, authUserID)
        }</span> else<span class="cov0" title="0"> if !matchesAuthIdentifier(request.Username, authIdentifiers) </span><span class="cov0" title="0">{
                reqLog.Warnw("Request username does not match authenticated identity",
                        "requestUsername", request.Username,
                        "authIdentifiers", authIdentifiers)
                apiresponses.RespondForbidden(c, "user identity mismatch")
                return
        }</span>

        <span class="cov0" title="0">if err := wc.validateSessionRequest(request); err != nil </span><span class="cov0" title="0">{
                reqLog.With("error", err, "request", request).Warn("Invalid session request parameters")
                apiresponses.RespondUnprocessableEntity(c, "missing input request data: "+err.Error())
                return
        }</span>

        // Sanitize reason field to prevent injection attacks
        <span class="cov0" title="0">if err := request.SanitizeReason(); err != nil </span><span class="cov0" title="0">{
                reqLog.With("error", err).Warn("Reason field sanitization failed")
                apiresponses.RespondUnprocessableEntity(c, "invalid reason: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">ctx := c.Request.Context()
        cug := ClusterUserGroup{
                Clustername: request.Clustername,
                Username:    request.Username,
                GroupName:   request.GroupName,
        }
        reqLog = reqLog.With("cluster", cug.Clustername, "user", cug.Username, "group", cug.GroupName)
        reqLog.Info("Validated session request parameters")

        // Load global config via cached loader (avoids disk reads per request)
        var globalCfg *config.Config
        if wc.configLoader != nil </span><span class="cov0" title="0">{
                if cfg, cerr := wc.configLoader.Get(); cerr == nil </span><span class="cov0" title="0">{
                        globalCfg = &amp;cfg
                }</span> else<span class="cov0" title="0"> {
                        reqLog.With("error", fmt.Errorf("cached config load failed: %w", cerr)).Debug("Continuing without global config")
                }</span>
        }

        // Resolve user groups: prefer token groups, fallback to cluster-based resolution
        <span class="cov0" title="0">var userGroups []string
        if raw, exists := c.Get("groups"); exists </span><span class="cov0" title="0">{ // trace raw token groups before any normalization
                if arr, ok := raw.([]string); ok </span><span class="cov0" title="0">{
                        reqLog.With("rawTokenGroups", arr, "rawTokenGroupCount", len(arr)).Debug("Extracted raw token groups from JWT claims")
                }</span>
        }
        <span class="cov0" title="0">if tg, exists := c.Get("groups"); exists </span><span class="cov0" title="0">{
                if arr, ok := tg.([]string); ok </span><span class="cov0" title="0">{
                        userGroups = append(userGroups, arr...)
                }</span>
        }
        <span class="cov0" title="0">if len(userGroups) == 0 </span><span class="cov0" title="0">{ // fallback to cluster lookup
                var gerr error
                userGroups, gerr = wc.getUserGroupsFn(ctx, cug)
                if gerr != nil </span><span class="cov0" title="0">{
                        reqLog.With("error", gerr).Error("Failed to retrieve user groups for escalation determination")
                        apiresponses.RespondInternalError(c, "extract user groups", gerr, reqLog)
                        return
                }</span>
        }
        // Strip OIDC prefixes if configured (cluster retrieval might include them; token groups usually not)
        <span class="cov0" title="0">if globalCfg != nil &amp;&amp; len(globalCfg.Kubernetes.OIDCPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                userGroups = stripOIDCPrefixes(userGroups, globalCfg.Kubernetes.OIDCPrefixes)
        }</span>

        <span class="cov0" title="0">escalations, err := wc.escalationManager.GetClusterGroupBreakglassEscalations(ctx, cug.Clustername, userGroups)
        if err != nil </span><span class="cov0" title="0">{
                reqLog.Errorw("Error getting breakglass escalations", "error", err)
                apiresponses.RespondInternalError(c, "extract cluster breakglass escalation information", err, reqLog)
                return
        }</span>
        // We already filtered by cluster &amp; user groups; treat these as possible escalations.
        <span class="cov0" title="0">possibleEscals := escalations
        // Note: Do NOT call dropK8sInternalFieldsEscalation here - we need the UID for owner references.
        // The UID stripping is only for API response serialization, not for internal processing.
        if len(possibleEscals) == 0 </span><span class="cov0" title="0">{
                // Provide extra debug information in logs to help e2e diagnosis when no escalations are found
                rawGroups, _ := c.Get("groups")
                reqLog.Warnw("No escalation groups found for user", "user", cug.Username, "requestedGroup", cug.GroupName, "cluster", cug.Clustername, "resolvedUserGroups", userGroups, "rawTokenGroups", rawGroups)
                // Also log any escalations that exist for the cluster for visibility
                if escList, err := wc.escalationManager.GetClusterBreakglassEscalations(ctx, cug.Clustername); err == nil </span><span class="cov0" title="0">{
                        names := make([]string, 0, len(escList))
                        for _, e := range escList </span><span class="cov0" title="0">{
                                names = append(names, e.Name)
                        }</span>
                        <span class="cov0" title="0">reqLog.Debugw("Cluster escalations (for visibility)", "cluster", cug.Clustername, "escalations", names)</span>
                }
                // User is authenticated but not authorized for this group - return 403 Forbidden
                <span class="cov0" title="0">apiresponses.RespondForbidden(c, "user not authorized for requested group")
                return</span>
        } else<span class="cov0" title="0"> {
                reqLog.Debugw("Possible escalations found", "user", cug.Username, "cluster", cug.Clustername, "count", len(possibleEscals))
        }</span>

        // Single pass: collect available groups, approvers, and find matched escalation
        <span class="cov0" title="0">possible := make([]string, 0, len(possibleEscals))
        // Track approvers by group: map[groupName][]approverEmails
        approversByGroup := make(map[string][]string)
        allApprovers := []string{} // Deduplicated list of all approvers for filtering
        selectedDenyPolicies := []string{}
        var matchedEsc *v1alpha1.BreakglassEscalation

        reqLog.Debugw("Starting approver resolution from escalations",
                "escalationCount", len(possibleEscals),
                "requestedGroup", request.GroupName)

        for i := range possibleEscals </span><span class="cov0" title="0">{
                p := &amp;possibleEscals[i]
                possible = append(possible, p.Spec.EscalatedGroup)
                reqLog.Debugw("Processing escalation for approver resolution",
                        "escalationName", p.Name,
                        "escalatedGroup", p.Spec.EscalatedGroup,
                        "explicitUserCount", len(p.Spec.Approvers.Users),
                        "approverGroupCount", len(p.Spec.Approvers.Groups))

                // Always check if this is the matched escalation first (needed for deny policies)
                isMatchedEscalation := p.Spec.EscalatedGroup == request.GroupName &amp;&amp; matchedEsc == nil
                if isMatchedEscalation </span><span class="cov0" title="0">{
                        matchedEsc = p
                        selectedDenyPolicies = append(selectedDenyPolicies, p.Spec.DenyPolicyRefs...)
                        reqLog.Debugw("Matched escalation found during approver collection",
                                "escalationName", matchedEsc.Name,
                                "escalatedGroup", matchedEsc.Spec.EscalatedGroup,
                                "denyPolicyCount", len(selectedDenyPolicies))
                }</span>

                // Check total approvers limit before processing this escalation's approvers
                <span class="cov0" title="0">if len(allApprovers) &gt;= MaxTotalApprovers </span><span class="cov0" title="0">{
                        // If we've already found the matched escalation, break out entirely
                        // to avoid unnecessary work and log spam
                        if matchedEsc != nil </span><span class="cov0" title="0">{
                                reqLog.Infow("Total approvers limit reached and matched escalation found, stopping",
                                        "limit", MaxTotalApprovers,
                                        "matchedEscalation", matchedEsc.Name)
                                break</span>
                        }
                        // Otherwise continue looking for the matched escalation (but skip approver resolution)
                        <span class="cov0" title="0">reqLog.Debugw("Total approvers limit reached, skipping approver resolution for escalation",
                                "limit", MaxTotalApprovers,
                                "skippedEscalation", p.Name)
                        continue</span>
                }

                // Add explicit users (deduplicated) - track them under special key
                <span class="cov0" title="0">for _, user := range p.Spec.Approvers.Users </span><span class="cov0" title="0">{
                        if len(allApprovers) &gt;= MaxTotalApprovers </span><span class="cov0" title="0">{
                                reqLog.Warnw("Total approvers limit reached while adding explicit users",
                                        "limit", MaxTotalApprovers,
                                        "escalation", p.Name)
                                break</span>
                        }
                        <span class="cov0" title="0">before := len(allApprovers)
                        allApprovers = addIfNotPresent(allApprovers, user)
                        if len(allApprovers) &gt; before </span><span class="cov0" title="0">{
                                // Explicit users are tracked separately
                                approversByGroup["_explicit_users"] = addIfNotPresent(approversByGroup["_explicit_users"], user)
                                reqLog.Debugw("Added explicit approver user",
                                        "user", user,
                                        "escalation", p.Name,
                                        "totalApproversNow", len(allApprovers))
                        }</span>
                }

                // Resolve and add group members (deduplicated)
                <span class="cov0" title="0">for _, group := range p.Spec.Approvers.Groups </span><span class="cov0" title="0">{
                        // Check total approvers limit before processing this group
                        if len(allApprovers) &gt;= MaxTotalApprovers </span><span class="cov0" title="0">{
                                reqLog.Warnw("Total approvers limit reached, skipping remaining groups",
                                        "limit", MaxTotalApprovers,
                                        "skippedGroup", group,
                                        "escalation", p.Name)
                                break</span>
                        }

                        <span class="cov0" title="0">reqLog.Debugw("Resolving approver group members",
                                "group", group,
                                "escalation", p.Name)

                        var members []string
                        var err error

                        // Multi-IDP mode: use deduplicated members from status if available
                        if len(p.Spec.AllowedIdentityProvidersForApprovers) &gt; 0 &amp;&amp; p.Status.ApproverGroupMembers != nil </span><span class="cov0" title="0">{
                                if statusMembers, ok := p.Status.ApproverGroupMembers[group]; ok </span><span class="cov0" title="0">{
                                        members = statusMembers
                                        reqLog.Debugw("Using deduplicated members from status (multi-IDP mode)",
                                                "group", group,
                                                "escalation", p.Name,
                                                "memberCount", len(members))
                                }</span> else<span class="cov0" title="0"> {
                                        reqLog.Debugw("No members found in status for group (multi-IDP mode)",
                                                "group", group,
                                                "escalation", p.Name)
                                        continue</span>
                                }
                        } else<span class="cov0" title="0"> {
                                // Legacy mode: resolve from single IDP
                                if wc.escalationManager != nil &amp;&amp; wc.escalationManager.GetResolver() != nil </span><span class="cov0" title="0">{
                                        members, err = wc.escalationManager.GetResolver().Members(ctx, group)
                                        if err != nil </span><span class="cov0" title="0">{
                                                reqLog.Warnw("Failed to resolve approver group members", "group", group, "error", err)
                                                // Continue with other groups even if one fails
                                                continue</span>
                                        }
                                }
                        }

                        // Apply per-group member limit to prevent resource exhaustion
                        <span class="cov0" title="0">if len(members) &gt; MaxApproverGroupMembers </span><span class="cov0" title="0">{
                                reqLog.Warnw("Approver group has too many members, truncating",
                                        "group", group,
                                        "escalation", p.Name,
                                        "originalCount", len(members),
                                        "limit", MaxApproverGroupMembers)
                                members = members[:MaxApproverGroupMembers]
                        }</span>

                        // Log member count (after truncation) to avoid PII leakage for large groups.
                        // Only log individual members at Debug level when the group is small enough.
                        <span class="cov0" title="0">if len(members) &lt;= 20 </span><span class="cov0" title="0">{
                                reqLog.Debugw("Resolved approver group members",
                                        "group", group,
                                        "escalation", p.Name,
                                        "memberCount", len(members),
                                        "members", members)
                        }</span> else<span class="cov0" title="0"> {
                                reqLog.Debugw("Resolved approver group members",
                                        "group", group,
                                        "escalation", p.Name,
                                        "memberCount", len(members))
                        }</span>

                        // Calculate how many more approvers we can add
                        <span class="cov0" title="0">remainingCapacity := MaxTotalApprovers - len(allApprovers)
                        if remainingCapacity == 0 </span><span class="cov0" title="0">{
                                reqLog.Warnw("No remaining capacity for approvers, skipping group",
                                        "group", group,
                                        "escalation", p.Name,
                                        "totalApproversLimit", MaxTotalApprovers)
                                break</span>
                        }
                        <span class="cov0" title="0">if remainingCapacity &lt; len(members) </span><span class="cov0" title="0">{
                                reqLog.Warnw("Truncating members to fit within total approvers limit",
                                        "group", group,
                                        "escalation", p.Name,
                                        "originalCount", len(members),
                                        "truncatedTo", remainingCapacity,
                                        "totalApproversLimit", MaxTotalApprovers)
                                members = members[:remainingCapacity]
                        }</span>

                        <span class="cov0" title="0">countBefore := len(allApprovers)
                        for _, member := range members </span><span class="cov0" title="0">{
                                allApprovers = addIfNotPresent(allApprovers, member)
                                // Track member as belonging to this group
                                approversByGroup[group] = addIfNotPresent(approversByGroup[group], member)
                        }</span>
                        <span class="cov0" title="0">countAdded := len(allApprovers) - countBefore
                        reqLog.Debugw("Added group members to approvers",
                                "group", group,
                                "escalation", p.Name,
                                "newMembersAdded", countAdded,
                                "totalApproversNow", len(allApprovers))</span>
                }

                // Break outer loop if we've reached the maximum total approvers AND
                // we've already found the matched escalation. If matchedEsc is nil,
                // let the loop continue  the top-of-loop check will skip approver
                // resolution but still identify the matched escalation.
                <span class="cov0" title="0">if len(allApprovers) &gt;= MaxTotalApprovers &amp;&amp; matchedEsc != nil </span><span class="cov0" title="0">{
                        reqLog.Infow("Maximum total approvers limit reached, stopping escalation processing",
                                "limit", MaxTotalApprovers,
                                "matchedEscalation", matchedEsc.Name)
                        break</span>
                }
        }

        // Note: individual approvers not logged to reduce PII exposure
        <span class="cov0" title="0">reqLog.Infow("Completed approver resolution from escalations",
                "totalApproversCollected", len(allApprovers),
                "approverGroupsCount", len(approversByGroup),
                "requestedGroup", request.GroupName)

        if !slices.Contains(possible, request.GroupName) </span><span class="cov0" title="0">{
                reqLog.Warnw("User not authorized for group", "user", request.Username, "group", request.GroupName)
                // User is authenticated but not authorized for this group - return 403 Forbidden
                apiresponses.RespondForbidden(c, "user not authorized for requested group")
                return
        }</span>
        <span class="cov0" title="0">if matchedEsc != nil &amp;&amp; matchedEsc.Spec.RequestReason != nil &amp;&amp; matchedEsc.Spec.RequestReason.Mandatory </span><span class="cov0" title="0">{
                if strings.TrimSpace(request.Reason) == "" </span><span class="cov0" title="0">{
                        reqLog.Warnw("Missing required request reason", "group", request.GroupName)
                        apiresponses.RespondUnprocessableEntity(c, "missing required request reason")
                        return
                }</span>
        }

        // Determine the user identifier claim.
        // This ensures the session's spec.User matches what the spoke cluster's OIDC sends in SAR.
        // Priority: ClusterConfig &gt; Global config
        <span class="cov0" title="0">var userIdentifierClaim v1alpha1.UserIdentifierClaimType
        if globalCfg != nil </span><span class="cov0" title="0">{
                userIdentifierClaim = globalCfg.GetUserIdentifierClaim()
        }</span>

        // Check ClusterConfig for per-cluster override
        <span class="cov0" title="0">var clusterConfig *v1alpha1.ClusterConfig
        if wc.clusterConfigManager != nil </span><span class="cov0" title="0">{
                var ccErr error
                clusterConfig, ccErr = wc.clusterConfigManager.GetClusterConfigByName(ctx, request.Clustername)
                if ccErr != nil </span><span class="cov0" title="0">{
                        reqLog.Debugw("Could not fetch cluster config for user identifier claim",
                                "cluster", request.Clustername,
                                "error", ccErr)
                }</span> else<span class="cov0" title="0"> if clusterConfig.Spec.UserIdentifierClaim != "" </span><span class="cov0" title="0">{
                        userIdentifierClaim = clusterConfig.GetUserIdentifierClaim()
                        reqLog.Debugw("Using cluster-specific userIdentifierClaim",
                                "cluster", request.Clustername,
                                "userIdentifierClaim", userIdentifierClaim)
                }</span>
        }

        // Get the user identifier based on the configured claim type
        <span class="cov0" title="0">userIdentifier, err := wc.identityProvider.GetUserIdentifier(c, userIdentifierClaim)
        if err != nil </span><span class="cov0" title="0">{
                reqLog.Errorw("Error getting user identifier from token",
                        "error", err,
                        "userIdentifierClaim", userIdentifierClaim)
                apiresponses.RespondInternalError(c, fmt.Sprintf("extract user identifier (%s) from token", userIdentifierClaim), err, reqLog)
                return
        }</span>
        <span class="cov0" title="0">reqLog.Debugw("Resolved user identifier for session",
                "userIdentifier", userIdentifier,
                "userIdentifierClaim", userIdentifierClaim,
                "requestUsername", request.Username)

        // Guard against TOCTOU race: serialize concurrent session creation requests
        // for the same (cluster, user, group) triple so the duplicate check below
        // cannot be bypassed by a second request arriving before the first creates
        // the session in the API server.
        if wc.inFlightCreates != nil </span><span class="cov0" title="0">{
                createKey := request.Clustername + "/" + userIdentifier + "/" + request.GroupName
                if _, loaded := wc.inFlightCreates.LoadOrStore(createKey, true); loaded </span><span class="cov0" title="0">{
                        reqLog.Infow("Concurrent session creation already in-flight, returning conflict",
                                "cluster", request.Clustername, "user", userIdentifier, "group", request.GroupName)
                        c.JSON(http.StatusConflict, gin.H{"error": "session creation already in progress"})
                        return
                }</span>
                <span class="cov0" title="0">defer wc.inFlightCreates.Delete(createKey)</span>
        }

        <span class="cov0" title="0">ses, err := wc.getActiveBreakglassSession(ctx,
                userIdentifier, request.Clustername, request.GroupName)
        if err != nil </span><span class="cov0" title="0">{
                if !errors.Is(err, ErrSessionNotFound) </span><span class="cov0" title="0">{
                        reqLog.Errorw("Error getting breakglass sessions", "error", err)
                        apiresponses.RespondInternalError(c, "extract breakglass session information", err, reqLog)
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                // A matching session exists; decide response based on its canonical state.
                reqLog.Infow("Existing session found", "session", ses.Name, "cluster", request.Clustername, "user", userIdentifier, "group", request.GroupName, "state", ses.Status.State)
                // Remove k8s internal fields before returning session in API response
                dropK8sInternalFieldsSession(&amp;ses)

                // Approved session -&gt; explicit "already approved" error
                if ses.Status.State == v1alpha1.SessionStateApproved || !ses.Status.ApprovedAt.IsZero() </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, gin.H{"error": "already approved", "session": ses})
                        return
                }</span>

                // Pending (requested but not yet approved/rejected) -&gt; "already requested" with linked session
                <span class="cov0" title="0">if IsSessionPendingApproval(ses) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, gin.H{"error": "already requested", "session": ses})
                        return
                }</span>

                // Fallback: session exists but in another terminal state (e.g. timeout)  return generic conflict with session
                <span class="cov0" title="0">c.JSON(http.StatusConflict, gin.H{"error": "session exists", "session": ses})
                return</span>
        }

        <span class="cov0" title="0">if authEmail == "" </span><span class="cov0" title="0">{
                reqLog.Errorw("Error getting user identity email", "error", emailErr)
                apiresponses.RespondInternalError(c, "extract email from token", emailErr, reqLog)
                return
        }</span>
        <span class="cov0" title="0">username := wc.identityProvider.GetUsername(c)

        reqLog.Debugw("Session creation initiated by user",
                "requestorEmail", authEmail,
                "requestorUsername", username,
                "requestedGroup", request.GroupName,
                "requestedCluster", request.Clustername)

        // Initialize session spec and populate duration fields from matched escalation when available
        spec := v1alpha1.BreakglassSessionSpec{
                Cluster:        request.Clustername,
                User:           userIdentifier, // Use the identifier based on ClusterConfig's userIdentifierClaim
                GrantedGroup:   request.GroupName,
                DenyPolicyRefs: selectedDenyPolicies,
                RequestReason:  request.Reason,
        }

        // Multi-IDP: Populate IDP tracking fields from authentication middleware
        if idpName, exists := c.Get("identity_provider_name"); exists </span><span class="cov0" title="0">{
                if name, ok := idpName.(string); ok &amp;&amp; name != "" </span><span class="cov0" title="0">{
                        spec.IdentityProviderName = name
                }</span>
        }
        <span class="cov0" title="0">if issuer, exists := c.Get("issuer"); exists </span><span class="cov0" title="0">{
                if iss, ok := issuer.(string); ok &amp;&amp; iss != "" </span><span class="cov0" title="0">{
                        spec.IdentityProviderIssuer = iss
                }</span>
        }

        <span class="cov0" title="0">if matchedEsc != nil </span><span class="cov0" title="0">{
                // copy relevant duration-related fields from escalation spec to session spec
                spec.MaxValidFor = matchedEsc.Spec.MaxValidFor
                spec.RetainFor = matchedEsc.Spec.RetainFor

                // Copy reason configurations as snapshots so session is self-contained
                // This avoids needing to look up the escalation later
                if matchedEsc.Spec.RequestReason != nil </span><span class="cov0" title="0">{
                        spec.RequestReasonConfig = matchedEsc.Spec.RequestReason.DeepCopy()
                }</span>
                <span class="cov0" title="0">if matchedEsc.Spec.ApprovalReason != nil </span><span class="cov0" title="0">{
                        spec.ApprovalReasonConfig = matchedEsc.Spec.ApprovalReason.DeepCopy()
                }</span>

                // Determine AllowIDPMismatch flag: set to true when neither escalation nor cluster have IDP restrictions
                // This ensures backward compatibility for single-IDP deployments
                <span class="cov0" title="0">escalationHasIDPRestriction := len(matchedEsc.Spec.AllowedIdentityProviders) &gt; 0
                clusterHasIDPRestriction := false

                // Use the already-fetched clusterConfig for IDP restriction check (avoid duplicate fetch)
                if clusterConfig != nil </span><span class="cov0" title="0">{
                        clusterHasIDPRestriction = len(clusterConfig.Spec.IdentityProviderRefs) &gt; 0
                        reqLog.Debugw("Using already-fetched cluster config for IDP restriction check",
                                "cluster", request.Clustername,
                                "clusterHasIDPRestriction", clusterHasIDPRestriction,
                                "escalationHasIDPRestriction", escalationHasIDPRestriction)
                }</span> else<span class="cov0" title="0"> {
                        reqLog.Debugw("Cluster config not available for IDP check (will default to false for restriction)",
                                "cluster", request.Clustername)
                }</span>

                // AllowIDPMismatch=true means: ignore IDP checks during authorization
                // This is set when BOTH escalation and cluster have no IDP restrictions
                // This enables backward compatibility for deployments not using multi-IDP
                <span class="cov0" title="0">spec.AllowIDPMismatch = !escalationHasIDPRestriction &amp;&amp; !clusterHasIDPRestriction
                reqLog.Debugw("Set AllowIDPMismatch flag for session",
                        "allowIDPMismatch", spec.AllowIDPMismatch,
                        "escalationHasIDPRestriction", escalationHasIDPRestriction,
                        "clusterHasIDPRestriction", clusterHasIDPRestriction)

                // Validate and apply custom duration if provided
                if request.Duration &gt; 0 </span><span class="cov0" title="0">{
                        // Parse max allowed duration from string (e.g., "1h", "3600s", "7d")
                        d, err := v1alpha1.ParseDuration(matchedEsc.Spec.MaxValidFor)
                        if err != nil </span><span class="cov0" title="0">{
                                reqLog.Warnw("Failed to parse MaxValidFor duration", "error", err, "value", matchedEsc.Spec.MaxValidFor)
                                apiresponses.RespondInternalError(c, "parse escalation duration configuration", err, reqLog)
                                return
                        }</span>
                        <span class="cov0" title="0">maxAllowed := int64(d.Seconds())
                        if err := request.ValidateDuration(maxAllowed); err != nil </span><span class="cov0" title="0">{
                                reqLog.Warnw("Duration validation failed", "error", err, "requestedDuration", request.Duration, "maxAllowed", maxAllowed)
                                apiresponses.RespondUnprocessableEntity(c, "invalid duration: "+err.Error())
                                return
                        }</span>
                        // Convert custom duration to Go duration string (e.g., "1h30m")
                        <span class="cov0" title="0">customDuration := time.Duration(request.Duration) * time.Second
                        spec.MaxValidFor = customDuration.String()
                        reqLog.Debugw("Custom duration applied", "duration", request.Duration, "defaultMaxValidFor", matchedEsc.Spec.MaxValidFor, "customMaxValidFor", spec.MaxValidFor)</span>
                }

                // Store scheduled start time if provided
                <span class="cov0" title="0">if request.ScheduledStartTime != "" </span><span class="cov0" title="0">{
                        // Parse ISO 8601 datetime
                        scheduledTime, err := time.Parse(time.RFC3339, request.ScheduledStartTime)
                        if err != nil </span><span class="cov0" title="0">{
                                reqLog.Warnw("Failed to parse scheduledStartTime", "error", err, "value", request.ScheduledStartTime)
                                apiresponses.RespondUnprocessableEntity(c, "invalid scheduledStartTime format (expected ISO 8601)")
                                return
                        }</span>

                        // Ensure scheduled time is in the future
                        <span class="cov0" title="0">now := time.Now()
                        if scheduledTime.Before(now) </span><span class="cov0" title="0">{
                                reqLog.Warnw("scheduledStartTime is in the past",
                                        "requestedTime", request.ScheduledStartTime,
                                        "parsedUTC", scheduledTime.Format(time.RFC3339),
                                        "nowUTC", now.Format(time.RFC3339),
                                        "nowLocal", now.Local().Format(time.RFC3339),
                                        "parsedLocal", scheduledTime.Local().Format(time.RFC3339),
                                        "timeDiffSeconds", now.Unix()-scheduledTime.Unix())
                                apiresponses.RespondUnprocessableEntity(c, "scheduledStartTime must be in the future")
                                return
                        }</span>

                        <span class="cov0" title="0">spec.ScheduledStartTime = &amp;metav1.Time{Time: scheduledTime}
                        reqLog.Debugw("Scheduled start time set",
                                "scheduledStartTimeISO", request.ScheduledStartTime,
                                "scheduledTimeUTC", scheduledTime.Format(time.RFC3339),
                                "scheduledTimeLocal", scheduledTime.Local().Format(time.RFC3339),
                                "nowUTC", now.Format(time.RFC3339),
                                "secondsInFuture", scheduledTime.Unix()-now.Unix())</span>
                }
        }

        <span class="cov0" title="0">bs := v1alpha1.BreakglassSession{Spec: spec}
        // Add labels to sessions so label selectors can operate when field indices are unavailable
        if bs.Labels == nil </span><span class="cov0" title="0">{
                bs.Labels = map[string]string{}
        }</span>
        // Sanitize label values to conform to Kubernetes label restrictions (RFC1123-ish)
        <span class="cov0" title="0">bs.Labels["breakglass.t-caas.telekom.com/cluster"] = naming.ToRFC1123Label(request.Clustername)
        bs.Labels["breakglass.t-caas.telekom.com/user"] = naming.ToRFC1123Label(userIdentifier) // Use resolved identifier, not request.Username
        bs.Labels["breakglass.t-caas.telekom.com/group"] = naming.ToRFC1123Label(request.GroupName)
        // Ensure session is created in the same namespace as the matched escalation
        if matchedEsc != nil </span><span class="cov0" title="0">{
                reqLog.Debugw("Matched escalation found during session creation; attaching ownerRef",
                        "escalationName", matchedEsc.Name, "escalationUID", matchedEsc.UID, "escalationNamespace", matchedEsc.Namespace)
                bs.Namespace = matchedEsc.Namespace
                // Attach owner reference so the session can be linked back to its escalation
                // This allows other components (webhook/controller) to resolve the escalation
                // via the session's OwnerReferences.
                bs.OwnerReferences = []metav1.OwnerReference{{
                        APIVersion: v1alpha1.GroupVersion.String(),
                        Kind:       "BreakglassEscalation",
                        Name:       matchedEsc.Name,
                        UID:        matchedEsc.UID,
                        // Controller and BlockOwnerDeletion are optional; set Controller=true for clarity.
                        Controller: func() *bool </span><span class="cov0" title="0">{ b := true; return &amp;b }</span>(),
                }}
                <span class="cov0" title="0">reqLog.Debugw("OwnerReference prepared for session create", "ownerRefs", bs.OwnerReferences)</span>
        } else<span class="cov0" title="0"> {
                reqLog.Debugw("No matching escalation found during session creation; no ownerRef will be attached", "requestedGroup", request.GroupName, "cluster", request.Clustername)
        }</span>

        // If no escalation was matched, reject creation: sessions must be tied to an escalation
        <span class="cov0" title="0">if matchedEsc == nil </span><span class="cov0" title="0">{
                reqLog.Warnw("Refusing to create session without matched escalation", "user", userIdentifier, "cluster", request.Clustername, "group", request.GroupName)
                apiresponses.RespondUnauthorizedWithMessage(c, "no escalation found for requested group")
                return
        }</span>

        // Check session limits (IDP-level with escalation overrides)
        <span class="cov0" title="0">if err := wc.checkSessionLimits(ctx, matchedEsc, spec.IdentityProviderName, userIdentifier, userGroups, reqLog); err != nil </span><span class="cov0" title="0">{
                reqLog.Warnw("Session limit check failed", "error", err, "escalation", matchedEsc.Name, "user", userIdentifier)
                // Distinguish infrastructure errors (500) from user-facing limit errors (422).
                switch </span>{
                case apierrors.IsNotFound(err),
                        apierrors.IsForbidden(err),
                        apierrors.IsUnauthorized(err),
                        apierrors.IsTimeout(err),
                        apierrors.IsServerTimeout(err),
                        apierrors.IsTooManyRequests(err),
                        apierrors.IsInternalError(err),
                        errors.Is(err, context.DeadlineExceeded),
                        errors.Is(err, context.Canceled):<span class="cov0" title="0">
                        apiresponses.RespondInternalError(c, "check session limits", err, reqLog)</span>
                default:<span class="cov0" title="0">
                        apiresponses.RespondUnprocessableEntity(c, err.Error())</span>
                }
                <span class="cov0" title="0">return</span>
        }

        // Generate RFC1123-safe name parts for cluster and group
        <span class="cov0" title="0">safeCluster := naming.ToRFC1123Subdomain(request.Clustername)
        safeGroup := naming.ToRFC1123Subdomain(request.GroupName)
        bs.GenerateName = fmt.Sprintf("%s-%s-", safeCluster, safeGroup)
        if err := wc.sessionManager.AddBreakglassSession(ctx, &amp;bs); err != nil </span><span class="cov0" title="0">{
                reqLog.Errorw("error while adding breakglass session", "error", err)
                reason := "internal_error"
                if apierrors.IsInvalid(err) </span><span class="cov0" title="0">{
                        reason = "invalid"
                        apiresponses.RespondUnprocessableEntity(c, err.Error())
                }</span> else<span class="cov0" title="0"> if apierrors.IsForbidden(err) </span><span class="cov0" title="0">{
                        reason = "forbidden"
                        apiresponses.RespondForbidden(c, err.Error())
                }</span> else<span class="cov0" title="0"> if apierrors.IsBadRequest(err) </span><span class="cov0" title="0">{
                        reason = "bad_request"
                        apiresponses.RespondBadRequest(c, err.Error())
                }</span> else<span class="cov0" title="0"> {
                        apiresponses.RespondInternalError(c, "create session", err, reqLog)
                }</span>
                <span class="cov0" title="0">metrics.SessionCreateFailed.WithLabelValues(request.Clustername, reason).Inc()
                return</span>
        }
        // Note: bs already has its Name populated by AddBreakglassSession (passed as pointer).
        // Do not try to fetch it again as this can race with informer cache population.
        // Instead, reuse the bs object that was created.

        // Get approval timeout from escalation spec using helper
        <span class="cov0" title="0">approvalTimeout := ParseApprovalTimeout(matchedEsc.Spec, reqLog)
        if matchedEsc.Spec.ApprovalTimeout != "" </span><span class="cov0" title="0">{
                reqLog.Debugw("Using approval timeout from escalation spec", "approvalTimeout", approvalTimeout)
        }</span>

        // Compute retained-until at creation so sessions always expose when they will be cleaned up.
        <span class="cov0" title="0">retainFor := ParseRetainFor(spec, reqLog)

        bs.Status = v1alpha1.BreakglassSessionStatus{
                RetainedUntil: metav1.NewTime(time.Now().Add(retainFor)),
                TimeoutAt:     metav1.NewTime(time.Now().Add(approvalTimeout)), // Approval timeout
                State:         v1alpha1.SessionStatePending,
                Conditions: []metav1.Condition{{
                        Type:               string(v1alpha1.SessionConditionTypeIdle),
                        Status:             metav1.ConditionTrue,
                        LastTransitionTime: metav1.Now(),
                        Reason:             string(v1alpha1.SessionConditionReasonEditedByApprover),
                        Message:            fmt.Sprintf("User %q requested session.", username),
                }},
        }

        if err := wc.sessionManager.UpdateBreakglassSessionStatus(ctx, bs); err != nil </span><span class="cov0" title="0">{
                reqLog.Errorw("error while updating breakglass session", "error", err)
                apiresponses.RespondInternalError(c, "update session status", err, reqLog)
                return
        }</span>

        <span class="cov0" title="0">if wc.disableEmail </span><span class="cov0" title="0">{
                reqLog.Debug("Email sending disabled via --disable-email flag")
        }</span> else<span class="cov0" title="0"> if matchedEsc.Spec.DisableNotifications != nil &amp;&amp; *matchedEsc.Spec.DisableNotifications </span><span class="cov0" title="0">{
                reqLog.Infow("Email sending disabled for this escalation via DisableNotifications",
                        "escalationName", matchedEsc.Name,
                        "cluster", bs.Spec.Cluster,
                        "grantedGroup", bs.Spec.GrantedGroup)
        }</span> else<span class="cov0" title="0"> {
                reqLog.Infow("Resolved approvers from escalation (explicit users + group members)",
                        "approverCount", len(allApprovers),
                        "approvers", allApprovers,
                        "cluster", bs.Spec.Cluster,
                        "grantedGroup", bs.Spec.GrantedGroup)

                reqLog.Debugw("About to send breakglass request email",
                        "approvalsRequired", len(allApprovers),
                        "approvers", allApprovers,
                        "requestorEmail", authEmail,
                        "requestorUsername", username,
                        "grantedGroup", bs.Spec.GrantedGroup,
                        "cluster", bs.Spec.Cluster)
                if len(allApprovers) == 0 </span><span class="cov0" title="0">{
                        reqLog.Warnw("No approvers resolved for email notification; cannot send email with empty recipients",
                                "escalation", bs.Spec.GrantedGroup,
                                "cluster", bs.Spec.Cluster,
                                "requestorEmail", authEmail,
                                "requestorUsername", username)
                }</span> else<span class="cov0" title="0"> {
                        // Trigger a group sync before sending email (but still send based on current status)
                        if wc.escalationManager != nil &amp;&amp; wc.escalationManager.GetResolver() != nil </span><span class="cov0" title="0">{
                                // Capture the request-scoped logger (which contains cid) so background logs
                                // emitted during group sync include the same correlation id.
                                goroutineLog := reqLog.With("cluster", bs.Spec.Cluster)
                                go func(log *zap.SugaredLogger) </span><span class="cov0" title="0">{
                                        // Use a timeout context for background work to prevent goroutine leaks
                                        ctx, cancel := context.WithTimeout(context.Background(), APIContextTimeout)
                                        defer cancel()
                                        // Run a sync for all approver groups in the escalation(s) for this request
                                        escalations, err := wc.escalationManager.GetClusterGroupBreakglassEscalations(ctx, bs.Spec.Cluster, []string{})
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Warnw("Failed to list escalations for group sync", "error", err)
                                                return
                                        }</span>

                                        // Deduplicate groups across all escalations to avoid syncing the same group multiple times
                                        <span class="cov0" title="0">groupsToSync := make(map[string]bool)
                                        for _, esc := range escalations </span><span class="cov0" title="0">{
                                                for _, g := range esc.Spec.Approvers.Groups </span><span class="cov0" title="0">{
                                                        groupsToSync[g] = true
                                                }</span>
                                        }

                                        <span class="cov0" title="0">if len(groupsToSync) == 0 </span><span class="cov0" title="0">{
                                                log.Debugw("No approver groups found to sync", "cluster", bs.Spec.Cluster, "escalationCount", len(escalations))
                                                return
                                        }</span>

                                        <span class="cov0" title="0">log.Debugw("Syncing approver groups", "cluster", bs.Spec.Cluster, "groupCount", len(groupsToSync))
                                        for g := range groupsToSync </span><span class="cov0" title="0">{
                                                members, merr := wc.escalationManager.GetResolver().Members(ctx, g)
                                                if merr != nil </span><span class="cov0" title="0">{
                                                        log.Warnw("Group member resolution failed during sync", "group", g, "error", merr)
                                                        continue</span>
                                                }
                                                <span class="cov0" title="0">log.Debugw("Resolved group members for sync", "group", g, "count", len(members))</span>
                                        }
                                }(goroutineLog)
                        }

                        // Filter out excluded users/groups and hidden groups from approvers list
                        <span class="cov0" title="0">reqLog.Debugw("About to filter approvers",
                                "escalationName", matchedEsc.Name,
                                "preFilterApproverCount", len(allApprovers),
                                "preFilterApprovers", allApprovers)

                        filteredApprovers := wc.filterExcludedNotificationRecipients(reqLog, allApprovers, matchedEsc)
                        reqLog.Debugw("After filterExcludedNotificationRecipients",
                                "postExcludeApproverCount", len(filteredApprovers),
                                "postExcludeApprovers", filteredApprovers,
                                "excludedCount", len(allApprovers)-len(filteredApprovers))

                        filteredApprovers = wc.filterHiddenFromUIRecipients(reqLog, filteredApprovers, matchedEsc)
                        reqLog.Debugw("After filterHiddenFromUIRecipients",
                                "postHiddenFilterApproverCount", len(filteredApprovers),
                                "postHiddenFilterApprovers", filteredApprovers,
                                "hiddenFilteredOutCount", len(allApprovers)-len(filteredApprovers))

                        if len(filteredApprovers) == 0 </span><span class="cov0" title="0">{
                                reqLog.Infow("All approvers excluded from notifications via NotificationExclusions or HiddenFromUI",
                                        "escalationName", matchedEsc.Name,
                                        "originalApproverCount", len(allApprovers))
                        }</span> else<span class="cov0" title="0"> {
                                // Send separate emails per approver group
                                // Each email shows only the specific group that matched
                                wc.sendOnRequestEmailsByGroup(reqLog, bs, authEmail, username, filteredApprovers, approversByGroup, matchedEsc)
                        }</span>
                }
        }

        // Emit audit event for session creation
        <span class="cov0" title="0">wc.emitSessionAuditEvent(c.Request.Context(), audit.EventSessionRequested, &amp;bs, request.Username, "Session requested")

        reqLog.Debugw("Session created", "user", request.Username, "cluster", request.Clustername, "group", request.GroupName, "generatedName", bs.Name)
        c.JSON(http.StatusCreated, bs)</span>
}

func (wc *BreakglassSessionController) setSessionStatus(c *gin.Context, sesCondition v1alpha1.BreakglassSessionConditionType) <span class="cov0" title="0">{
        reqLog := system.GetReqLogger(c, wc.log)
        reqLog = system.EnrichReqLoggerWithAuth(c, reqLog)

        sessionName := c.Param("name")

        bs, err := wc.sessionManager.GetBreakglassSessionByName(c.Request.Context(), sessionName)
        if err != nil </span><span class="cov0" title="0">{
                reqLog.Error("error while getting breakglass session", zap.Error(err))
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        apiresponses.RespondNotFoundSimple(c, "session not found")
                }</span> else<span class="cov0" title="0"> {
                        apiresponses.RespondInternalError(c, "get session", err, reqLog)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Attempt to decode optional approver reason from the request body (for approve/reject)
        <span class="cov0" title="0">var approverPayload struct {
                Reason string `json:"reason,omitempty"`
        }
        // Ignore errors; payload is optional. Guard against nil Request.Body which can occur in tests/clients.
        if c.Request != nil &amp;&amp; c.Request.Body != nil </span><span class="cov0" title="0">{
                if err := decodeJSONStrict(c.Request.Body, &amp;approverPayload); err != nil </span><span class="cov0" title="0">{
                        if !errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                                reqLog.Debugw("Failed to decode optional approver payload (using empty values)", "error", err)
                        }</span>
                }
        }
        // Sanitize approver reason to prevent injection attacks
        <span class="cov0" title="0">if approverPayload.Reason != "" </span><span class="cov0" title="0">{
                sanitized, err := SanitizeReasonText(approverPayload.Reason)
                if err != nil </span><span class="cov0" title="0">{
                        reqLog.Warnw("Failed to sanitize approver reason, using empty string", "error", err)
                        approverPayload.Reason = "" // Use empty string as safe fallback
                }</span> else<span class="cov0" title="0"> {
                        approverPayload.Reason = sanitized
                }</span>
        }

        <span class="cov0" title="0">var lastCondition metav1.Condition
        if l := len(bs.Status.Conditions); l &gt; 0 </span><span class="cov0" title="0">{
                lastCondition = bs.Status.Conditions[l-1]
        }</span>

        // If the session already has the same last condition, return conflict to avoid repeated transitions.
        <span class="cov0" title="0">if lastCondition.Type == string(sesCondition) </span><span class="cov0" title="0">{
                c.JSON(http.StatusConflict, struct {
                        Error   string                     `json:"error"`
                        Code    string                     `json:"code"`
                        Session v1alpha1.BreakglassSession `json:"session"`
                }{
                        Error:   "session already in requested state",
                        Code:    "CONFLICT",
                        Session: bs,
                })
                return
        }</span>

        // Different actions have different preconditions:
        // - Approve and Reject must only be executed when the session is pending.
        // - Other actions should be blocked only when the session is already in a true terminal state
        //   (Rejected, Withdrawn, Expired, Timeout). Approved is intentionally not part of that list
        //   because approved sessions may later transition to expired/dropped by owner or canceled by approver.
        <span class="cov0" title="0">currState := bs.Status.State
        if sesCondition == v1alpha1.SessionConditionTypeApproved || sesCondition == v1alpha1.SessionConditionTypeRejected </span><span class="cov0" title="0">{
                if currState != v1alpha1.SessionStatePending </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, struct {
                                Error   string                     `json:"error"`
                                Code    string                     `json:"code"`
                                Session v1alpha1.BreakglassSession `json:"session"`
                        }{
                                Error:   fmt.Sprintf("session must be pending to perform %s; current state: %s", sesCondition, currState),
                                Code:    "BAD_REQUEST",
                                Session: bs,
                        })
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                if currState == v1alpha1.SessionStateRejected || currState == v1alpha1.SessionStateWithdrawn || currState == v1alpha1.SessionStateExpired || currState == v1alpha1.SessionStateTimeout </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, struct {
                                Error   string                     `json:"error"`
                                Code    string                     `json:"code"`
                                Session v1alpha1.BreakglassSession `json:"session"`
                        }{
                                Error:   fmt.Sprintf("session is in terminal state %s and cannot be modified", currState),
                                Code:    "BAD_REQUEST",
                                Session: bs,
                        })
                        return
                }</span>
        }

        // Authorization: determine whether the caller is allowed to perform the action.
        // Allow the session requester to reject their own pending session. For reject actions only,
        // if the caller is the original requester and the session is still pending, bypass the approver check.
        <span class="cov0" title="0">allowOwnerReject := false
        if sesCondition == v1alpha1.SessionConditionTypeRejected </span><span class="cov0" title="0">{
                if requesterEmail, err := wc.identityProvider.GetEmail(c); err == nil </span><span class="cov0" title="0">{
                        if requesterEmail == bs.Spec.User &amp;&amp; IsSessionPendingApproval(bs) </span><span class="cov0" title="0">{
                                allowOwnerReject = true
                        }</span>
                }
        }

        <span class="cov0" title="0">if !allowOwnerReject </span><span class="cov0" title="0">{
                authResult := wc.checkApprovalAuthorization(c, bs)
                if !authResult.Allowed </span><span class="cov0" title="0">{
                        // Use appropriate HTTP status code based on denial reason:
                        // - 401 for authentication failures (can't identify user)
                        // - 403 for authorization failures (user identified but not allowed)
                        switch authResult.Reason </span>{
                        case ApprovalDenialUnauthenticated:<span class="cov0" title="0">
                                apiresponses.RespondUnauthorizedWithMessage(c, authResult.Message)</span>
                        case ApprovalDenialSelfApprovalBlocked:<span class="cov0" title="0">
                                apiresponses.RespondForbidden(c, authResult.Message)</span>
                        case ApprovalDenialDomainNotAllowed:<span class="cov0" title="0">
                                apiresponses.RespondForbidden(c, authResult.Message)</span>
                        case ApprovalDenialNotAnApprover:<span class="cov0" title="0">
                                apiresponses.RespondForbidden(c, authResult.Message)</span>
                        case ApprovalDenialNoMatchingEscalation:<span class="cov0" title="0">
                                apiresponses.RespondForbidden(c, authResult.Message)</span>
                        default:<span class="cov0" title="0">
                                // Fallback for unknown reasons
                                apiresponses.RespondForbidden(c, "Access denied")</span>
                        }
                        <span class="cov0" title="0">return</span>
                }
        }

        <span class="cov0" title="0">switch sesCondition </span>{
        case v1alpha1.SessionConditionTypeApproved:<span class="cov0" title="0">
                // Clear any previous rejection timestamp so the approved state is canonical.
                bs.Status.RejectedAt = metav1.Time{}
                bs.Status.ApprovedAt = metav1.Now()

                // Determine expiry based on session spec MaxValidFor if provided, otherwise use default
                validFor := ParseMaxValidFor(bs.Spec, reqLog)

                // Determine retention based on session spec RetainFor if provided, otherwise use default
                retainFor := ParseRetainFor(bs.Spec, reqLog)

                bs.Status.TimeoutAt = metav1.Time{} // Clear approval timeout

                // Check if session has a scheduled start time
                if bs.Spec.ScheduledStartTime != nil &amp;&amp; !bs.Spec.ScheduledStartTime.IsZero() </span><span class="cov0" title="0">{
                        // Scheduled session: enter WaitingForScheduledTime state
                        // RBAC group will NOT be applied until activation time is reached
                        bs.Status.State = v1alpha1.SessionStateWaitingForScheduledTime
                        // Calculate expiry and retention from ScheduledStartTime, not from now
                        bs.Status.ExpiresAt = metav1.NewTime(bs.Spec.ScheduledStartTime.Add(validFor))
                        bs.Status.RetainedUntil = metav1.NewTime(bs.Spec.ScheduledStartTime.Add(validFor).Add(retainFor))
                        // ActualStartTime will be set during activation
                        bs.Status.ActualStartTime = metav1.Time{}
                        reqLog.Infow("Session approved with scheduled start time",
                                "session", bs.Name,
                                "scheduledStartTime", bs.Spec.ScheduledStartTime.Time,
                                "expiresAt", bs.Status.ExpiresAt.Time,
                        )
                }</span> else<span class="cov0" title="0"> {
                        // Immediate session: activate now (original behavior)
                        bs.Status.State = v1alpha1.SessionStateApproved
                        bs.Status.ActualStartTime = metav1.Now() // For consistency
                        // Calculate expiry and retention from now
                        bs.Status.ExpiresAt = metav1.NewTime(bs.Status.ApprovedAt.Add(validFor))
                        bs.Status.RetainedUntil = metav1.NewTime(time.Now().Add(retainFor))
                        // RBAC group is immediately applied (via webhook or controller)
                        reqLog.Infow("Session approved and activated immediately",
                                "session", bs.Name,
                                "expiresAt", bs.Status.ExpiresAt.Time,
                        )
                }</span>
                // record approver
                <span class="cov0" title="0">approverEmail, _ := wc.identityProvider.GetEmail(c)
                if approverEmail != "" </span><span class="cov0" title="0">{
                        bs.Status.Approver = approverEmail
                        // append to approvers history if not already present
                        bs.Status.Approvers = addIfNotPresent(bs.Status.Approvers, approverEmail)
                }</span>
                // store approver reason if provided
                <span class="cov0" title="0">if strings.TrimSpace(approverPayload.Reason) != "" </span><span class="cov0" title="0">{
                        bs.Status.ApprovalReason = approverPayload.Reason
                }</span>
        case v1alpha1.SessionConditionTypeRejected:<span class="cov0" title="0">
                // IMPORTANT: Do NOT clear existing timestamps. We want to preserve history.
                // Only set state and rejection-specific timestamp.
                bs.Status.RejectedAt = metav1.Now()
                bs.Status.State = v1alpha1.SessionStateRejected
                bs.Status.ReasonEnded = "rejected"

                // Set RetainedUntil for rejected sessions
                retainFor := ParseRetainFor(bs.Spec, reqLog)
                bs.Status.RetainedUntil = metav1.NewTime(time.Now().Add(retainFor))

                // record approver (rejector)
                rejectorEmail, _ := wc.identityProvider.GetEmail(c)
                if rejectorEmail != "" </span><span class="cov0" title="0">{
                        bs.Status.Approver = rejectorEmail
                        bs.Status.Approvers = addIfNotPresent(bs.Status.Approvers, rejectorEmail)
                }</span>
                // store approver reason if provided
                <span class="cov0" title="0">if strings.TrimSpace(approverPayload.Reason) != "" </span><span class="cov0" title="0">{
                        bs.Status.ApprovalReason = approverPayload.Reason
                }</span>
        case v1alpha1.SessionConditionTypeIdle:<span class="cov0" title="0">
                reqLog.Error("error setting session status to idle which should be only initial state")
                apiresponses.RespondBadRequest(c, "cannot set session status to idle (initial state only)")
                return</span>
        default:<span class="cov0" title="0">
                reqLog.Error("unknown session condition type", zap.String("type", string(sesCondition)))
                apiresponses.RespondBadRequest(c, fmt.Sprintf("unknown session condition type: %s", sesCondition))
                return</span>
        }

        <span class="cov0" title="0">username, _ := wc.identityProvider.GetEmail(c)
        bs.Status.Conditions = append(bs.Status.Conditions, metav1.Condition{
                Type:               string(sesCondition),
                Status:             metav1.ConditionTrue,
                LastTransitionTime: metav1.Now(),
                Reason:             string(v1alpha1.SessionConditionReasonEditedByApprover),
                Message:            fmt.Sprintf("User %q set session to %s", username, sesCondition),
        })

        if err := wc.sessionManager.UpdateBreakglassSessionStatus(c.Request.Context(), bs); err != nil </span><span class="cov0" title="0">{
                reqLog.Error("error while updating breakglass session", zap.Error(err))
                if apierrors.IsConflict(err) </span><span class="cov0" title="0">{
                        apiresponses.RespondConflict(c, "session update conflict, please retry")
                }</span> else<span class="cov0" title="0"> if apierrors.IsInvalid(err) </span><span class="cov0" title="0">{
                        apiresponses.RespondUnprocessableEntity(c, err.Error())
                }</span> else<span class="cov0" title="0"> {
                        apiresponses.RespondInternalError(c, "update session status", err, reqLog)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Get approver identity for audit events
        <span class="cov0" title="0">approver := wc.identityProvider.GetUsername(c)
        if approver == "" </span><span class="cov0" title="0">{
                if email, err := wc.identityProvider.GetEmail(c); err == nil </span><span class="cov0" title="0">{
                        approver = email
                }</span>
        }

        // Track metrics for session lifecycle events
        <span class="cov0" title="0">switch sesCondition </span>{
        case v1alpha1.SessionConditionTypeApproved:<span class="cov0" title="0">
                metrics.SessionApproved.WithLabelValues(bs.Spec.Cluster).Inc()
                // Track if session was approved with specific IDP
                if bs.Spec.IdentityProviderName != "" </span><span class="cov0" title="0">{
                        metrics.SessionApprovedWithIDP.WithLabelValues(bs.Spec.IdentityProviderName).Inc()
                }</span>
                // Also track if it was a scheduled session that got approved
                <span class="cov0" title="0">if bs.Spec.ScheduledStartTime != nil &amp;&amp; !bs.Spec.ScheduledStartTime.IsZero() </span><span class="cov0" title="0">{
                        metrics.SessionScheduled.WithLabelValues(bs.Spec.Cluster).Inc()
                }</span>

                // Emit audit event for session approval
                <span class="cov0" title="0">wc.emitSessionAuditEvent(c.Request.Context(), audit.EventSessionApproved, &amp;bs, approver, "Session approved")

                // Send approval notification email to requester
                if !wc.disableEmail &amp;&amp; bs.Spec.User != "" &amp;&amp; (wc.mailService != nil &amp;&amp; wc.mailService.IsEnabled() || wc.mailQueue != nil) </span><span class="cov0" title="0">{
                        wc.sendSessionApprovalEmail(reqLog, bs)
                }</span>
        case v1alpha1.SessionConditionTypeRejected:<span class="cov0" title="0">
                metrics.SessionRejected.WithLabelValues(bs.Spec.Cluster).Inc()
                // Emit audit event for session rejection
                wc.emitSessionAuditEvent(c.Request.Context(), audit.EventSessionRejected, &amp;bs, approver, "Session rejected")

                // Send rejection notification email to requester
                if !wc.disableEmail &amp;&amp; bs.Spec.User != "" &amp;&amp; (wc.mailService != nil &amp;&amp; wc.mailService.IsEnabled() || wc.mailQueue != nil) </span><span class="cov0" title="0">{
                        wc.sendSessionRejectionEmail(reqLog, bs)
                }</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, bs)</span>
}

func (wc *BreakglassSessionController) getActiveBreakglassSession(ctx context.Context,
        username,
        clustername,
        group string,
) (v1alpha1.BreakglassSession, error) <span class="cov0" title="0">{
        selector := fields.SelectorFromSet(
                fields.Set{
                        "spec.cluster":      clustername,
                        "spec.user":         username,
                        "spec.grantedGroup": group,
                },
        )
        wc.log.Debugw("Querying for active breakglass session", "user", username, "cluster", clustername, "group", group)
        sessions, err := wc.sessionManager.GetBreakglassSessionsWithSelector(ctx, selector)
        if err != nil </span><span class="cov0" title="0">{
                wc.log.Error("Failed to list sessions for getActiveBreakglassSession", zap.Error(err))
                return v1alpha1.BreakglassSession{}, fmt.Errorf("failed to list sessions: %w", err)
        }</span>

        <span class="cov0" title="0">validSessions := make([]v1alpha1.BreakglassSession, 0, len(sessions))
        for _, ses := range sessions </span><span class="cov0" title="0">{
                if !IsSessionActive(ses) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">wc.log.Debugw("Found active session candidate", "session", ses.Name)
                validSessions = append(validSessions, ses)</span>
        }

        <span class="cov0" title="0">if len(validSessions) == 0 </span><span class="cov0" title="0">{
                wc.log.Infow("No active breakglass session found", "user", username, "cluster", clustername, "group", group)
                return v1alpha1.BreakglassSession{}, ErrSessionNotFound
        }</span> else<span class="cov0" title="0"> if len(validSessions) &gt; 1 </span><span class="cov0" title="0">{
                wc.log.Error("There is more than a single active breakglass session; this should not happen",
                        zap.Int("num_sessions", len(validSessions)),
                        zap.String("user_data", fmt.Sprintf("%#v", ClusterUserGroup{
                                Clustername: clustername,
                                Username:    username,
                                GroupName:   group,
                        })))
        }</span>
        <span class="cov0" title="0">wc.log.Infow("Returning active breakglass session", "session", validSessions[0].Name)
        return validSessions[0], nil</span>
}

// checkSessionLimits verifies that creating a new session won't exceed session limits.
// Limits are resolved in order of precedence:
// 1. Escalation override (sessionLimitsOverride.unlimited = true disables limits)
// 2. Escalation override (sessionLimitsOverride.maxActiveSessionsPerUser and/or maxActiveSessionsTotal)
// 3. IDP group override (sessionLimits.groupOverrides[].unlimited or maxActiveSessionsPerUser)
// 4. IDP default (sessionLimits.maxActiveSessionsPerUser)
//
// Note: maxActiveSessionsTotal is only available at escalation level, not IDP level.
// Per-user limits are checked globally across all escalations; total limits are per-escalation.
// Returns nil if the session can be created, or an error describing the limit violation.
func (wc *BreakglassSessionController) checkSessionLimits(
        ctx context.Context,
        escalation *v1alpha1.BreakglassEscalation,
        idpName string,
        userIdentifier string,
        userGroups []string,
        log *zap.SugaredLogger,
) error <span class="cov0" title="0">{
        // 1. Check escalation-level override first
        if escalation.Spec.SessionLimitsOverride != nil </span><span class="cov0" title="0">{
                override := escalation.Spec.SessionLimitsOverride
                if override.Unlimited </span><span class="cov0" title="0">{
                        log.Debugw("Session limits disabled via escalation override (unlimited)",
                                "escalation", escalation.Name)
                        return nil
                }</span>
                // Check per-user limit from escalation override
                <span class="cov0" title="0">if override.MaxActiveSessionsPerUser != nil </span><span class="cov0" title="0">{
                        limit := *override.MaxActiveSessionsPerUser
                        log.Debugw("Using escalation-level per-user session limit override",
                                "escalation", escalation.Name,
                                "maxPerUser", limit)
                        if err := wc.checkUserSessionCount(ctx, userIdentifier, limit, "escalation override", log); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                // Check total limit from escalation override
                <span class="cov0" title="0">if override.MaxActiveSessionsTotal != nil </span><span class="cov0" title="0">{
                        limit := *override.MaxActiveSessionsTotal
                        log.Debugw("Using escalation-level total session limit override",
                                "escalation", escalation.Name,
                                "maxTotal", limit)
                        if err := wc.checkTotalSessionCount(ctx, escalation, limit, "escalation override", log); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                // Only return early if escalation has per-user override (which replaces IDP per-user limits).
                // If only MaxActiveSessionsTotal is set, fall through to check IDP per-user limits,
                // since total and per-user limits are orthogonal concerns.
                <span class="cov0" title="0">if override.MaxActiveSessionsPerUser != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        // 2. Look up IDP limits if idpName is set
        <span class="cov0" title="0">if idpName == "" </span><span class="cov0" title="0">{
                log.Debugw("No IDP name set, skipping IDP-level session limits")
                return nil
        }</span>

        <span class="cov0" title="0">idp := &amp;v1alpha1.IdentityProvider{}
        if err := wc.sessionManager.Client.Get(ctx, client.ObjectKey{Name: idpName}, idp); err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        log.Warnw("IdentityProvider not found  session limits cannot be enforced; verify the IDP resource exists",
                                "idp", idpName)
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to get IdentityProvider: %w", err)</span>
        }

        // No session limits configured on IDP
        <span class="cov0" title="0">if idp.Spec.SessionLimits == nil </span><span class="cov0" title="0">{
                log.Debugw("No session limits configured on IDP", "idp", idpName)
                return nil
        }</span>

        // 3. Check IDP group overrides (first matching group wins)
        // Uses glob pattern matching (e.g., "platform-*" matches "platform-team")
<span class="cov0" title="0">GroupOverrideLoop:
        for _, groupOverride := range idp.Spec.SessionLimits.GroupOverrides </span><span class="cov0" title="0">{
                for _, userGroup := range userGroups </span><span class="cov0" title="0">{
                        // Use glob pattern matching for flexible group specifications
                        matched, err := utils.GlobMatch(groupOverride.Group, userGroup)
                        if err != nil </span><span class="cov0" title="0">{
                                // Invalid glob pattern - log warning and skip this override
                                log.Warnw("Invalid glob pattern in IDP group override, skipping",
                                        "idp", idpName,
                                        "pattern", groupOverride.Group,
                                        "error", err)
                                continue GroupOverrideLoop</span>
                        }
                        <span class="cov0" title="0">if matched </span><span class="cov0" title="0">{
                                log.Debugw("Matched IDP group override",
                                        "idp", idpName,
                                        "pattern", groupOverride.Group,
                                        "matchedGroup", userGroup,
                                        "unlimited", groupOverride.Unlimited)
                                if groupOverride.Unlimited </span><span class="cov0" title="0">{
                                        return nil
                                }</span>
                                <span class="cov0" title="0">if groupOverride.MaxActiveSessionsPerUser != nil </span><span class="cov0" title="0">{
                                        return wc.checkUserSessionCount(ctx, userIdentifier, *groupOverride.MaxActiveSessionsPerUser, fmt.Sprintf("IDP group override (%s)", groupOverride.Group), log)
                                }</span>
                                // Group matched but no specific limit set, fall through to IDP default
                                // Use labeled break to exit BOTH loops (first matching group wins)
                                <span class="cov0" title="0">break GroupOverrideLoop</span>
                        }
                }
        }

        // 4. Apply IDP default limit
        <span class="cov0" title="0">if idp.Spec.SessionLimits.MaxActiveSessionsPerUser != nil </span><span class="cov0" title="0">{
                return wc.checkUserSessionCount(ctx, userIdentifier, *idp.Spec.SessionLimits.MaxActiveSessionsPerUser, "IDP default", log)
        }</span>

        <span class="cov0" title="0">log.Debugw("No session limit applicable", "idp", idpName, "escalation", escalation.Name)
        return nil</span>
}

// checkUserSessionCount counts active sessions for a user and checks against a limit.
// Uses the spec.user field index for efficient lookup when available.
func (wc *BreakglassSessionController) checkUserSessionCount(
        ctx context.Context,
        userIdentifier string,
        limit int32,
        source string,
        log *zap.SugaredLogger,
) error <span class="cov0" title="0">{
        // Use indexed query to fetch only sessions for this user
        sessionList, err := wc.sessionManager.GetUserBreakglassSessions(ctx, userIdentifier)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list sessions for user: %w", err)
        }</span>

        // Count active sessions for this user (across ALL escalations)
        <span class="cov0" title="0">var userActive int32
        for i := range sessionList </span><span class="cov0" title="0">{
                session := &amp;sessionList[i]
                if !IsSessionActive(*session) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">userActive++</span>
        }

        <span class="cov0" title="0">log.Debugw("Session count for user",
                "user", userIdentifier,
                "activeCount", userActive,
                "limit", limit,
                "source", source)

        if userActive &gt;= limit </span><span class="cov0" title="0">{
                return fmt.Errorf("session limit reached: maximum %d active sessions per user allowed (%s)", limit, source)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// checkTotalSessionCount counts total active sessions for an escalation and checks against a limit.
// Sessions are counted by matching owner reference to ensure sessions created by different
// escalations that grant the same group are not incorrectly counted together.
// Optimized: only lists sessions in states that can be active (Pending, Approved) instead of all sessions.
func (wc *BreakglassSessionController) checkTotalSessionCount(
        ctx context.Context,
        escalation *v1alpha1.BreakglassEscalation,
        limit int32,
        source string,
        log *zap.SugaredLogger,
) error <span class="cov0" title="0">{
        // Optimization: only list sessions in potentially active states (Pending and Approved)
        // rather than listing all sessions and filtering out terminal states.
        // This reduces data transfer from etcd significantly in clusters with many expired sessions.
        pendingSessions, err := wc.sessionManager.GetSessionsByState(ctx, v1alpha1.SessionStatePending)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list pending sessions: %w", err)
        }</span>
        <span class="cov0" title="0">approvedSessions, err := wc.sessionManager.GetSessionsByState(ctx, v1alpha1.SessionStateApproved)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list approved sessions: %w", err)
        }</span>

        // Count active sessions for this specific escalation (by matching owner reference UID)
        // This ensures sessions from different escalations that grant the same group are counted separately.
        <span class="cov0" title="0">var totalActive int32
        for i := range pendingSessions </span><span class="cov0" title="0">{
                session := &amp;pendingSessions[i]
                if !isOwnedByEscalation(session, escalation) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if !IsSessionActive(*session) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">totalActive++</span>
        }
        <span class="cov0" title="0">for i := range approvedSessions </span><span class="cov0" title="0">{
                session := &amp;approvedSessions[i]
                if !isOwnedByEscalation(session, escalation) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if !IsSessionActive(*session) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">totalActive++</span>
        }

        <span class="cov0" title="0">log.Debugw("Total session count for escalation",
                "escalation", escalation.Name,
                "escalationUID", escalation.UID,
                "activeCount", totalActive,
                "limit", limit,
                "source", source)

        if totalActive &gt;= limit </span><span class="cov0" title="0">{
                return fmt.Errorf("session limit reached: maximum %d total active sessions allowed (%s)", limit, source)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (wc *BreakglassSessionController) handleApproveBreakglassSession(c *gin.Context) <span class="cov0" title="0">{
        wc.setSessionStatus(c, v1alpha1.SessionConditionTypeApproved)
}</span>

func (wc *BreakglassSessionController) handleRejectBreakglassSession(c *gin.Context) <span class="cov0" title="0">{
        wc.setSessionStatus(c, v1alpha1.SessionConditionTypeRejected)
}</span>

// handleGetBreakglassSessionStatus handles GET /status for breakglass session
func (wc *BreakglassSessionController) handleGetBreakglassSessionStatus(c *gin.Context) <span class="cov0" title="0">{
        reqLog := system.GetReqLogger(c, wc.log)
        reqLog = system.EnrichReqLoggerWithAuth(c, reqLog)
        reqLog.Debug("Handling GET /status for breakglass session")
        // Use background context with timeout instead of request context to prevent
        // "context canceled" errors when client closes connection during rapid refreshes.
        // The Kubernetes API List operation needs to complete even if the HTTP client
        // disconnects, otherwise users see errors on rapid tab switches in the UI.
        // We use a timeout to prevent indefinite hangs. Timeout is configurable via APIContextTimeout.
        ctx, cancel := context.WithTimeout(context.Background(), APIContextTimeout)
        defer cancel()

        // Support server-side filtering when cluster/user/group query params are provided
        // to avoid fetching all sessions when unnecessary.
        clusterQ := c.Query("cluster")
        userQ := c.Query("user")
        groupQ := c.Query("group")
        // Support token-based validation (frontend uses ?token=&lt;name&gt;) to validate an approval link
        if token := c.Query("token"); token != "" </span><span class="cov0" title="0">{
                // Try to load session by metadata.name (token is treated as session name)
                ses, err := wc.sessionManager.GetBreakglassSessionByName(ctx, token)
                if err != nil </span><span class="cov0" title="0">{
                        reqLog.Debugw("Token validation: session not found", "token", token, "error", err)
                        c.JSON(http.StatusNotFound, struct {
                                Valid bool `json:"valid"`
                        }{Valid: false})
                        return
                }</span>
                <span class="cov0" title="0">canApprove := wc.isSessionApprover(c, ses)
                alreadyActive := IsSessionActive(ses)
                valid := true
                if IsSessionExpired(ses) || ses.Status.State == v1alpha1.SessionStateWithdrawn || ses.Status.State == v1alpha1.SessionStateRejected </span><span class="cov0" title="0">{
                        valid = false
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"canApprove": canApprove, "alreadyActive": alreadyActive, "valid": valid})
                return</span>
        }

        <span class="cov0" title="0">var sessions []v1alpha1.BreakglassSession
        var err error
        if clusterQ != "" || userQ != "" || groupQ != "" </span><span class="cov0" title="0">{
                // Build field selector from provided params
                fs := fields.Set{}
                if clusterQ != "" </span><span class="cov0" title="0">{
                        fs["spec.cluster"] = clusterQ
                }</span>
                <span class="cov0" title="0">if userQ != "" </span><span class="cov0" title="0">{
                        fs["spec.user"] = userQ
                }</span>
                <span class="cov0" title="0">if groupQ != "" </span><span class="cov0" title="0">{
                        fs["spec.grantedGroup"] = groupQ
                }</span>
                <span class="cov0" title="0">selector := fields.SelectorFromSet(fs)
                reqLog.Debugw("Using field selector for sessions query", "selector", selector.String())
                sessions, err = wc.sessionManager.GetBreakglassSessionsWithSelector(ctx, selector)</span>
        } else<span class="cov0" title="0"> {
                sessions, err = wc.sessionManager.GetAllBreakglassSessions(ctx)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                reqLog.Error("Error getting breakglass sessions", zap.Error(err))
                apiresponses.RespondInternalError(c, "list sessions", err, reqLog)
                return
        }</span>

        // Ownership filters
        <span class="cov0" title="0">includeMine := parseBoolQuery(c.Query("mine"), false)
        includeApprover := parseBoolQuery(c.Query("approver"), true)
        includeApprovedByMe := parseBoolQuery(c.Query("approvedByMe"), false)
        activeOnly := parseBoolQuery(c.Query("activeOnly"), false)
        stateFilters := normalizeStateFilters(c)
        statePredicates := buildStateFilterPredicates(stateFilters)

        var userEmail string
        if includeMine || includeApprovedByMe </span><span class="cov0" title="0">{
                userEmail, err = wc.identityProvider.GetEmail(c)
                if err != nil </span><span class="cov0" title="0">{
                        reqLog.Error("Error getting user identity email", zap.Error(err))
                        apiresponses.RespondInternalError(c, "extract email from token", err, reqLog)
                        return
                }</span>
        }

        <span class="cov0" title="0">authIdentifiers := []string{}
        if includeMine </span><span class="cov0" title="0">{
                authIdentifiers = collectAuthIdentifiers(userEmail, wc.identityProvider.GetUsername(c), wc.identityProvider.GetIdentity(c))
                if len(authIdentifiers) == 0 </span><span class="cov0" title="0">{
                        reqLog.Error("No authenticated identity claims found for session ownership filtering")
                        apiresponses.RespondUnauthorizedWithMessage(c, "user identity not found")
                        return
                }</span>
        }

        <span class="cov0" title="0">filtered := make([]v1alpha1.BreakglassSession, 0, len(sessions))
        for _, ses := range sessions </span><span class="cov0" title="0">{
                isMine := matchesAuthIdentifier(ses.Spec.User, authIdentifiers)
                var isApprover bool
                if includeApprover </span><span class="cov0" title="0">{
                        isApprover = wc.isSessionApprover(c, ses)
                }</span>
                <span class="cov0" title="0">hasApproved := false
                if includeApprovedByMe </span><span class="cov0" title="0">{
                        hasApproved = userHasApprovedSession(ses, userEmail)
                }</span>

                <span class="cov0" title="0">include := false
                if includeMine &amp;&amp; isMine </span><span class="cov0" title="0">{
                        include = true
                }</span>
                <span class="cov0" title="0">if includeApprover &amp;&amp; isApprover </span><span class="cov0" title="0">{
                        include = true
                }</span>
                <span class="cov0" title="0">if includeApprovedByMe &amp;&amp; hasApproved </span><span class="cov0" title="0">{
                        include = true
                }</span>
                <span class="cov0" title="0">if !includeMine &amp;&amp; !includeApprover &amp;&amp; !includeApprovedByMe </span><span class="cov0" title="0">{
                        include = isMine || isApprover || hasApproved
                }</span>
                <span class="cov0" title="0">if !include </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if len(statePredicates) &gt; 0 </span><span class="cov0" title="0">{
                        matched := false
                        for _, predicate := range statePredicates </span><span class="cov0" title="0">{
                                if predicate(ses) </span><span class="cov0" title="0">{
                                        matched = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !matched </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                <span class="cov0" title="0">if activeOnly &amp;&amp; !IsSessionActive(ses) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">filtered = append(filtered, ses)</span>
        }

        // Enrich sessions with approvalReason from matching escalations
        <span class="cov0" title="0">enriched := wc.enrichSessionsWithApprovalReason(ctx, filtered, reqLog)

        reqLog.Infow("Returning filtered breakglass sessions", "count", len(enriched))
        c.JSON(http.StatusOK, enriched)</span>
}

// SessionApprovalMeta contains authorization metadata for a session
type SessionApprovalMeta struct {
        CanApprove   bool   `json:"canApprove"`
        CanReject    bool   `json:"canReject"`
        IsRequester  bool   `json:"isRequester"`
        IsApprover   bool   `json:"isApprover"`
        DenialReason string `json:"denialReason,omitempty"`
        SessionState string `json:"sessionState"`
        StateMessage string `json:"stateMessage,omitempty"`
}

// EnrichedSessionResponse wraps a session with additional metadata from the escalation config
type EnrichedSessionResponse struct {
        v1alpha1.BreakglassSession
        // ApprovalReason contains the escalation's approval reason configuration (if any)
        // Now sourced from session.Spec.ApprovalReasonConfig (snapshot at creation time)
        ApprovalReason *ReasonConfigInfo `json:"approvalReason,omitempty"`
}

// enrichSessionsWithApprovalReason adds the approvalReason config from the session's stored snapshot.
// Sessions now store reason configs at creation time, so no escalation lookup is needed.
func (wc *BreakglassSessionController) enrichSessionsWithApprovalReason(_ context.Context, sessions []v1alpha1.BreakglassSession, _ *zap.SugaredLogger) []EnrichedSessionResponse <span class="cov0" title="0">{
        result := make([]EnrichedSessionResponse, 0, len(sessions))

        for i := range sessions </span><span class="cov0" title="0">{
                ses := sessions[i]
                dropK8sInternalFieldsSession(&amp;ses)

                enriched := EnrichedSessionResponse{
                        BreakglassSession: ses,
                }

                // Use the session's stored approval reason config (snapshot from escalation at creation time)
                if ses.Spec.ApprovalReasonConfig != nil </span><span class="cov0" title="0">{
                        enriched.ApprovalReason = &amp;ReasonConfigInfo{
                                Mandatory:   ses.Spec.ApprovalReasonConfig.Mandatory,
                                Description: ses.Spec.ApprovalReasonConfig.Description,
                        }
                }</span>

                <span class="cov0" title="0">result = append(result, enriched)</span>
        }

        <span class="cov0" title="0">return result</span>
}

// getSessionApprovalMeta determines the user's authorization status for a session
func (wc *BreakglassSessionController) getSessionApprovalMeta(c *gin.Context, session v1alpha1.BreakglassSession) SessionApprovalMeta <span class="cov0" title="0">{
        reqLog := system.GetReqLogger(c, wc.log)
        meta := SessionApprovalMeta{
                SessionState: string(session.Status.State),
        }

        // Get user email
        email, err := wc.identityProvider.GetEmail(c)
        if err != nil </span><span class="cov0" title="0">{
                reqLog.Warnw("Failed to get user email for approval meta", "error", err)
                meta.DenialReason = "Unable to verify your identity"
                return meta
        }</span>

        // Check if user is the requester
        <span class="cov0" title="0">meta.IsRequester = email == session.Spec.User

        // Check session state first
        switch session.Status.State </span>{
        case v1alpha1.SessionStateApproved:<span class="cov0" title="0">
                meta.StateMessage = "This session has already been approved"
                if session.Status.Approver != "" </span><span class="cov0" title="0">{
                        meta.StateMessage += " by " + session.Status.Approver
                }</span>
                <span class="cov0" title="0">return meta</span>
        case v1alpha1.SessionStateRejected:<span class="cov0" title="0">
                meta.StateMessage = "This session has already been rejected"
                if session.Status.Approver != "" </span><span class="cov0" title="0">{
                        meta.StateMessage += " by " + session.Status.Approver
                }</span>
                <span class="cov0" title="0">return meta</span>
        case v1alpha1.SessionStateWithdrawn:<span class="cov0" title="0">
                meta.StateMessage = "This session has been withdrawn by the requester"
                return meta</span>
        case v1alpha1.SessionStateExpired:<span class="cov0" title="0">
                meta.StateMessage = "This session has expired"
                return meta</span>
        case v1alpha1.SessionStateTimeout:<span class="cov0" title="0">
                meta.StateMessage = "This session has timed out waiting for approval"
                return meta</span>
        }

        // Session is pending - check if user can approve
        <span class="cov0" title="0">if session.Status.State != v1alpha1.SessionStatePending </span><span class="cov0" title="0">{
                meta.DenialReason = fmt.Sprintf("Session is in unexpected state: %s", session.Status.State)
                return meta
        }</span>

        // Check if user is an approver (use detailed authorization check for specific denial reasons)
        <span class="cov0" title="0">authResult := wc.checkApprovalAuthorization(c, session)
        meta.IsApprover = authResult.Allowed

        if meta.IsApprover </span><span class="cov0" title="0">{
                meta.CanApprove = true
                meta.CanReject = true
                reqLog.Debugw("User is authorized to approve/reject session",
                        "session", session.Name, "user", email, "isRequester", meta.IsRequester)
        }</span> else<span class="cov0" title="0"> {
                // Use the specific denial reason from the authorization check
                meta.DenialReason = authResult.Message
                reqLog.Debugw("User is not authorized to approve session",
                        "session", session.Name, "user", email, "reason", authResult.Reason, "message", authResult.Message)
        }</span>

        // Requester can always reject their own pending session (withdraw equivalent)
        <span class="cov0" title="0">if meta.IsRequester &amp;&amp; session.Status.State == v1alpha1.SessionStatePending </span><span class="cov0" title="0">{
                meta.CanReject = true
        }</span>

        <span class="cov0" title="0">return meta</span>
}

// handleGetBreakglassSessionByName handles GET /breakglassSessions/:name and returns a single session
// It includes authorization metadata to help the frontend display appropriate UI/errors
func (wc *BreakglassSessionController) handleGetBreakglassSessionByName(c *gin.Context) <span class="cov0" title="0">{
        reqLog := system.GetReqLogger(c, wc.log)
        reqLog = system.EnrichReqLoggerWithAuth(c, reqLog)

        sessionName := c.Param("name")
        reqLog.Infow("Handling GET /breakglassSessions/:name", "session", sessionName)

        ses, err := wc.sessionManager.GetBreakglassSessionByName(c.Request.Context(), sessionName)
        if err != nil </span><span class="cov0" title="0">{
                reqLog.Warnw("Session not found", "session", sessionName, "error", err)
                c.JSON(http.StatusNotFound, struct {
                        Error   string `json:"error"`
                        Code    string `json:"code"`
                        Session string `json:"session"`
                }{
                        Error:   "session not found",
                        Code:    "NOT_FOUND",
                        Session: sessionName,
                })
                return
        }</span>

        // Get authorization metadata
        <span class="cov0" title="0">approvalMeta := wc.getSessionApprovalMeta(c, ses)
        reqLog.Infow("Session retrieved with approval metadata",
                "session", sessionName,
                "state", ses.Status.State,
                "canApprove", approvalMeta.CanApprove,
                "isApprover", approvalMeta.IsApprover,
                "isRequester", approvalMeta.IsRequester,
                "denialReason", approvalMeta.DenialReason)

        // Return a single session object with metadata
        dropK8sInternalFieldsSession(&amp;ses)
        c.JSON(http.StatusOK, gin.H{
                "session":      ses,
                "approvalMeta": approvalMeta,
        })</span>
}

// handleWithdrawMyRequest allows the session requester to withdraw their own pending request
func (wc *BreakglassSessionController) handleWithdrawMyRequest(c *gin.Context) <span class="cov0" title="0">{
        reqLog := system.GetReqLogger(c, wc.log)
        reqLog = system.EnrichReqLoggerWithAuth(c, reqLog)

        sessionName := c.Param("name")
        bs, err := wc.sessionManager.GetBreakglassSessionByName(c.Request.Context(), sessionName)
        if err != nil </span><span class="cov0" title="0">{
                reqLog.Error("error while getting breakglass session", zap.Error(err))
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        apiresponses.RespondNotFoundSimple(c, "session not found")
                }</span> else<span class="cov0" title="0"> {
                        apiresponses.RespondInternalError(c, "get session", err, reqLog)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Only allow the original requester to withdraw
        <span class="cov0" title="0">requesterEmail, err := wc.identityProvider.GetEmail(c)
        if err != nil </span><span class="cov0" title="0">{
                reqLog.Error("error getting user identity email", zap.Error(err))
                apiresponses.RespondInternalError(c, "extract email from token", err, reqLog)
                return
        }</span>
        <span class="cov0" title="0">if bs.Spec.User != requesterEmail </span><span class="cov0" title="0">{
                // User is authenticated but not the session owner - return 403 Forbidden
                apiresponses.RespondForbidden(c, "only the session requester can withdraw")
                return
        }</span>

        // Only allow withdrawal if session is still pending
        <span class="cov0" title="0">if !IsSessionPendingApproval(bs) </span><span class="cov0" title="0">{
                apiresponses.RespondBadRequest(c, "Session is not pending and cannot be withdrawn")
                return
        }</span>

        // Set status to Withdrawn
        // IMPORTANT: Do NOT clear existing timestamps (ApprovedAt, ExpiresAt, etc.)
        // We want to preserve history. Only set state and withdrawal-specific timestamp.
        <span class="cov0" title="0">bs.Status.WithdrawnAt = metav1.Now() // Record when withdrawn
        bs.Status.State = v1alpha1.SessionStateWithdrawn
        // short reason for UI
        bs.Status.ReasonEnded = "withdrawn"
        // clear approver info for withdrawn sessions
        bs.Status.Approver = ""
        bs.Status.Approvers = nil

        // Set RetainedUntil for withdrawn sessions
        retainFor := ParseRetainFor(bs.Spec, reqLog)
        bs.Status.RetainedUntil = metav1.NewTime(time.Now().Add(retainFor))

        bs.Status.Conditions = append(bs.Status.Conditions, metav1.Condition{
                Type:               string(v1alpha1.SessionConditionTypeCanceled),
                Status:             metav1.ConditionTrue,
                LastTransitionTime: metav1.Now(),
                Reason:             string(v1alpha1.SessionConditionReasonEditedByApprover),
                Message:            "Session withdrawn by requester",
        })

        if err := wc.sessionManager.UpdateBreakglassSessionStatus(c.Request.Context(), bs); err != nil </span><span class="cov0" title="0">{
                reqLog.Error("error while updating breakglass session", zap.Error(err))
                if apierrors.IsConflict(err) </span><span class="cov0" title="0">{
                        apiresponses.RespondConflict(c, "session update conflict, please retry")
                }</span> else<span class="cov0" title="0"> if apierrors.IsInvalid(err) </span><span class="cov0" title="0">{
                        apiresponses.RespondUnprocessableEntity(c, err.Error())
                }</span> else<span class="cov0" title="0"> {
                        apiresponses.RespondInternalError(c, "update session status", err, reqLog)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Emit audit event for session withdrawal by requester
        <span class="cov0" title="0">wc.emitSessionAuditEvent(c.Request.Context(), audit.EventSessionWithdrawn, &amp;bs, requesterEmail, "Session withdrawn by requester")

        c.JSON(http.StatusOK, bs)</span>
}

// handleDropMySession allows the session requester (owner) to drop their own session.
// This differs from withdraw: drop permits removing either pending or approved sessions by owner.
func (wc *BreakglassSessionController) handleDropMySession(c *gin.Context) <span class="cov0" title="0">{
        reqLog := system.GetReqLogger(c, wc.log)
        reqLog = system.EnrichReqLoggerWithAuth(c, reqLog)

        sessionName := c.Param("name")
        bs, err := wc.sessionManager.GetBreakglassSessionByName(c.Request.Context(), sessionName)
        if err != nil </span><span class="cov0" title="0">{
                reqLog.Error("error while getting breakglass session", zap.Error(err))
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        apiresponses.RespondNotFoundSimple(c, "session not found")
                }</span> else<span class="cov0" title="0"> {
                        apiresponses.RespondInternalError(c, "get session", err, reqLog)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Only allow the original requester to drop
        <span class="cov0" title="0">requesterEmail, err := wc.identityProvider.GetEmail(c)
        if err != nil </span><span class="cov0" title="0">{
                reqLog.Error("error getting user identity email", zap.Error(err))
                apiresponses.RespondInternalError(c, "extract email from token", err, reqLog)
                return
        }</span>
        <span class="cov0" title="0">if bs.Spec.User != requesterEmail </span><span class="cov0" title="0">{
                // User is authenticated but not the session owner - return 403 Forbidden
                apiresponses.RespondForbidden(c, "only the session requester can drop")
                return
        }</span>

        // If approved -&gt; mark as Expired and set RetainedUntil appropriately (owner requested termination)
        <span class="cov0" title="0">if bs.Status.State == v1alpha1.SessionStateApproved &amp;&amp; !bs.Status.ApprovedAt.IsZero() </span><span class="cov0" title="0">{
                // Approved session dropped - transition to Expired
                // IMPORTANT: Do NOT clear existing timestamps. We want to preserve history.
                bs.Status.ExpiresAt = metav1.NewTime(time.Now())
                bs.Status.State = v1alpha1.SessionStateExpired
                bs.Status.Conditions = append(bs.Status.Conditions, metav1.Condition{
                        Type:               string(v1alpha1.SessionConditionTypeExpired),
                        Status:             metav1.ConditionTrue,
                        LastTransitionTime: metav1.Now(),
                        Reason:             string(v1alpha1.SessionConditionReasonEditedByApprover),
                        Message:            "Session dropped by owner",
                })
                bs.Status.ReasonEnded = "dropped"

                // Set RetainedUntil for expired sessions
                retainFor := ParseRetainFor(bs.Spec, reqLog)
                bs.Status.RetainedUntil = metav1.NewTime(time.Now().Add(retainFor))
        }</span> else<span class="cov0" title="0"> {
                // Pending or other state -&gt; behave like withdraw
                // IMPORTANT: Do NOT clear existing timestamps. We want to preserve history.
                bs.Status.WithdrawnAt = metav1.Now() // Record when withdrawn
                bs.Status.State = v1alpha1.SessionStateWithdrawn
                bs.Status.Approver = ""
                bs.Status.Approvers = nil

                // Set RetainedUntil for withdrawn sessions
                retainFor := ParseRetainFor(bs.Spec, reqLog)
                bs.Status.RetainedUntil = metav1.NewTime(time.Now().Add(retainFor))

                bs.Status.Conditions = append(bs.Status.Conditions, metav1.Condition{
                        Type:               string(v1alpha1.SessionConditionTypeCanceled),
                        Status:             metav1.ConditionTrue,
                        LastTransitionTime: metav1.Now(),
                        Reason:             string(v1alpha1.SessionConditionReasonEditedByApprover),
                        Message:            "Session dropped by owner",
                })
                bs.Status.ReasonEnded = "withdrawn"
        }</span>

        <span class="cov0" title="0">if err := wc.sessionManager.UpdateBreakglassSessionStatus(c.Request.Context(), bs); err != nil </span><span class="cov0" title="0">{
                reqLog.Error("error while updating breakglass session", zap.Error(err))
                if apierrors.IsConflict(err) </span><span class="cov0" title="0">{
                        apiresponses.RespondConflict(c, "session update conflict, please retry")
                }</span> else<span class="cov0" title="0"> if apierrors.IsInvalid(err) </span><span class="cov0" title="0">{
                        apiresponses.RespondUnprocessableEntity(c, err.Error())
                }</span> else<span class="cov0" title="0"> {
                        apiresponses.RespondInternalError(c, "update session status", err, reqLog)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Emit audit event for session dropped by owner
        <span class="cov0" title="0">wc.emitSessionAuditEvent(c.Request.Context(), audit.EventSessionDropped, &amp;bs, requesterEmail, "Session dropped by owner")

        c.JSON(http.StatusOK, bs)</span>
}

// handleApproverCancel allows an approver to cancel/terminate a running (approved) session.
// This endpoint is intended for approvers to immediately end an active session (set to Expired).
func (wc *BreakglassSessionController) handleApproverCancel(c *gin.Context) <span class="cov0" title="0">{
        reqLog := system.GetReqLogger(c, wc.log)
        reqLog = system.EnrichReqLoggerWithAuth(c, reqLog)

        sessionName := c.Param("name")
        bs, err := wc.sessionManager.GetBreakglassSessionByName(c.Request.Context(), sessionName)
        if err != nil </span><span class="cov0" title="0">{
                reqLog.Error("error while getting breakglass session", zap.Error(err))
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        apiresponses.RespondNotFoundSimple(c, "session not found")
                }</span> else<span class="cov0" title="0"> {
                        apiresponses.RespondInternalError(c, "get session", err, reqLog)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Only approvers can cancel via this endpoint
        <span class="cov0" title="0">if !wc.isSessionApprover(c, bs) </span><span class="cov0" title="0">{
                // User is authenticated but not an approver - return 403 Forbidden
                apiresponses.RespondForbidden(c, "only approvers can cancel sessions")
                return
        }</span>

        // Only allow cancellation of active/approved sessions
        <span class="cov0" title="0">if bs.Status.State != v1alpha1.SessionStateApproved || bs.Status.ApprovedAt.IsZero() </span><span class="cov0" title="0">{
                apiresponses.RespondBadRequest(c, "Session is not active/approved and cannot be canceled by approver")
                return
        }</span>

        // Transition to expired immediately
        // IMPORTANT: Do NOT clear existing timestamps. We want to preserve history.
        <span class="cov0" title="0">bs.Status.ExpiresAt = metav1.NewTime(time.Now())
        bs.Status.State = v1alpha1.SessionStateExpired

        // Set RetainedUntil for expired sessions
        retainFor := ParseRetainFor(bs.Spec, reqLog)
        bs.Status.RetainedUntil = metav1.NewTime(time.Now().Add(retainFor))

        // record approver who canceled
        approverEmail, _ := wc.identityProvider.GetEmail(c)
        if approverEmail != "" </span><span class="cov0" title="0">{
                bs.Status.Approver = approverEmail
                // append if not present
                bs.Status.Approvers = addIfNotPresent(bs.Status.Approvers, approverEmail)
        }</span>

        <span class="cov0" title="0">bs.Status.Conditions = append(bs.Status.Conditions, metav1.Condition{
                Type:               string(v1alpha1.SessionConditionTypeExpired),
                Status:             metav1.ConditionTrue,
                LastTransitionTime: metav1.Now(),
                Reason:             string(v1alpha1.SessionConditionReasonEditedByApprover),
                Message:            "Session canceled by approver",
        })
        bs.Status.ReasonEnded = "canceled"

        if err := wc.sessionManager.UpdateBreakglassSessionStatus(c.Request.Context(), bs); err != nil </span><span class="cov0" title="0">{
                reqLog.Error("error while updating breakglass session", zap.Error(err))
                if apierrors.IsConflict(err) </span><span class="cov0" title="0">{
                        apiresponses.RespondConflict(c, "session update conflict, please retry")
                }</span> else<span class="cov0" title="0"> if apierrors.IsInvalid(err) </span><span class="cov0" title="0">{
                        apiresponses.RespondUnprocessableEntity(c, err.Error())
                }</span> else<span class="cov0" title="0"> {
                        apiresponses.RespondInternalError(c, "update session status", err, reqLog)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Emit audit event for session revocation by approver
        <span class="cov0" title="0">wc.emitSessionAuditEvent(c.Request.Context(), audit.EventSessionRevoked, &amp;bs, approverEmail, "Session canceled by approver")

        c.JSON(http.StatusOK, bs)</span>
}

// formatDuration converts a time.Duration to a human-readable string (e.g., "2 hours", "30 minutes")
func formatDuration(d time.Duration) string <span class="cov0" title="0">{
        if d == 0 </span><span class="cov0" title="0">{
                return "0"
        }</span>

        // Handle days
        <span class="cov0" title="0">if d &gt;= 24*time.Hour </span><span class="cov0" title="0">{
                days := d / (24 * time.Hour)
                remainder := d % (24 * time.Hour)
                if remainder == 0 </span><span class="cov0" title="0">{
                        if days == 1 </span><span class="cov0" title="0">{
                                return "1 day"
                        }</span>
                        <span class="cov0" title="0">return fmt.Sprintf("%d days", days)</span>
                }
                <span class="cov0" title="0">hours := remainder / time.Hour
                if hours == 0 </span><span class="cov0" title="0">{
                        if days == 1 </span><span class="cov0" title="0">{
                                return "1 day"
                        }</span>
                        <span class="cov0" title="0">return fmt.Sprintf("%d days", days)</span>
                }
                <span class="cov0" title="0">if days == 1 </span><span class="cov0" title="0">{
                        if hours == 1 </span><span class="cov0" title="0">{
                                return "1 day 1 hour"
                        }</span>
                        <span class="cov0" title="0">return fmt.Sprintf("1 day %d hours", hours)</span>
                }
                <span class="cov0" title="0">if hours == 1 </span><span class="cov0" title="0">{
                        return fmt.Sprintf("%d days 1 hour", days)
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%d days %d hours", days, hours)</span>
        }

        // Handle hours
        <span class="cov0" title="0">if d &gt;= time.Hour </span><span class="cov0" title="0">{
                hours := d / time.Hour
                remainder := d % time.Hour
                if remainder == 0 </span><span class="cov0" title="0">{
                        if hours == 1 </span><span class="cov0" title="0">{
                                return "1 hour"
                        }</span>
                        <span class="cov0" title="0">return fmt.Sprintf("%d hours", hours)</span>
                }
                <span class="cov0" title="0">mins := remainder / time.Minute
                if mins == 0 </span><span class="cov0" title="0">{
                        if hours == 1 </span><span class="cov0" title="0">{
                                return "1 hour"
                        }</span>
                        <span class="cov0" title="0">return fmt.Sprintf("%d hours", hours)</span>
                }
                <span class="cov0" title="0">if hours == 1 </span><span class="cov0" title="0">{
                        if mins == 1 </span><span class="cov0" title="0">{
                                return "1 hour 1 minute"
                        }</span>
                        <span class="cov0" title="0">return fmt.Sprintf("1 hour %d minutes", mins)</span>
                }
                <span class="cov0" title="0">if mins == 1 </span><span class="cov0" title="0">{
                        return fmt.Sprintf("%d hours 1 minute", hours)
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%d hours %d minutes", hours, mins)</span>
        }

        // Handle minutes
        <span class="cov0" title="0">if d &gt;= time.Minute </span><span class="cov0" title="0">{
                mins := d / time.Minute
                if mins == 1 </span><span class="cov0" title="0">{
                        return "1 minute"
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%d minutes", mins)</span>
        }

        // Handle seconds (rarely used but for completeness)
        <span class="cov0" title="0">secs := d / time.Second
        if secs == 1 </span><span class="cov0" title="0">{
                return "1 second"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%d seconds", secs)</span>
}

func (wc *BreakglassSessionController) sendOnRequestEmail(bs v1alpha1.BreakglassSession,
        requestEmail,
        requestUsername string,
        approvers []string,
        approverGroupsToShow []string, // The specific approver group(s) to display in this email
        matchedEscalation *v1alpha1.BreakglassEscalation,
) error <span class="cov0" title="0">{
        // Guard: validate approvers list
        if len(approvers) == 0 </span><span class="cov0" title="0">{
                wc.log.Errorw("Cannot send breakglass request email: approvers list is empty",
                        "session", bs.Name,
                        "cluster", bs.Spec.Cluster,
                        "group", bs.Spec.GrantedGroup,
                        "requestUsername", requestUsername,
                        "requestEmail", requestEmail)
                return fmt.Errorf("cannot send email: no approvers available")
        }</span>

        <span class="cov0" title="0">subject := fmt.Sprintf("Cluster %q user %q is requesting breakglass group assignment %q", bs.Spec.Cluster, bs.Spec.User, bs.Spec.GrantedGroup)

        wc.log.Debugw("Rendering breakglass session request email",
                "session", bs.Name,
                "subject", subject,
                "approverId", len(approvers),
                "approvers", approvers,
                "requestEmail", requestEmail,
                "requestUsername", requestUsername)

        // Calculate scheduling information and duration for email
        scheduledStartTimeStr := ""
        calculatedExpiresAtStr := ""
        formattedDurationStr := ""
        requestedAtStr := time.Now().Format("2006-01-02 15:04:05 MST")

        if bs.Spec.ScheduledStartTime != nil </span><span class="cov0" title="0">{
                scheduledStartTimeStr = bs.Spec.ScheduledStartTime.Format("2006-01-02 15:04:05 MST")

                // Calculate expiry time from scheduled start time using spec.MaxValidFor
                expiryTime := bs.Spec.ScheduledStartTime.Time
                if bs.Spec.MaxValidFor != "" </span><span class="cov0" title="0">{
                        if d, err := v1alpha1.ParseDuration(bs.Spec.MaxValidFor); err == nil &amp;&amp; d &gt; 0 </span><span class="cov0" title="0">{
                                expiryTime = bs.Spec.ScheduledStartTime.Add(d)
                                formattedDurationStr = formatDuration(d)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Default to 1 hour if not specified
                        expiryTime = bs.Spec.ScheduledStartTime.Add(1 * time.Hour)
                        formattedDurationStr = "1 hour"
                }</span>
                <span class="cov0" title="0">calculatedExpiresAtStr = expiryTime.Format("2006-01-02 15:04:05 MST")</span>
        } else<span class="cov0" title="0"> {
                // Immediate session: calculate duration from MaxValidFor
                if bs.Spec.MaxValidFor != "" </span><span class="cov0" title="0">{
                        if d, err := v1alpha1.ParseDuration(bs.Spec.MaxValidFor); err == nil &amp;&amp; d &gt; 0 </span><span class="cov0" title="0">{
                                formattedDurationStr = formatDuration(d)
                                calculatedExpiresAtStr = time.Now().Add(d).Format("2006-01-02 15:04:05 MST")
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Default to 1 hour
                        formattedDurationStr = "1 hour"
                        calculatedExpiresAtStr = time.Now().Add(1 * time.Hour).Format("2006-01-02 15:04:05 MST")
                }</span>
        }

        // Use the provided approver groups to display
        // These are specific to this email (e.g., just "group-a" for members of group-a)
        <span class="cov0" title="0">wc.log.Debugw("Using provided approver groups for email",
                "approverGroupsToShow", approverGroupsToShow,
                "session", bs.Name)

        // Build TimeRemaining string for UI/UX
        timeRemaining := ""
        var expiryTime time.Time
        if bs.Spec.ScheduledStartTime != nil </span><span class="cov0" title="0">{
                expiryTime = bs.Spec.ScheduledStartTime.Time
                if bs.Spec.MaxValidFor != "" </span><span class="cov0" title="0">{
                        if d, err := v1alpha1.ParseDuration(bs.Spec.MaxValidFor); err == nil &amp;&amp; d &gt; 0 </span><span class="cov0" title="0">{
                                expiryTime = bs.Spec.ScheduledStartTime.Add(d)
                        }</span>
                } else<span class="cov0" title="0"> {
                        expiryTime = bs.Spec.ScheduledStartTime.Add(1 * time.Hour)
                }</span>
        } else<span class="cov0" title="0"> {
                // Immediate session
                expiryTime = time.Now()
                if bs.Spec.MaxValidFor != "" </span><span class="cov0" title="0">{
                        if d, err := v1alpha1.ParseDuration(bs.Spec.MaxValidFor); err == nil &amp;&amp; d &gt; 0 </span><span class="cov0" title="0">{
                                expiryTime = time.Now().Add(d)
                        }</span>
                } else<span class="cov0" title="0"> {
                        expiryTime = time.Now().Add(1 * time.Hour)
                }</span>
        }
        <span class="cov0" title="0">remainingDuration := time.Until(expiryTime)
        if remainingDuration &gt; 0 </span><span class="cov0" title="0">{
                timeRemaining = formatDuration(remainingDuration)
        }</span>

        // Build RequestedApprovalGroups string
        <span class="cov0" title="0">requestedApprovalGroupsStr := ""
        if matchedEscalation != nil &amp;&amp; len(matchedEscalation.Spec.Approvers.Groups) &gt; 0 </span><span class="cov0" title="0">{
                groupNames := matchedEscalation.Spec.Approvers.Groups
                if len(groupNames) == 1 </span><span class="cov0" title="0">{
                        requestedApprovalGroupsStr = groupNames[0]
                }</span> else<span class="cov0" title="0"> {
                        requestedApprovalGroupsStr = strings.Join(groupNames, " OR ")
                }</span>
        }

        <span class="cov0" title="0">body, err := mail.RenderBreakglassSessionRequest(mail.RequestBreakglassSessionMailParams{
                SubjectEmail:            requestEmail,
                SubjectFullName:         requestUsername,
                RequestingUsername:      requestUsername,
                RequestedCluster:        bs.Spec.Cluster,
                RequestedUsername:       bs.Spec.User,
                RequestedGroup:          bs.Spec.GrantedGroup,
                RequestReason:           bs.Spec.RequestReason,
                ScheduledStartTime:      scheduledStartTimeStr,
                CalculatedExpiresAt:     calculatedExpiresAtStr,
                FormattedDuration:       formattedDurationStr,
                RequestedAt:             requestedAtStr,
                ApproverGroups:          approverGroupsToShow,
                RequestedApprovalGroups: requestedApprovalGroupsStr,
                TimeRemaining:           timeRemaining,
                URL:                     fmt.Sprintf("%s/session/%s/approve", wc.config.Frontend.BaseURL, bs.Name),
                BrandingName: func() string </span><span class="cov0" title="0">{
                        if wc.config.Frontend.BrandingName != "" </span><span class="cov0" title="0">{
                                return wc.config.Frontend.BrandingName
                        }</span>
                        <span class="cov0" title="0">return "Breakglass"</span>
                }(),
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                wc.log.Errorw("failed to render email template",
                        "session", bs.Name,
                        "error", err,
                        "recipients", len(approvers),
                        "subject", subject)
                return err
        }</span>

        <span class="cov0" title="0">wc.log.Debugw("Email template rendered successfully",
                "session", bs.Name,
                "bodyLength", len(body),
                "recipientCount", len(approvers),
                "recipients", approvers,
                "subject", subject)

        // Use mail service (preferred) or mail queue for non-blocking async sending
        sessionID := fmt.Sprintf("session-%s", bs.Name)
        if wc.mailService != nil &amp;&amp; wc.mailService.IsEnabled() </span><span class="cov0" title="0">{
                if err := wc.mailService.Enqueue(sessionID, approvers, subject, body); err != nil </span><span class="cov0" title="0">{
                        wc.log.Warnw("Failed to enqueue session request email via mail service",
                                "session", bs.Name,
                                "recipientCount", len(approvers),
                                "recipients", approvers,
                                "subject", subject,
                                "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">wc.log.Infow("Breakglass session request email queued",
                        "session", bs.Name,
                        "recipientCount", len(approvers),
                        "recipients", approvers,
                        "subject", subject)
                return nil</span>
        }

        // Fallback to legacy mailQueue
        <span class="cov0" title="0">if wc.mailQueue != nil </span><span class="cov0" title="0">{
                if err := wc.mailQueue.Enqueue(sessionID, approvers, subject, body); err != nil </span><span class="cov0" title="0">{
                        wc.log.Warnw("Failed to enqueue session request email (will not retry)",
                                "session", bs.Name,
                                "recipientCount", len(approvers),
                                "recipients", approvers,
                                "subject", subject,
                                "error", err)
                        // Don't fall back to synchronous send - if queue is configured but failing,
                        // synchronous send would likely fail too. Just log and continue.
                        return err
                }</span>
                <span class="cov0" title="0">wc.log.Infow("Breakglass session request email queued",
                        "session", bs.Name,
                        "recipientCount", len(approvers),
                        "recipients", approvers,
                        "subject", subject)
                return nil</span>
        }

        // Fallback to synchronous send if mail sender is configured (for legacy/test compatibility)
        // Note: In production, mailService should be used via WithMailService() which sets wc.mailService
        // This fallback is primarily for tests that set wc.mail directly to a FakeMailSender
        <span class="cov0" title="0">if wc.mail != nil </span><span class="cov0" title="0">{
                if err := wc.mail.Send(approvers, subject, body); err != nil </span><span class="cov0" title="0">{
                        wc.log.Errorw("failed to send request email",
                                "session", bs.Name,
                                "recipientCount", len(approvers),
                                "recipients", approvers,
                                "subject", subject,
                                "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">wc.log.Infow("Breakglass session request email sent",
                        "session", bs.Name,
                        "recipientCount", len(approvers),
                        "recipients", approvers,
                        "subject", subject)
                return nil</span>
        }

        // No mail service, queue, or sender configured - email notifications are disabled
        <span class="cov0" title="0">wc.log.Warnw("No mail provider configured - email notification skipped",
                "session", bs.Name,
                "recipientCount", len(approvers),
                "recipients", approvers,
                "subject", subject)
        return nil</span>
}

// sendOnRequestEmailsByGroup sends separate emails for each approver group, where each email shows
// only the specific group that matched. This allows approvers to understand which group they're
// being notified on behalf of.
func (wc *BreakglassSessionController) sendOnRequestEmailsByGroup(
        log *zap.SugaredLogger,
        bs v1alpha1.BreakglassSession,
        requestEmail, requestUsername string,
        filteredApprovers []string,
        approversByGroup map[string][]string, // map[groupName][]approverEmails
        matchedEscalation *v1alpha1.BreakglassEscalation,
) <span class="cov0" title="0">{
        if matchedEscalation == nil </span><span class="cov0" title="0">{
                log.Warnw("Cannot send emails by group: matched escalation is nil", "session", bs.Name)
                return
        }</span>

        <span class="cov0" title="0">log.Debugw("Sending emails per approver group",
                "session", bs.Name,
                "totalApprovers", len(filteredApprovers),
                "groupCount", len(approversByGroup))

        // Build a map of approver email -&gt; groups they belong to (across ALL groups)
        // This ensures we send one email per approver, showing all their groups
        approverToGroups := make(map[string][]string)

        // For each configured approver group, collect which groups each approver belongs to
        for _, groupName := range matchedEscalation.Spec.Approvers.Groups </span><span class="cov0" title="0">{
                groupMembers := approversByGroup[groupName]

                // Filter the group members to only include those in filteredApprovers
                for _, member := range groupMembers </span><span class="cov0" title="0">{
                        for _, filtered := range filteredApprovers </span><span class="cov0" title="0">{
                                if member == filtered </span><span class="cov0" title="0">{
                                        // Record this approver -&gt; group mapping
                                        approverToGroups[member] = append(approverToGroups[member], groupName)
                                        break</span>
                                }
                        }
                }
        }

        // Send one email to each approver, showing all groups they belong to
        <span class="cov0" title="0">for approver, groups := range approverToGroups </span><span class="cov0" title="0">{
                log.Debugw("Sending email for approver",
                        "session", bs.Name,
                        "approver", approver,
                        "groupCount", len(groups),
                        "groups", groups)

                // Send email with ALL groups this approver belongs to
                if err := wc.sendOnRequestEmail(bs, requestEmail, requestUsername, []string{approver}, groups, matchedEscalation); err != nil </span><span class="cov0" title="0">{
                        log.Warnw("Failed to send email for approver",
                                "session", bs.Name,
                                "approver", approver,
                                "groupCount", len(groups),
                                "groups", groups,
                                "error", err)
                        // Continue with other approvers even if one fails
                }</span>
        }

        // Also send emails to explicit users (those not in any group)
        <span class="cov0" title="0">explicitUsers := approversByGroup["_explicit_users"]
        if len(explicitUsers) &gt; 0 </span><span class="cov0" title="0">{
                // Filter explicit users to only include those in filteredApprovers
                var approversForExplicit []string
                for _, user := range explicitUsers </span><span class="cov0" title="0">{
                        for _, filtered := range filteredApprovers </span><span class="cov0" title="0">{
                                if user == filtered </span><span class="cov0" title="0">{
                                        approversForExplicit = append(approversForExplicit, user)
                                        break</span>
                                }
                        }
                }

                <span class="cov0" title="0">if len(approversForExplicit) &gt; 0 </span><span class="cov0" title="0">{
                        log.Debugw("Sending email for explicit users",
                                "session", bs.Name,
                                "recipientCount", len(approversForExplicit))

                        // Send email with no specific group (since these are explicit users)
                        if err := wc.sendOnRequestEmail(bs, requestEmail, requestUsername, approversForExplicit, []string{}, matchedEscalation); err != nil </span><span class="cov0" title="0">{
                                log.Warnw("Failed to send email for explicit users",
                                        "session", bs.Name,
                                        "recipientCount", len(approversForExplicit),
                                        "error", err)
                        }</span>
                }
        }
}

// filterExcludedNotificationRecipients filters out users/groups that are in the escalation's NotificationExclusions
func (wc *BreakglassSessionController) filterExcludedNotificationRecipients(
        log *zap.SugaredLogger,
        approvers []string,
        escalation *v1alpha1.BreakglassEscalation,
) []string <span class="cov0" title="0">{
        log.Debugw("filterExcludedNotificationRecipients called",
                "approverCount", len(approvers),
                "approvers", approvers,
                "escalationNil", escalation == nil,
                "hasNotificationExclusions", escalation != nil &amp;&amp; escalation.Spec.NotificationExclusions != nil)

        if escalation == nil || escalation.Spec.NotificationExclusions == nil </span><span class="cov0" title="0">{
                log.Debugw("No notification exclusions configured",
                        "escalationNil", escalation == nil)
                return approvers
        }</span>

        <span class="cov0" title="0">exclusions := escalation.Spec.NotificationExclusions
        log.Infow("Notification exclusions configured",
                "excludedUserCount", len(exclusions.Users),
                "excludedUsers", exclusions.Users,
                "excludedGroupCount", len(exclusions.Groups),
                "excludedGroups", exclusions.Groups)

        // Build set of excluded users for O(1) lookup
        excludedUsers := make(map[string]bool)
        for _, user := range exclusions.Users </span><span class="cov0" title="0">{
                excludedUsers[user] = true
        }</span>
        <span class="cov0" title="0">log.Debugw("Built excluded users set",
                "directExcludedUserCount", len(excludedUsers),
                "directExcludedUsers", exclusions.Users)

        // Get members of excluded groups
        excludedGroupMembers := make(map[string]bool)
        if len(exclusions.Groups) &gt; 0 &amp;&amp; wc.escalationManager != nil &amp;&amp; wc.escalationManager.GetResolver() != nil </span><span class="cov0" title="0">{
                // Use a timeout context to prevent hanging on slow group resolution
                ctx, cancel := context.WithTimeout(context.Background(), APIContextTimeout)
                defer cancel()
                resolvedGroupsCount := 0
                totalMembersCount := 0

                for _, group := range exclusions.Groups </span><span class="cov0" title="0">{
                        log.Debugw("Attempting to resolve excluded group members",
                                "group", group)
                        members, err := wc.escalationManager.GetResolver().Members(ctx, group)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Warnw("Failed to resolve members of excluded group",
                                        "group", group,
                                        "error", err,
                                        "errorType", fmt.Sprintf("%T", err))
                                continue</span>
                        }
                        <span class="cov0" title="0">log.Infow("Successfully resolved excluded group members",
                                "group", group,
                                "memberCount", len(members),
                                "members", members)
                        resolvedGroupsCount++
                        totalMembersCount += len(members)
                        for _, member := range members </span><span class="cov0" title="0">{
                                excludedGroupMembers[member] = true
                        }</span>
                }

                <span class="cov0" title="0">excludedGroupMembersList := make([]string, 0, len(excludedGroupMembers))
                for m := range excludedGroupMembers </span><span class="cov0" title="0">{
                        excludedGroupMembersList = append(excludedGroupMembersList, m)
                }</span>
                <span class="cov0" title="0">log.Infow("Excluded group resolution summary",
                        "resolvedGroupCount", resolvedGroupsCount,
                        "totalGroupMemberCount", totalMembersCount,
                        "uniqueExcludedGroupMembers", len(excludedGroupMembers),
                        "excludedGroupMemberList", excludedGroupMembersList)</span>
        } else<span class="cov0" title="0"> {
                resolverNil := wc.escalationManager != nil &amp;&amp; wc.escalationManager.GetResolver() == nil
                log.Debugw("Cannot resolve excluded group members",
                        "groupCount", len(exclusions.Groups),
                        "escalationManagerNil", wc.escalationManager == nil,
                        "resolverNil", resolverNil)
        }</span>

        // Filter approvers
        <span class="cov0" title="0">filtered := []string{}
        excludedApprovers := []string{}
        for _, approver := range approvers </span><span class="cov0" title="0">{
                isExcluded := excludedUsers[approver] || excludedGroupMembers[approver]
                if isExcluded </span><span class="cov0" title="0">{
                        excludedApprovers = append(excludedApprovers, approver)
                }</span> else<span class="cov0" title="0"> {
                        filtered = append(filtered, approver)
                }</span>
        }

        <span class="cov0" title="0">log.Infow("Filtering results",
                "originalApproverCount", len(approvers),
                "originalApprovers", approvers,
                "visibleApproverCount", len(filtered),
                "visibleApprovers", filtered,
                "excludedApproverCount", len(excludedApprovers),
                "excludedApproversFiltered", excludedApprovers,
                "totalDirectExcluded", len(excludedUsers),
                "totalGroupMembersExcluded", len(excludedGroupMembers))

        return filtered</span>
}

// filterHiddenFromUIRecipients filters out users/groups that are marked as hidden from UI in the escalation.
// Hidden groups are used as fallback approvers but are not displayed in the UI or sent notifications.
func (wc *BreakglassSessionController) filterHiddenFromUIRecipients(
        log *zap.SugaredLogger,
        approvers []string,
        escalation *v1alpha1.BreakglassEscalation,
) []string <span class="cov0" title="0">{
        hiddenFromUICount := 0
        if escalation != nil </span><span class="cov0" title="0">{
                hiddenFromUICount = len(escalation.Spec.Approvers.HiddenFromUI)
        }</span>
        <span class="cov0" title="0">log.Debugw("filterHiddenFromUIRecipients called",
                "approverCount", len(approvers),
                "approvers", approvers,
                "escalationNil", escalation == nil,
                "hiddenFromUICount", hiddenFromUICount)

        if escalation == nil || len(escalation.Spec.Approvers.HiddenFromUI) == 0 </span><span class="cov0" title="0">{
                log.Debugw("No hidden approvers configured, returning all approvers",
                        "escalationNil", escalation == nil,
                        "hiddenCount", hiddenFromUICount)
                return approvers
        }</span>

        <span class="cov0" title="0">log.Infow("Hidden approvers configured",
                "hiddenItems", escalation.Spec.Approvers.HiddenFromUI,
                "hiddenItemCount", len(escalation.Spec.Approvers.HiddenFromUI))

        // Build set of hidden users for O(1) lookup
        hiddenUsers := make(map[string]bool)
        for _, user := range escalation.Spec.Approvers.HiddenFromUI </span><span class="cov0" title="0">{
                hiddenUsers[user] = true
        }</span>
        <span class="cov0" title="0">log.Debugw("Built hidden users set",
                "directHiddenUserCount", len(hiddenUsers),
                "directHiddenUsers", escalation.Spec.Approvers.HiddenFromUI)

        // Get members of hidden groups
        hiddenGroupMembers := make(map[string]bool)
        if wc.escalationManager != nil &amp;&amp; wc.escalationManager.GetResolver() != nil </span><span class="cov0" title="0">{
                // Use a timeout context to prevent hanging on slow group resolution
                ctx, cancel := context.WithTimeout(context.Background(), APIContextTimeout)
                defer cancel()
                resolvedGroupsCount := 0
                totalMembersCount := 0

                for _, group := range escalation.Spec.Approvers.HiddenFromUI </span><span class="cov0" title="0">{
                        log.Debugw("Attempting to resolve hidden item as group",
                                "item", group)
                        members, err := wc.escalationManager.GetResolver().Members(ctx, group)
                        if err != nil </span><span class="cov0" title="0">{
                                // This might be a user, not a group - just continue
                                log.Debugw("Failed to resolve members of hidden item (treating as individual user)",
                                        "item", group,
                                        "error", err,
                                        "errorType", fmt.Sprintf("%T", err))
                                continue</span>
                        }
                        <span class="cov0" title="0">log.Infow("Successfully resolved hidden group members",
                                "group", group,
                                "memberCount", len(members),
                                "members", members)
                        resolvedGroupsCount++
                        totalMembersCount += len(members)
                        for _, member := range members </span><span class="cov0" title="0">{
                                hiddenGroupMembers[member] = true
                        }</span>
                }

                <span class="cov0" title="0">log.Infow("Hidden group resolution summary",
                        "resolvedGroupCount", resolvedGroupsCount,
                        "totalGroupMemberCount", totalMembersCount,
                        "uniqueHiddenGroupMembers", len(hiddenGroupMembers),
                        "hiddenGroupMemberList", func() []string </span><span class="cov0" title="0">{
                                members := make([]string, 0, len(hiddenGroupMembers))
                                for m := range hiddenGroupMembers </span><span class="cov0" title="0">{
                                        members = append(members, m)
                                }</span>
                                <span class="cov0" title="0">return members</span>
                        }())
        } else<span class="cov0" title="0"> {
                log.Warnw("Cannot resolve hidden group members - resolver not available",
                        "escalationManagerNil", wc.escalationManager == nil,
                        "resolverNil", wc.escalationManager != nil &amp;&amp; wc.escalationManager.GetResolver() == nil)
        }</span>

        // Filter approvers - only include those not in hidden lists
        <span class="cov0" title="0">filtered := []string{}
        hiddenApprovers := []string{}
        for _, approver := range approvers </span><span class="cov0" title="0">{
                isHidden := hiddenUsers[approver] || hiddenGroupMembers[approver]
                if isHidden </span><span class="cov0" title="0">{
                        hiddenApprovers = append(hiddenApprovers, approver)
                }</span> else<span class="cov0" title="0"> {
                        filtered = append(filtered, approver)
                }</span>
        }

        <span class="cov0" title="0">log.Infow("Filtering results",
                "originalApproverCount", len(approvers),
                "originalApprovers", approvers,
                "visibleApproverCount", len(filtered),
                "visibleApprovers", filtered,
                "hiddenApproverCount", len(hiddenApprovers),
                "hiddenApproversFiltered", hiddenApprovers,
                "totalDirectHidden", len(hiddenUsers),
                "totalGroupMembersHidden", len(hiddenGroupMembers))

        return filtered</span>
}

// checkApprovalAuthorization performs a detailed check of whether the current user can approve/reject a session.
// It returns an ApprovalCheckResult with specific denial reasons instead of a simple boolean.
func (wc *BreakglassSessionController) checkApprovalAuthorization(c *gin.Context, session v1alpha1.BreakglassSession) ApprovalCheckResult <span class="cov0" title="0">{
        reqLog := system.GetReqLogger(c, wc.log)

        email, err := wc.identityProvider.GetEmail(c)
        if err != nil </span><span class="cov0" title="0">{
                reqLog.Error("Error getting user identity", zap.Error(err))
                return ApprovalCheckResult{
                        Allowed: false,
                        Reason:  ApprovalDenialUnauthenticated,
                        Message: "Unable to verify user identity",
                }
        }</span>
        <span class="cov0" title="0">reqLog.Debugw("Approver identity verified", "email", email, "cluster", session.Spec.Cluster)
        ctx := c.Request.Context()
        approverID := ClusterUserGroup{Username: email, Clustername: session.Spec.Cluster}

        // Base defaults for escalation evaluation
        var baseBlockSelfApproval bool
        var baseAllowedApproverDomains []string

        // Gather approver groups with caching
        cacheKey := "approverGroups_" + email
        var approverGroups []string
        if cached, ok := c.Get(cacheKey); ok </span><span class="cov0" title="0">{
                approverGroups = cached.([]string)
        }</span> else<span class="cov0" title="0"> {
                var gerr error
                approverGroups, gerr = wc.getUserGroupsFn(ctx, approverID)
                if raw, ok := c.Get("groups"); ok </span><span class="cov0" title="0">{
                        if arr, ok2 := raw.([]string); ok2 &amp;&amp; len(arr) &gt; 0 </span><span class="cov0" title="0">{
                                approverGroups = arr
                        }</span>
                } else<span class="cov0" title="0"> if gerr != nil </span><span class="cov0" title="0">{
                        reqLog.Errorw("[E2E-DEBUG] Approver group error", "error", gerr)
                        return ApprovalCheckResult{
                                Allowed: false,
                                Reason:  ApprovalDenialUnauthenticated,
                                Message: "Unable to retrieve user groups",
                        }
                }</span>
                <span class="cov0" title="0">c.Set(cacheKey, approverGroups)</span>
        }

        <span class="cov0" title="0">escalations, err := wc.escalationManager.GetClusterBreakglassEscalations(ctx, session.Spec.Cluster)
        if err != nil </span><span class="cov0" title="0">{
                reqLog.Error("Error listing cluster escalations for approval", zap.Error(err))
                return ApprovalCheckResult{
                        Allowed: false,
                        Reason:  ApprovalDenialNoMatchingEscalation,
                        Message: "Error retrieving escalation configuration",
                }
        }</span>

        // Track the most specific denial reason encountered during evaluation.
        // Priority: SelfApprovalBlocked &gt; DomainNotAllowed &gt; NotAnApprover &gt; NoMatchingEscalation
        <span class="cov0" title="0">var mostSpecificDenial ApprovalCheckResult
        foundMatchingEscalation := false

        reqLog.Debugw("Approver evaluation context", "session", session.Name, "sessionGrantedGroup", session.Spec.GrantedGroup, "candidateEscalationCount", len(escalations), "approverEmail", email)
        for _, esc := range escalations </span><span class="cov0" title="0">{
                if esc.Spec.EscalatedGroup != session.Spec.GrantedGroup </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">foundMatchingEscalation = true
                reqLog.Debugw("Evaluating matching escalation", "escalation", esc.Name, "users", len(esc.Spec.Approvers.Users), "groups", len(esc.Spec.Approvers.Groups))

                // Determine effective settings for this escalation
                effectiveBlockSelf := baseBlockSelfApproval
                effectiveAllowedDomains := baseAllowedApproverDomains
                if wc.clusterConfigManager != nil </span><span class="cov0" title="0">{
                        if cc, cerr := wc.clusterConfigManager.GetClusterConfigInNamespace(c.Request.Context(), esc.Namespace, session.Spec.Cluster); cerr == nil &amp;&amp; cc != nil </span><span class="cov0" title="0">{
                                effectiveBlockSelf = cc.Spec.BlockSelfApproval
                                effectiveAllowedDomains = cc.Spec.AllowedApproverDomains
                        }</span> else<span class="cov0" title="0"> if cerr != nil </span><span class="cov0" title="0">{
                                reqLog.Debugw("No ClusterConfig found in escalation namespace, continuing with defaults", "cluster", session.Spec.Cluster, "namespace", esc.Namespace, "error", cerr)
                        }</span>
                }
                <span class="cov0" title="0">if esc.Spec.BlockSelfApproval != nil </span><span class="cov0" title="0">{
                        effectiveBlockSelf = *esc.Spec.BlockSelfApproval
                }</span>
                <span class="cov0" title="0">if len(esc.Spec.AllowedApproverDomains) &gt; 0 </span><span class="cov0" title="0">{
                        effectiveAllowedDomains = esc.Spec.AllowedApproverDomains
                }</span>

                // Check self-approval restriction
                <span class="cov0" title="0">if effectiveBlockSelf &amp;&amp; email == session.Spec.User </span><span class="cov0" title="0">{
                        reqLog.Debugw("Self-approval blocked by escalation/cluster setting", "escalation", esc.Name, "approver", email)
                        // Track this as the most specific denial (highest priority)
                        mostSpecificDenial = ApprovalCheckResult{
                                Allowed: false,
                                Reason:  ApprovalDenialSelfApprovalBlocked,
                                Message: "Self-approval is not allowed for this cluster/escalation. Please ask another approver to approve your request.",
                        }
                        continue</span>
                }

                // Check domain restrictions
                <span class="cov0" title="0">if len(effectiveAllowedDomains) &gt; 0 </span><span class="cov0" title="0">{
                        allowed := false
                        for _, domain := range effectiveAllowedDomains </span><span class="cov0" title="0">{
                                if strings.HasSuffix(strings.ToLower(email), "@"+strings.ToLower(domain)) </span><span class="cov0" title="0">{
                                        allowed = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !allowed </span><span class="cov0" title="0">{
                                reqLog.Warnw("Approver email does not match allowed domains for escalation", "escalation", esc.Name, "approver", email, "allowedDomains", effectiveAllowedDomains)
                                // Only update if we haven't seen a more specific denial (self-approval blocked)
                                if mostSpecificDenial.Reason != ApprovalDenialSelfApprovalBlocked </span><span class="cov0" title="0">{
                                        mostSpecificDenial = ApprovalCheckResult{
                                                Allowed: false,
                                                Reason:  ApprovalDenialDomainNotAllowed,
                                                Message: fmt.Sprintf("Your email domain is not in the list of allowed approver domains: %v", effectiveAllowedDomains),
                                        }
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }
                }

                // Direct user approver check
                <span class="cov0" title="0">if slices.Contains(esc.Spec.Approvers.Users, email) </span><span class="cov0" title="0">{
                        reqLog.Debugw("User is session approver (direct user)", "session", session.Name, "escalation", esc.Name, "user", email)
                        return ApprovalCheckResult{Allowed: true}
                }</span>

                // Multi-IDP aware group checking
                <span class="cov0" title="0">approverGroupsToCheck := esc.Spec.Approvers.Groups
                var dedupMembers []string

                if len(esc.Spec.AllowedIdentityProvidersForApprovers) &gt; 0 &amp;&amp; esc.Status.ApproverGroupMembers != nil </span><span class="cov0" title="0">{
                        for _, g := range approverGroupsToCheck </span><span class="cov0" title="0">{
                                if members, ok := esc.Status.ApproverGroupMembers[g]; ok </span><span class="cov0" title="0">{
                                        dedupMembers = append(dedupMembers, members...)
                                        reqLog.Debugw("Using deduplicated members from multi-IDP status",
                                                "escalation", esc.Name, "group", g, "memberCount", len(members))
                                }</span>
                        }

                        <span class="cov0" title="0">for _, member := range dedupMembers </span><span class="cov0" title="0">{
                                if strings.EqualFold(member, email) </span><span class="cov0" title="0">{
                                        reqLog.Debugw("User is session approver (multi-IDP deduplicated group member)",
                                                "session", session.Name, "escalation", esc.Name, "member", email)
                                        return ApprovalCheckResult{Allowed: true}
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        for _, g := range approverGroupsToCheck </span><span class="cov0" title="0">{
                                if slices.Contains(approverGroups, g) </span><span class="cov0" title="0">{
                                        reqLog.Debugw("User is session approver (legacy group)", "session", session.Name, "escalation", esc.Name, "group", g)
                                        return ApprovalCheckResult{Allowed: true}
                                }</span>
                        }
                }

                // Not an approver for this escalation
                <span class="cov0" title="0">if len(esc.Spec.AllowedIdentityProvidersForApprovers) &gt; 0 </span><span class="cov0" title="0">{
                        reqLog.Debugw("Escalation found but user not in deduplicated approvers (continuing)",
                                "session", session.Name, "escalation", esc.Name, "user", email, "dedupMemberCount", len(dedupMembers))
                }</span> else<span class="cov0" title="0"> {
                        reqLog.Debugw("Escalation found but user not in approvers (continuing)",
                                "session", session.Name, "escalation", esc.Name, "user", email, "userGroups", approverGroups, "approverUsers", esc.Spec.Approvers.Users, "approverGroups", esc.Spec.Approvers.Groups)
                }</span>
                // Track not-an-approver as lowest priority denial
                <span class="cov0" title="0">if mostSpecificDenial.Reason == ApprovalDenialNone </span><span class="cov0" title="0">{
                        mostSpecificDenial = ApprovalCheckResult{
                                Allowed: false,
                                Reason:  ApprovalDenialNotAnApprover,
                                Message: "You are not in an approver group for this escalation",
                        }
                }</span>
        }

        // Return the most specific denial reason found, or no-matching-escalation if none found
        <span class="cov0" title="0">if !foundMatchingEscalation </span><span class="cov0" title="0">{
                reqLog.Debugw("No escalation with matching granted group for approval", "session", session.Name, "grantedGroup", session.Spec.GrantedGroup, "approverEmail", email, "approverGroups", approverGroups)
                return ApprovalCheckResult{
                        Allowed: false,
                        Reason:  ApprovalDenialNoMatchingEscalation,
                        Message: "No matching escalation found for the session's granted group",
                }
        }</span>

        <span class="cov0" title="0">return mostSpecificDenial</span>
}

// isSessionApprover returns true if the current user is authorized to approve/reject the session.
// For detailed denial reasons, use checkApprovalAuthorization instead.
func (wc *BreakglassSessionController) isSessionApprover(c *gin.Context, session v1alpha1.BreakglassSession) bool <span class="cov0" title="0">{
        result := wc.checkApprovalAuthorization(c, session)
        return result.Allowed
}</span>

// IsSessionRetained checks if a session should be removed (retainedUntil passed)
func IsSessionRetained(session v1alpha1.BreakglassSession) bool <span class="cov0" title="0">{
        if session.Status.RetainedUntil.IsZero() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return time.Now().After(session.Status.RetainedUntil.Time)</span>
}

func collectAuthIdentifiers(email, username, userID string) []string <span class="cov0" title="0">{
        identifiers := make([]string, 0, 3)
        if email != "" </span><span class="cov0" title="0">{
                identifiers = append(identifiers, email)
        }</span>
        <span class="cov0" title="0">if username != "" </span><span class="cov0" title="0">{
                identifiers = append(identifiers, username)
        }</span>
        <span class="cov0" title="0">if userID != "" </span><span class="cov0" title="0">{
                identifiers = append(identifiers, userID)
        }</span>
        <span class="cov0" title="0">return identifiers</span>
}

func firstNonEmpty(values ...string) string <span class="cov0" title="0">{
        for _, v := range values </span><span class="cov0" title="0">{
                if v != "" </span><span class="cov0" title="0">{
                        return v
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func matchesAuthIdentifier(value string, identifiers []string) bool <span class="cov0" title="0">{
        if value == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for _, id := range identifiers </span><span class="cov0" title="0">{
                if id == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if strings.EqualFold(id, value) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// IsSessionRejected returns true if session is in Rejected state (state-first validation)
func IsSessionRejected(session v1alpha1.BreakglassSession) bool <span class="cov0" title="0">{
        // CRITICAL: Check STATE FIRST - state is the ultimate truth
        return session.Status.State == v1alpha1.SessionStateRejected
}</span>

// IsSessionWithdrawn returns true if session is in Withdrawn state (state-first validation)
func IsSessionWithdrawn(session v1alpha1.BreakglassSession) bool <span class="cov0" title="0">{
        // CRITICAL: Check STATE FIRST - state is the ultimate truth
        return session.Status.State == v1alpha1.SessionStateWithdrawn
}</span>

// IsSessionExpired returns true if session is in Expired state OR (state is Approved AND ExpiresAt passed).
// State-first: Check terminal Expired state first, then timestamp for Approved state.
func IsSessionExpired(session v1alpha1.BreakglassSession) bool <span class="cov0" title="0">{
        // CRITICAL: Check STATE FIRST
        // If state is explicitly Expired, it is definitely expired
        if session.Status.State == v1alpha1.SessionStateExpired </span><span class="cov0" title="0">{
                return true
        }</span>

        // For Approved state, check if the timestamp has passed (timestamp is secondary check)
        <span class="cov0" title="0">if session.Status.State == v1alpha1.SessionStateApproved </span><span class="cov0" title="0">{
                return !session.Status.ExpiresAt.Time.IsZero() &amp;&amp; time.Now().After(session.Status.ExpiresAt.Time)
        }</span>

        // All other states (terminal or non-Approved) are not considered expired by this function
        // Expired state is explicitly set via Status.State
        <span class="cov0" title="0">return false</span>
}

func IsSessionValid(session v1alpha1.BreakglassSession) bool <span class="cov0" title="0">{
        // CRITICAL: Check terminal states FIRST. State is the ultimate truth.
        // Even if timestamps suggest validity, terminal states are never valid.
        if session.Status.State == v1alpha1.SessionStateRejected ||
                session.Status.State == v1alpha1.SessionStateWithdrawn ||
                session.Status.State == v1alpha1.SessionStateExpired ||
                session.Status.State == v1alpha1.SessionStateTimeout </span><span class="cov0" title="0">{
                return false
        }</span>

        // Session is not valid if it's in WaitingForScheduledTime state
        // (i.e., scheduled but not yet activated)
        <span class="cov0" title="0">if session.Status.State == v1alpha1.SessionStateWaitingForScheduledTime </span><span class="cov0" title="0">{
                return false
        }</span>

        // Session is not valid if it has a scheduled start time in the future
        <span class="cov0" title="0">if session.Spec.ScheduledStartTime != nil &amp;&amp; !session.Spec.ScheduledStartTime.IsZero() </span><span class="cov0" title="0">{
                if time.Now().Before(session.Spec.ScheduledStartTime.Time) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Only now check if it has expired based on ExpiresAt timestamp
        // But only for approved sessions (which should have ExpiresAt set)
        <span class="cov0" title="0">if session.Status.State == v1alpha1.SessionStateApproved &amp;&amp; IsSessionExpired(session) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// IsSessionActive returns if session can be approved or was already approved
// A session is active if it's valid and not in a terminal state.
// State is the primary determinant; timestamps are secondary validators.
func IsSessionActive(session v1alpha1.BreakglassSession) bool <span class="cov0" title="0">{
        // CRITICAL: Check terminal states FIRST. State is the ultimate truth.
        if session.Status.State == v1alpha1.SessionStateRejected ||
                session.Status.State == v1alpha1.SessionStateWithdrawn ||
                session.Status.State == v1alpha1.SessionStateExpired ||
                session.Status.State == v1alpha1.SessionStateTimeout </span><span class="cov0" title="0">{
                return false
        }</span>

        // Use general validity check for other state-based rules
        <span class="cov0" title="0">return IsSessionValid(session)</span>
}

// isOwnedByEscalation checks if a session is owned by the given escalation by matching
// the owner reference UID. This ensures sessions from different escalations that grant
// the same group are counted separately.
func isOwnedByEscalation(session *v1alpha1.BreakglassSession, escalation *v1alpha1.BreakglassEscalation) bool <span class="cov0" title="0">{
        for _, ownerRef := range session.GetOwnerReferences() </span><span class="cov0" title="0">{
                if ownerRef.UID == escalation.UID </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func NewBreakglassSessionController(log *zap.SugaredLogger,
        cfg config.Config,
        sessionManager *SessionManager,
        escalationManager *EscalationManager,
        middleware gin.HandlerFunc,
        configPath string,
        ccProvider interface {
                GetRESTConfig(ctx context.Context, name string) (*rest.Config, error)
        },
        clusterConfigClient client.Client,
        disableEmail ...bool,
) *BreakglassSessionController <span class="cov0" title="0">{
        ip := KeycloakIdentityProvider{log: log}

        // Check if disableEmail flag is provided
        disableEmailFlag := false
        if len(disableEmail) &gt; 0 </span><span class="cov0" title="0">{
                disableEmailFlag = disableEmail[0]
        }</span>

        // NOTE: mail field is left nil by default. Use WithMailService() to configure email sending
        // via the MailProvider CRD (preferred), or WithQueue() for legacy queue support.
        // Tests can set mail directly via struct initialization with &amp;FakeMailSender{}.

        <span class="cov0" title="0">ctrl := &amp;BreakglassSessionController{
                log:                  log,
                config:               cfg,
                sessionManager:       sessionManager,
                escalationManager:    escalationManager,
                middleware:           middleware,
                identityProvider:     ip,
                mail:                 nil, // Do not create stub sender; use mailService via WithMailService()
                mailQueue:            nil,
                disableEmail:         disableEmailFlag,
                configPath:           configPath,
                configLoader:         config.NewCachedLoader(configPath, 5*time.Second), // Cache config, check file every 5s
                ccProvider:           ccProvider,
                clusterConfigManager: NewClusterConfigManager(clusterConfigClient, WithClusterConfigLogger(log)),
                inFlightCreates:      &amp;sync.Map{},
        }

        ctrl.getUserGroupsFn = func(ctx context.Context, cug ClusterUserGroup) ([]string, error) </span><span class="cov0" title="0">{
                if ctrl.ccProvider != nil </span><span class="cov0" title="0">{
                        if rc, err := ctrl.ccProvider.GetRESTConfig(ctx, cug.Clustername); err == nil &amp;&amp; rc != nil </span><span class="cov0" title="0">{
                                remote := rest.CopyConfig(rc)
                                remote.Impersonate = rest.ImpersonationConfig{UserName: cug.Username}
                                client, cerr := kubernetes.NewForConfig(remote)
                                if cerr != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("remote client construction failed: %w", cerr)
                                }</span>
                                <span class="cov0" title="0">res, rerr := client.AuthenticationV1().SelfSubjectReviews().Create(ctx, &amp;authenticationv1.SelfSubjectReview{}, metav1.CreateOptions{})
                                if rerr != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("remote SelfSubjectReview failed: %w", rerr)
                                }</span>
                                <span class="cov0" title="0">ui := res.Status.UserInfo
                                groups := ui.Groups
                                // Use cached config loader for OIDC prefix stripping
                                if ctrl.configLoader != nil </span><span class="cov0" title="0">{
                                        if cfgLoaded, lerr := ctrl.configLoader.Get(); lerr == nil &amp;&amp; len(cfgLoaded.Kubernetes.OIDCPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                                                groups = stripOIDCPrefixes(groups, cfgLoaded.Kubernetes.OIDCPrefixes)
                                        }</span>
                                }
                                <span class="cov0" title="0">log.Debugw("Resolved user groups via spoke cluster rest.Config", "cluster", cug.Clustername, "user", cug.Username, "groups", groups)
                                return groups, nil</span>
                        }
                        <span class="cov0" title="0">log.Debugw("Falling back to legacy GetUserGroupsWithConfig (kube context)", "cluster", cug.Clustername)</span>
                }
                <span class="cov0" title="0">return GetUserGroupsWithConfig(ctx, cug, ctrl.configPath)</span>
        }

        <span class="cov0" title="0">return ctrl</span>
}

// sendSessionApprovalEmail sends an approval notification to the requester
func (wc *BreakglassSessionController) sendSessionApprovalEmail(log *zap.SugaredLogger, session v1alpha1.BreakglassSession) <span class="cov0" title="0">{
        // Check if mail is available (either via service or legacy queue)
        mailEnabled := (wc.mailService != nil &amp;&amp; wc.mailService.IsEnabled()) || wc.mailQueue != nil
        if !mailEnabled </span><span class="cov0" title="0">{
                log.Warnw("mail not available, cannot send approval email", "session", session.Name)
                return
        }</span>

        <span class="cov0" title="0">brandingName := "Breakglass"
        if wc.config.Frontend.BrandingName != "" </span><span class="cov0" title="0">{
                brandingName = wc.config.Frontend.BrandingName
        }</span>

        // Determine if this is a scheduled session
        <span class="cov0" title="0">isScheduled := session.Spec.ScheduledStartTime != nil &amp;&amp; !session.Spec.ScheduledStartTime.IsZero()

        // Determine activation time (either now or scheduled time)
        activationTime := time.Now().Format("2006-01-02 15:04:05")
        if isScheduled </span><span class="cov0" title="0">{
                activationTime = session.Spec.ScheduledStartTime.Format("2006-01-02 15:04:05")
        }</span>

        // Prepare email parameters with comprehensive approval info
        <span class="cov0" title="0">params := mail.ApprovedMailParams{
                SubjectFullName: session.Spec.User,
                SubjectEmail:    session.Spec.User,
                RequestedRole:   session.Spec.GrantedGroup,
                ApproverFullName: func() string </span><span class="cov0" title="0">{
                        // Try to extract approver name from email or use as-is
                        if session.Status.Approver != "" </span><span class="cov0" title="0">{
                                return session.Status.Approver
                        }</span>
                        <span class="cov0" title="0">return "Approver"</span>
                }(),
                ApproverEmail: session.Status.Approver,
                BrandingName:  brandingName,

                // Tracking and scheduling information
                ApprovedAt:     time.Now().Format("2006-01-02 15:04:05"),
                ActivationTime: activationTime,
                ExpirationTime: session.Status.ExpiresAt.Format("2006-01-02 15:04:05"),
                IsScheduled:    isScheduled,
                SessionID:      session.Name,
                Cluster:        session.Spec.Cluster,
                Username:       session.Spec.User,
                ApprovalReason: "", // Could be populated from session.Status.ApprovalReason if available

                // IDP information for multi-IDP setups
                IDPName:   session.Spec.IdentityProviderName,
                IDPIssuer: session.Spec.IdentityProviderIssuer,
        }

        // Render the approval email body using the enhanced template
        <span class="cov0" title="0">body, err := mail.RenderApproved(params)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorw("failed to render approval email template", "error", err, "session", session.Name)
                return
        }</span>

        // Enqueue the email for sending via mail service (preferred) or legacy queue
        <span class="cov0" title="0">subject := fmt.Sprintf("Breakglass Access Approved - %s on %s", session.Spec.GrantedGroup, session.Spec.Cluster)
        sessionID := "session-approval-" + session.Name
        recipients := []string{session.Spec.User}

        // Prefer mail service if available
        if wc.mailService != nil &amp;&amp; wc.mailService.IsEnabled() </span><span class="cov0" title="0">{
                if err := wc.mailService.Enqueue(sessionID, recipients, subject, body); err != nil </span><span class="cov0" title="0">{
                        log.Errorw("failed to enqueue approval email via mail service", "error", err, "session", session.Name, "to", session.Spec.User)
                        return
                }</span>
                <span class="cov0" title="0">log.Infow("approval email enqueued for sending", "session", session.Name, "to", session.Spec.User)
                return</span>
        }

        // Fallback to legacy queue
        <span class="cov0" title="0">if wc.mailQueue != nil </span><span class="cov0" title="0">{
                if err := wc.mailQueue.Enqueue(sessionID, recipients, subject, body); err != nil </span><span class="cov0" title="0">{
                        log.Errorw("failed to enqueue approval email", "error", err, "session", session.Name, "to", session.Spec.User)
                        return
                }</span>
                <span class="cov0" title="0">log.Infow("approval email enqueued for sending", "session", session.Name, "to", session.Spec.User)</span>
        }
}

// sendSessionRejectionEmail sends a rejection notification to the requester
func (wc *BreakglassSessionController) sendSessionRejectionEmail(log *zap.SugaredLogger, session v1alpha1.BreakglassSession) <span class="cov0" title="0">{
        // Check if mail is available (either via service or legacy queue)
        mailEnabled := (wc.mailService != nil &amp;&amp; wc.mailService.IsEnabled()) || wc.mailQueue != nil
        if !mailEnabled </span><span class="cov0" title="0">{
                log.Warnw("mail not available, cannot send rejection email", "session", session.Name)
                return
        }</span>

        <span class="cov0" title="0">brandingName := "Breakglass"
        if wc.config.Frontend.BrandingName != "" </span><span class="cov0" title="0">{
                brandingName = wc.config.Frontend.BrandingName
        }</span>

        // Prepare email parameters with rejection info
        <span class="cov0" title="0">params := mail.RejectedMailParams{
                SubjectFullName: session.Spec.User,
                SubjectEmail:    session.Spec.User,
                RequestedRole:   session.Spec.GrantedGroup,
                RejectorFullName: func() string </span><span class="cov0" title="0">{
                        if session.Status.Approver != "" </span><span class="cov0" title="0">{
                                return session.Status.Approver
                        }</span>
                        <span class="cov0" title="0">return "Approver"</span>
                }(),
                RejectorEmail:   session.Status.Approver,
                BrandingName:    brandingName,
                RejectedAt:      session.Status.RejectedAt.Format("2006-01-02 15:04:05"),
                RejectionReason: session.Status.ApprovalReason, // ApprovalReason is used for both approve and reject reasons
                SessionID:       session.Name,
                Cluster:         session.Spec.Cluster,
                Username:        session.Spec.User,
        }

        // Render the rejection email body using the template
        <span class="cov0" title="0">body, err := mail.RenderRejected(params)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorw("failed to render rejection email template", "error", err, "session", session.Name)
                return
        }</span>

        // Enqueue the email for sending via mail service (preferred) or legacy queue
        <span class="cov0" title="0">subject := fmt.Sprintf("Breakglass Access Rejected - %s on %s", session.Spec.GrantedGroup, session.Spec.Cluster)
        sessionID := "session-rejection-" + session.Name
        recipients := []string{session.Spec.User}

        // Prefer mail service if available
        if wc.mailService != nil &amp;&amp; wc.mailService.IsEnabled() </span><span class="cov0" title="0">{
                if err := wc.mailService.Enqueue(sessionID, recipients, subject, body); err != nil </span><span class="cov0" title="0">{
                        log.Errorw("failed to enqueue rejection email via mail service", "error", err, "session", session.Name, "to", session.Spec.User)
                        return
                }</span>
                <span class="cov0" title="0">log.Infow("rejection email enqueued for sending", "session", session.Name, "to", session.Spec.User)
                return</span>
        }

        // Fallback to legacy queue
        <span class="cov0" title="0">if wc.mailQueue != nil </span><span class="cov0" title="0">{
                if err := wc.mailQueue.Enqueue(sessionID, recipients, subject, body); err != nil </span><span class="cov0" title="0">{
                        log.Errorw("failed to enqueue rejection email", "error", err, "session", session.Name, "to", session.Spec.User)
                        return
                }</span>
                <span class="cov0" title="0">log.Infow("rejection email enqueued for sending", "session", session.Name, "to", session.Spec.User)</span>
        }
}

// WithQueue sets the mail queue for asynchronous email sending
// Deprecated: Use WithMailService instead for hot-reload support
func (b *BreakglassSessionController) WithQueue(mailQueue *mail.Queue) *BreakglassSessionController <span class="cov0" title="0">{
        b.mailQueue = mailQueue
        return b
}</span>

// WithMailService sets the mail service for asynchronous email sending with hot-reload support
func (b *BreakglassSessionController) WithMailService(mailService MailEnqueuer) *BreakglassSessionController <span class="cov0" title="0">{
        b.mailService = mailService
        return b
}</span>

// WithAuditService sets the audit service for emitting audit events
func (b *BreakglassSessionController) WithAuditService(auditService AuditEmitter) *BreakglassSessionController <span class="cov0" title="0">{
        b.auditService = auditService
        return b
}</span>

// emitSessionAuditEvent emits an audit event for session lifecycle changes
func (b *BreakglassSessionController) emitSessionAuditEvent(ctx context.Context, eventType audit.EventType, session *v1alpha1.BreakglassSession, user string, message string) <span class="cov0" title="0">{
        if b.auditService == nil || !b.auditService.IsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">event := &amp;audit.Event{
                Type:      eventType,
                Timestamp: time.Now().UTC(),
                Actor: audit.Actor{
                        User: user,
                },
                Target: audit.Target{
                        Kind:      "BreakglassSession",
                        Name:      session.Name,
                        Namespace: session.Namespace,
                        Cluster:   session.Spec.Cluster,
                },
                RequestContext: &amp;audit.RequestContext{
                        SessionName:    session.Name,
                        EscalationName: session.Spec.GrantedGroup,
                },
                Details: map[string]interface{}{
                        "message":      message,
                        "cluster":      session.Spec.Cluster,
                        "grantedGroup": session.Spec.GrantedGroup,
                        "state":        string(session.Status.State),
                },
        }

        b.auditService.Emit(ctx, event)</span>
}

// emitSessionExpiredAuditEvent emits an audit event when a session expires
func (b *BreakglassSessionController) emitSessionExpiredAuditEvent(ctx context.Context, session *v1alpha1.BreakglassSession, reason string) <span class="cov0" title="0">{
        if b.auditService == nil || !b.auditService.IsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">message := "Session expired"
        switch reason </span>{
        case "timeExpired":<span class="cov0" title="0">
                message = "Session validity period has ended"</span>
        case "approvalTimeout":<span class="cov0" title="0">
                message = "Session approval timed out before being approved"</span>
        }

        <span class="cov0" title="0">event := &amp;audit.Event{
                Type:      audit.EventSessionExpired,
                Severity:  audit.SeverityInfo,
                Timestamp: time.Now().UTC(),
                Actor: audit.Actor{
                        User: "system", // System-initiated expiration
                },
                Target: audit.Target{
                        Kind:      "BreakglassSession",
                        Name:      session.Name,
                        Namespace: session.Namespace,
                        Cluster:   session.Spec.Cluster,
                },
                RequestContext: &amp;audit.RequestContext{
                        SessionName:    session.Name,
                        EscalationName: session.Spec.GrantedGroup,
                },
                Details: map[string]interface{}{
                        "message":          message,
                        "expirationReason": reason,
                        "cluster":          session.Spec.Cluster,
                        "grantedGroup":     session.Spec.GrantedGroup,
                        "user":             session.Spec.User,
                },
        }

        b.auditService.Emit(ctx, event)</span>
}

// Handlers returns the middleware(s) for this controller (required by APIController interface)
func (b *BreakglassSessionController) Handlers() []gin.HandlerFunc <span class="cov0" title="0">{
        return []gin.HandlerFunc{b.middleware}
}</span>

// dropK8sInternalFields removes K8s internal fields from BreakglassSession for API response
func dropK8sInternalFieldsSession(s *v1alpha1.BreakglassSession) <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">s.ManagedFields = nil
        s.UID = ""
        s.ResourceVersion = ""
        s.Generation = 0
        if s.Annotations != nil </span><span class="cov0" title="0">{
                delete(s.Annotations, "kubectl.kubernetes.io/last-applied-configuration")
        }</span>
}

func dropK8sInternalFieldsSessionList(list []v1alpha1.BreakglassSession) []v1alpha1.BreakglassSession <span class="cov0" title="0">{
        for i := range list </span><span class="cov0" title="0">{
                dropK8sInternalFieldsSession(&amp;list[i])
        }</span>
        <span class="cov0" title="0">return list</span>
}

type sessionStatePredicate func(v1alpha1.BreakglassSession) bool

func parseBoolQuery(value string, defaultVal bool) bool <span class="cov0" title="0">{
        if value == "" </span><span class="cov0" title="0">{
                return defaultVal
        }</span>
        <span class="cov0" title="0">parsed, err := strconv.ParseBool(value)
        if err != nil </span><span class="cov0" title="0">{
                return defaultVal
        }</span>
        <span class="cov0" title="0">return parsed</span>
}

func normalizeStateFilters(c *gin.Context) []string <span class="cov0" title="0">{
        rawValues := c.QueryArray("state")
        if len(rawValues) == 0 </span><span class="cov0" title="0">{
                if single := c.Query("state"); single != "" </span><span class="cov0" title="0">{
                        rawValues = append(rawValues, single)
                }</span>
        }
        <span class="cov0" title="0">normalized := make([]string, 0, len(rawValues))
        for _, value := range rawValues </span><span class="cov0" title="0">{
                parts := strings.Split(value, ",")
                for _, part := range parts </span><span class="cov0" title="0">{
                        token := normalizeStateToken(part)
                        if token != "" </span><span class="cov0" title="0">{
                                normalized = append(normalized, token)
                        }</span>
                }
        }
        <span class="cov0" title="0">return normalized</span>
}

func normalizeStateToken(value string) string <span class="cov0" title="0">{
        trimmed := strings.TrimSpace(strings.ToLower(value))
        if trimmed == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">replacer := strings.NewReplacer("-", "", "_", "")
        return replacer.Replace(trimmed)</span>
}

func buildStateFilterPredicates(tokens []string) []sessionStatePredicate <span class="cov0" title="0">{
        if len(tokens) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">predicates := make([]sessionStatePredicate, 0, len(tokens))
        for _, token := range tokens </span><span class="cov0" title="0">{
                switch token </span>{
                case "all":<span class="cov0" title="0">
                        return nil</span>
                case "pending":<span class="cov0" title="0">
                        predicates = append(predicates, func(session v1alpha1.BreakglassSession) bool </span><span class="cov0" title="0">{
                                return session.Status.State == v1alpha1.SessionStatePending
                        }</span>)
                case "approved":<span class="cov0" title="0">
                        predicates = append(predicates, func(session v1alpha1.BreakglassSession) bool </span><span class="cov0" title="0">{
                                return session.Status.State == v1alpha1.SessionStateApproved
                        }</span>)
                case "rejected":<span class="cov0" title="0">
                        predicates = append(predicates, func(session v1alpha1.BreakglassSession) bool </span><span class="cov0" title="0">{
                                return IsSessionRejected(session)
                        }</span>)
                case "withdrawn":<span class="cov0" title="0">
                        predicates = append(predicates, func(session v1alpha1.BreakglassSession) bool </span><span class="cov0" title="0">{
                                return IsSessionWithdrawn(session)
                        }</span>)
                case "expired":<span class="cov0" title="0">
                        predicates = append(predicates, func(session v1alpha1.BreakglassSession) bool </span><span class="cov0" title="0">{
                                return IsSessionExpired(session)
                        }</span>)
                case "timeout", "approvaltimeout":<span class="cov0" title="0">
                        predicates = append(predicates, func(session v1alpha1.BreakglassSession) bool </span><span class="cov0" title="0">{
                                return session.Status.State == v1alpha1.SessionStateTimeout
                        }</span>)
                case "active":<span class="cov0" title="0">
                        predicates = append(predicates, func(session v1alpha1.BreakglassSession) bool </span><span class="cov0" title="0">{
                                return IsSessionActive(session)
                        }</span>)
                case "waitingforscheduledtime", "waiting", "scheduled":<span class="cov0" title="0">
                        predicates = append(predicates, func(session v1alpha1.BreakglassSession) bool </span><span class="cov0" title="0">{
                                return session.Status.State == v1alpha1.SessionStateWaitingForScheduledTime
                        }</span>)
                default:<span class="cov0" title="0">
                        continue</span>
                }
        }
        <span class="cov0" title="0">return predicates</span>
}

func userHasApprovedSession(session v1alpha1.BreakglassSession, email string) bool <span class="cov0" title="0">{
        if email == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if strings.EqualFold(session.Status.Approver, email) </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">for _, approver := range session.Status.Approvers </span><span class="cov0" title="0">{
                if strings.EqualFold(approver, email) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package breakglass

import (
        "context"
        "errors"
        "fmt"
        "strings"

        "github.com/telekom/k8s-breakglass/api/v1alpha1"
        "github.com/telekom/k8s-breakglass/pkg/metrics"
        "github.com/telekom/k8s-breakglass/pkg/system"
        "github.com/telekom/k8s-breakglass/pkg/utils"
        "go.uber.org/zap"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/fields"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/client/config"
)

// SessionManager is kubernetes client based object for managing CRUD operation on BreakglassSession custom resource.
type SessionManager struct {
        client.Client
        reader client.Reader
        log    *zap.SugaredLogger
}

// getLogger returns the injected logger or falls back to the global logger.
func (c SessionManager) getLogger() *zap.SugaredLogger <span class="cov8" title="1">{
        if c.log != nil </span><span class="cov0" title="0">{
                return c.log
        }</span>
        <span class="cov8" title="1">return zap.S()</span>
}

var ErrAccessNotFound = errors.New("access not found")

// SessionManagerOption configures a SessionManager during construction.
type SessionManagerOption func(*SessionManager)

// WithSessionLogger sets a custom logger for the SessionManager.
// If not provided, the global zap.S() logger is used as fallback.
// Passing nil is a no-op (the existing logger is retained).
func WithSessionLogger(log *zap.SugaredLogger) SessionManagerOption <span class="cov0" title="0">{
        return func(sm *SessionManager) </span><span class="cov0" title="0">{
                if log != nil </span><span class="cov0" title="0">{
                        sm.log = log
                }</span>
        }
}

func NewSessionManager(contextName string) (SessionManager, error) <span class="cov0" title="0">{
        cfg, err := config.GetConfigWithContext(contextName)
        if err != nil </span><span class="cov0" title="0">{
                zap.S().Errorw("Failed to get config with context", "context", contextName, "error", err)
                return SessionManager{}, fmt.Errorf("failed to get config with context %q: %w", contextName, err)
        }</span>

        <span class="cov0" title="0">c, err := client.New(cfg, client.Options{
                Scheme: Scheme,
        })
        if err != nil </span><span class="cov0" title="0">{
                zap.S().Errorw("Failed to create new client", "error", err)
                return SessionManager{}, fmt.Errorf("failed to create new client: %w", err)
        }</span>

        <span class="cov0" title="0">log := zap.S().Named("session-manager")
        log.Infow("SessionManager initialized", "context", contextName)
        return SessionManager{Client: c, reader: c, log: log}, nil</span>
}

// NewSessionManagerWithClient allows embedding an existing controller-runtime client (e.g., from a shared manager)
// to avoid creating redundant rest.Config instances or duplicate caches. The provided client must already be
// configured with the Breakglass scheme.
// Configuration is applied via functional options (WithSessionLogger).
func NewSessionManagerWithClient(c client.Client, opts ...SessionManagerOption) SessionManager <span class="cov8" title="1">{
        return NewSessionManagerWithClientAndReader(c, c, opts...)
}</span>

// NewSessionManagerWithClientAndReader allows using a cached client for writes and an optional reader
// (e.g., APIReader) for consistent reads when required.
// Configuration is applied via functional options (WithSessionLogger).
func NewSessionManagerWithClientAndReader(c client.Client, reader client.Reader, opts ...SessionManagerOption) SessionManager <span class="cov8" title="1">{
        if reader == nil </span><span class="cov0" title="0">{
                reader = c
        }</span>
        <span class="cov8" title="1">sm := SessionManager{Client: c, reader: reader}
        for _, opt := range opts </span><span class="cov0" title="0">{
                if opt != nil </span><span class="cov0" title="0">{
                        opt(&amp;sm)
                }</span>
        }
        <span class="cov8" title="1">return sm</span>
}

func (c SessionManager) list(ctx context.Context, list client.ObjectList, opts ...client.ListOption) error <span class="cov0" title="0">{
        if c.reader != nil </span><span class="cov0" title="0">{
                return c.reader.List(ctx, list, opts...)
        }</span>
        <span class="cov0" title="0">return c.Client.List(ctx, list, opts...)</span>
}

// isFieldIndexError returns true if the error indicates a missing field index
// or unsupported field selectori.e. it is safe to fall back to a full list +
// client-side filter.  All other errors (RBAC, network, etcd) are real failures.
func isFieldIndexError(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">msg := err.Error()
        // controller-runtime cache: "no index with name &lt;field&gt; has been registered"
        // controller-runtime cache: "Index with name &lt;field&gt; does not exist"
        // generic phrasing: "field index", "no indexer"
        // apiserver field selectors: "field label not supported"
        return strings.Contains(msg, "field index") ||
                strings.Contains(msg, "no indexer") ||
                strings.Contains(msg, "no index with name") ||
                strings.Contains(msg, "field label not supported") ||
                strings.Contains(msg, "Index with name")</span>
}

func SessionSelector(name, username, cluster, group string) string <span class="cov0" title="0">{
        selectors := []string{}

        if name != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("metadata.name=%s", name)
        }</span>

        <span class="cov0" title="0">if username != "" </span><span class="cov0" title="0">{
                selectors = append(selectors, fmt.Sprintf("spec.user=%s", username))
        }</span>
        <span class="cov0" title="0">if cluster != "" </span><span class="cov0" title="0">{
                selectors = append(selectors, fmt.Sprintf("spec.cluster=%s", cluster))
        }</span>
        <span class="cov0" title="0">if group != "" </span><span class="cov0" title="0">{
                selectors = append(selectors, fmt.Sprintf("spec.grantedGroup=%s", group))
        }</span>

        <span class="cov0" title="0">return strings.Join(selectors, ",")</span>
}

// Get all stored GetClusterGroupAccess
func (c SessionManager) GetAllBreakglassSessions(ctx context.Context) ([]v1alpha1.BreakglassSession, error) <span class="cov0" title="0">{
        log := c.getLogger()
        log.Debug("Fetching all BreakglassSessions")
        cgal := v1alpha1.BreakglassSessionList{}
        if err := c.list(ctx, &amp;cgal); err != nil </span><span class="cov0" title="0">{
                log.Errorw("Failed to get BreakglassSessionList", "error", err)
                return nil, fmt.Errorf("failed to get BreakglassSessionList: %w", err)
        }</span>
        <span class="cov0" title="0">log.Infow("Fetched BreakglassSessions", "count", len(cgal.Items))
        return cgal.Items, nil</span>
}

// GetSessionsByState returns all sessions in the specified state.
// Uses the status.state field index for efficient lookup when available.
// Falls back to listing all and filtering if index is not registered.
func (c SessionManager) GetSessionsByState(ctx context.Context,
        state v1alpha1.BreakglassSessionState,
) ([]v1alpha1.BreakglassSession, error) <span class="cov8" title="1">{
        log := c.getLogger()
        log.Debugw("Fetching BreakglassSessions by state (using field index)", "state", state)
        bsl := v1alpha1.BreakglassSessionList{}
        // Use the cached client (c.Client.List) for indexed queries.
        // Field indexes are only available in the cache, not via APIReader.
        if err := c.Client.List(ctx, &amp;bsl, client.MatchingFields{"status.state": string(state)}); err != nil </span><span class="cov0" title="0">{
                if !isFieldIndexError(err) </span><span class="cov0" title="0">{
                        // Real error (RBAC, network, etc.)  return it directly.
                        log.Errorw("Failed to list BreakglassSessions by state", "state", state, "error", err)
                        return nil, fmt.Errorf("failed to list BreakglassSessions by state: %w", err)
                }</span>
                // Field index not available  fall back to client-side filtering.
                <span class="cov0" title="0">log.Debugw("Field index not available; falling back to client-side filtering", "state", state, "error", err)
                all, err := c.GetAllBreakglassSessions(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">filtered := make([]v1alpha1.BreakglassSession, 0, len(all))
                for _, s := range all </span><span class="cov0" title="0">{
                        if s.Status.State == state </span><span class="cov0" title="0">{
                                filtered = append(filtered, s)
                        }</span>
                }
                <span class="cov0" title="0">return filtered, nil</span>
        }
        <span class="cov8" title="1">log.Infow("Fetched BreakglassSessions by state (indexed)", "count", len(bsl.Items), "state", state)
        return bsl.Items, nil</span>
}

// Get all stored GetClusterGroupAccess
func (c SessionManager) GetBreakglassSessionByName(ctx context.Context, name string) (v1alpha1.BreakglassSession, error) <span class="cov8" title="1">{
        log := c.getLogger()
        // Try direct GET first (works when object namespace is part of the object stored locally)
        log.Debugw("Fetching BreakglassSession by name (direct GET)", system.NamespacedFields(name, "")...)
        bs := v1alpha1.BreakglassSession{}

        // controller-runtime client requires a namespace when a name is provided in ObjectKey.
        // If the object was created with a namespace, a direct Get with empty namespace will fail.
        // In that case, fall back to listing sessions across all namespaces using a field selector on metadata.name.
        if err := c.Get(ctx, client.ObjectKey{Name: name}, &amp;bs); err == nil </span><span class="cov0" title="0">{
                log.Infow("Fetched BreakglassSession by name (direct GET)", system.NamespacedFields(name, bs.Namespace)...)
                return bs, nil
        }</span> else<span class="cov8" title="1"> {
                log.Debugw("Direct GET failed; falling back to list across namespaces", "name", name, "error", err)
        }</span>

        // Try cache-backed field index before falling back to selector-based listing
        <span class="cov8" title="1">indexed := v1alpha1.BreakglassSessionList{}
        if err := c.List(ctx, &amp;indexed, client.MatchingFields{"metadata.name": name}); err == nil </span><span class="cov8" title="1">{
                switch len(indexed.Items) </span>{
                case 0:<span class="cov0" title="0">
                        log.Debugw("Field index lookup returned no sessions; falling back to selector", "name", name)</span>
                case 1:<span class="cov8" title="1">
                        found := indexed.Items[0]
                        log.Infow("Fetched BreakglassSession by name (field index)", system.NamespacedFields(found.Name, found.Namespace)...)
                        return found, nil</span>
                default:<span class="cov0" title="0">
                        namespaces := make([]string, 0, len(indexed.Items))
                        for _, it := range indexed.Items </span><span class="cov0" title="0">{
                                namespaces = append(namespaces, it.Namespace)
                        }</span>
                        <span class="cov0" title="0">msg := fmt.Sprintf("multiple BreakglassSessions with name %q found in namespaces: %s", name, strings.Join(namespaces, ","))
                        log.Errorw("Ambiguous BreakglassSession name across namespaces (field index)", "name", name, "namespaces", namespaces)
                        return bs, fmt.Errorf("%s", msg)</span>
                }
        } else<span class="cov0" title="0"> {
                log.Debugw("Field index lookup failed; falling back to selector", "name", name, "error", err)
        }</span>

        // Fallback: list across namespaces using a metadata.name field selector
        <span class="cov0" title="0">selector := fmt.Sprintf("metadata.name=%s", name)
        fs, ferr := fields.ParseSelector(selector)
        if ferr != nil </span><span class="cov0" title="0">{
                log.Errorw("Failed to parse field selector for fallback lookup", "selector", selector, "error", ferr)
                return bs, fmt.Errorf("failed to create field selector %q: %w", selector, ferr)
        }</span>

        <span class="cov0" title="0">bsl := v1alpha1.BreakglassSessionList{}
        if err := c.list(ctx, &amp;bsl, &amp;client.ListOptions{FieldSelector: fs}); err != nil </span><span class="cov0" title="0">{
                log.Errorw("Failed to list BreakglassSessionList for fallback lookup", "selector", selector, "error", err)
                return bs, fmt.Errorf("failed to list BreakglassSessionList for fallback lookup: %w", err)
        }</span>

        <span class="cov0" title="0">if len(bsl.Items) == 0 </span><span class="cov0" title="0">{
                log.Debugw("BreakglassSession not found by name across namespaces", "name", name)
                return bs, apierrors.NewNotFound(schema.GroupResource{Group: v1alpha1.GroupVersion.Group, Resource: "breakglasssessions"}, name)
        }</span>

        <span class="cov0" title="0">if len(bsl.Items) &gt; 1 </span><span class="cov0" title="0">{
                // Ambiguous: multiple sessions with same name exist in different namespaces.
                namespaces := make([]string, 0, len(bsl.Items))
                for _, it := range bsl.Items </span><span class="cov0" title="0">{
                        namespaces = append(namespaces, it.Namespace)
                }</span>
                <span class="cov0" title="0">msg := fmt.Sprintf("multiple BreakglassSessions with name %q found in namespaces: %s", name, strings.Join(namespaces, ","))
                log.Errorw("Ambiguous BreakglassSession name across namespaces", "name", name, "namespaces", namespaces)
                return bs, fmt.Errorf("%s", msg)</span>
        }

        // Single match: return it
        <span class="cov0" title="0">found := bsl.Items[0]
        log.Infow("Fetched BreakglassSession by name (fallback list)", system.NamespacedFields(found.Name, found.Namespace)...)
        return found, nil</span>
}

// GetUserBreakglassSessions returns all sessions for a user across all clusters.
// Uses the spec.user field index for efficient lookup when available.
// Falls back to listing all and filtering if index is not registered.
func (c SessionManager) GetUserBreakglassSessions(ctx context.Context,
        user string,
) ([]v1alpha1.BreakglassSession, error) <span class="cov0" title="0">{
        log := c.getLogger()
        log.Debugw("Fetching BreakglassSessions for user (using field index)", "user", user)
        bsl := v1alpha1.BreakglassSessionList{}
        // Use the cached client (c.Client.List) for indexed queries.
        // Field indexes are only available in the cache, not via APIReader.
        if err := c.Client.List(ctx, &amp;bsl, client.MatchingFields{"spec.user": user}); err != nil </span><span class="cov0" title="0">{
                if !isFieldIndexError(err) </span><span class="cov0" title="0">{
                        log.Errorw("Failed to list BreakglassSessions for user", "user", user, "error", err)
                        return nil, fmt.Errorf("failed to list BreakglassSessions for user: %w", err)
                }</span>
                // Field index not available  fall back to client-side filtering.
                <span class="cov0" title="0">log.Debugw("Field index not available; falling back to client-side filtering", "user", user, "error", err)
                all, err := c.GetAllBreakglassSessions(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">filtered := make([]v1alpha1.BreakglassSession, 0, len(all))
                for _, s := range all </span><span class="cov0" title="0">{
                        if s.Spec.User == user </span><span class="cov0" title="0">{
                                filtered = append(filtered, s)
                        }</span>
                }
                <span class="cov0" title="0">return filtered, nil</span>
        }
        <span class="cov0" title="0">log.Infow("Fetched BreakglassSessions for user (indexed)", "count", len(bsl.Items), "user", user)
        return bsl.Items, nil</span>
}

// Get GetClusterGroupAccess by cluster name.
// Uses the spec.cluster and spec.user field indexes for efficient lookup when available.
// Falls back to listing all and filtering if indexes are not registered.
func (c SessionManager) GetClusterUserBreakglassSessions(ctx context.Context,
        cluster string,
        user string,
) ([]v1alpha1.BreakglassSession, error) <span class="cov0" title="0">{
        log := c.getLogger()
        log.Debugw("Fetching BreakglassSessions for cluster and user (using field index)", "cluster", cluster, "user", user)
        bsl := v1alpha1.BreakglassSessionList{}
        // Use the cached client (c.Client.List) for indexed queries.
        // Field indexes are only available in the cache, not via APIReader.
        if err := c.Client.List(ctx, &amp;bsl, client.MatchingFields{"spec.cluster": cluster, "spec.user": user}); err != nil </span><span class="cov0" title="0">{
                if !isFieldIndexError(err) </span><span class="cov0" title="0">{
                        log.Errorw("Failed to list BreakglassSessions for cluster/user", "cluster", cluster, "user", user, "error", err)
                        return nil, fmt.Errorf("failed to list BreakglassSessions for cluster/user: %w", err)
                }</span>
                // Field index not available  fall back to client-side filtering.
                <span class="cov0" title="0">log.Debugw("Field index not available; falling back to client-side filtering", "cluster", cluster, "user", user, "error", err)
                all, err := c.GetAllBreakglassSessions(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">filtered := make([]v1alpha1.BreakglassSession, 0, len(all))
                for _, s := range all </span><span class="cov0" title="0">{
                        if s.Spec.Cluster == cluster &amp;&amp; s.Spec.User == user </span><span class="cov0" title="0">{
                                filtered = append(filtered, s)
                        }</span>
                }
                <span class="cov0" title="0">return filtered, nil</span>
        }
        <span class="cov0" title="0">log.Infow("Fetched BreakglassSessions (indexed)", "count", len(bsl.Items), "cluster", cluster, "user", user)
        return bsl.Items, nil</span>
}

// GetBreakglassSessions with custom field selector string.
func (c SessionManager) GetBreakglassSessionsWithSelectorString(ctx context.Context,
        selectorString string,
) ([]v1alpha1.BreakglassSession, error) <span class="cov0" title="0">{
        log := c.getLogger()
        log.Debugw("Fetching BreakglassSessions with selector string", "selector", selectorString)
        bsl := v1alpha1.BreakglassSessionList{}

        fs, err := fields.ParseSelector(selectorString)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorw("Failed to create field selector", "selector", selectorString, "error", err)
                return nil, fmt.Errorf("failed to create field selector %q : %w", selectorString, err)
        }</span>

        <span class="cov0" title="0">if err := c.list(ctx, &amp;bsl, &amp;client.ListOptions{FieldSelector: fs}); err != nil </span><span class="cov0" title="0">{
                log.Errorw("Failed to list BreakglassSessionList with string selector", "selector", selectorString, "error", err)
                return nil, fmt.Errorf("failed to list BreakglassSessionList with string selector: %w", err)
        }</span>
        <span class="cov0" title="0">log.Infow("Fetched BreakglassSessions with selector string", "count", len(bsl.Items), "selector", selectorString)
        return bsl.Items, nil</span>
}

// GetBreakglassSessions with custom field selector.
func (c SessionManager) GetBreakglassSessionsWithSelector(ctx context.Context,
        fs fields.Selector,
) ([]v1alpha1.BreakglassSession, error) <span class="cov0" title="0">{
        log := c.getLogger()
        log.Debugw("Fetching BreakglassSessions with selector", "selector", fs.String())
        bsl := v1alpha1.BreakglassSessionList{}

        if err := c.list(ctx, &amp;bsl, &amp;client.ListOptions{FieldSelector: fs}); err != nil </span><span class="cov0" title="0">{
                log.Errorw("Failed to list BreakglassSessionList with selector", "selector", fs.String(), "error", err)
                return nil, fmt.Errorf("failed to list BreakglassSessionList with selector: %w", err)
        }</span>
        <span class="cov0" title="0">log.Infow("Fetched BreakglassSessions with selector", "count", len(bsl.Items), "selector", fs.String())
        return bsl.Items, nil</span>
}

// Add new breakglass session.
// Note: Uses Create instead of SSA because GenerateName requires Create semantics.
// For updates, use UpdateBreakglassSession which uses SSA.
func (c SessionManager) AddBreakglassSession(ctx context.Context, bs *v1alpha1.BreakglassSession) error <span class="cov0" title="0">{
        log := c.getLogger()
        log.Infow("Adding new BreakglassSession", append(system.NamespacedFields(bs.Name, bs.Namespace), "user", bs.Spec.User, "cluster", bs.Spec.Cluster)...)
        if err := c.Create(ctx, bs); err != nil </span><span class="cov0" title="0">{
                log.Errorw("Failed to create new BreakglassSession", append(system.NamespacedFields(bs.Name, bs.Namespace), "error", err)...)
                return fmt.Errorf("failed to create new BreakglassSession: %w", err)
        }</span>
        <span class="cov0" title="0">log.Infow("BreakglassSession created successfully", system.NamespacedFields(bs.Name, bs.Namespace)...)
        // Emit metric for created session (cluster may be in spec)
        metrics.SessionCreated.WithLabelValues(bs.Spec.Cluster).Inc()

        // Track session creation with IDP if specified
        if bs.Spec.IdentityProviderName != "" </span><span class="cov0" title="0">{
                metrics.SessionCreatedWithIDP.WithLabelValues(bs.Spec.IdentityProviderName).Inc()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Update breakglass session.
func (c SessionManager) UpdateBreakglassSession(ctx context.Context, bs v1alpha1.BreakglassSession) error <span class="cov0" title="0">{
        log := c.getLogger()
        log.Infow("Updating BreakglassSession", system.NamespacedFields(bs.Name, bs.Namespace)...)
        if bs.TypeMeta.APIVersion == "" || bs.TypeMeta.Kind == "" </span><span class="cov0" title="0">{
                bs.TypeMeta = metav1.TypeMeta{
                        APIVersion: v1alpha1.GroupVersion.String(),
                        Kind:       "BreakglassSession",
                }
        }</span>
        <span class="cov0" title="0">if err := utils.ApplyObject(ctx, c.Client, &amp;bs); err != nil </span><span class="cov0" title="0">{
                log.Errorw("Failed to update BreakglassSession", append(system.NamespacedFields(bs.Name, bs.Namespace), "error", err)...)
                return fmt.Errorf("failed to update BreakglassSession %s/%s: %w", bs.Namespace, bs.Name, err)
        }</span>
        <span class="cov0" title="0">log.Infow("BreakglassSession updated successfully", system.NamespacedFields(bs.Name, bs.Namespace)...)
        metrics.SessionUpdated.WithLabelValues(bs.Spec.Cluster).Inc()
        return nil</span>
}

func (c SessionManager) UpdateBreakglassSessionStatus(ctx context.Context, bs v1alpha1.BreakglassSession) error <span class="cov8" title="1">{
        log := c.getLogger()
        log.Infow("Updating BreakglassSession status", system.NamespacedFields(bs.Name, bs.Namespace)...)

        // Always fetch current state once to get Namespace, ResourceVersion, and Generation
        // This avoids duplicate API calls while ensuring kstatus compliance
        current, err := c.GetBreakglassSessionByName(ctx, bs.Name)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorw("Failed to resolve BreakglassSession before status update", append(system.NamespacedFields(bs.Name, bs.Namespace), "error", err)...)
                return fmt.Errorf("failed to resolve BreakglassSession %s before status update: %w", bs.Name, err)
        }</span>

        // Populate missing fields from current state
        <span class="cov8" title="1">if bs.Namespace == "" </span><span class="cov0" title="0">{
                bs.Namespace = current.Namespace
        }</span>
        <span class="cov8" title="1">if bs.ResourceVersion == "" </span><span class="cov0" title="0">{
                bs.ResourceVersion = current.ResourceVersion
        }</span>
        // Set observedGeneration for kstatus compliance
        <span class="cov8" title="1">bs.Status.ObservedGeneration = current.Generation
        if err := applyBreakglassSessionStatus(ctx, c, &amp;bs); err != nil </span><span class="cov0" title="0">{
                log.Errorw("Failed to update BreakglassSession status", append(system.NamespacedFields(bs.Name, bs.Namespace), "error", err)...)
                return fmt.Errorf("failed to update BreakglassSession status %s/%s: %w", bs.Namespace, bs.Name, err)
        }</span>
        <span class="cov8" title="1">log.Infow("BreakglassSession status updated successfully", system.NamespacedFields(bs.Name, bs.Namespace)...)
        return nil</span>
}

// DeleteBreakglassSession deletes the given BreakglassSession and emits a metric when successful.
func (c SessionManager) DeleteBreakglassSession(ctx context.Context, bs *v1alpha1.BreakglassSession) error <span class="cov0" title="0">{
        log := c.getLogger()
        if err := c.Delete(ctx, bs); err != nil </span><span class="cov0" title="0">{
                log.Errorw("Failed to delete BreakglassSession", append(system.NamespacedFields(bs.Name, bs.Namespace), "error", err)...)
                return fmt.Errorf("failed to delete breakglass session: %w", err)
        }</span>
        <span class="cov0" title="0">log.Infow("BreakglassSession deleted successfully", system.NamespacedFields(bs.Name, bs.Namespace)...)
        metrics.SessionDeleted.WithLabelValues(bs.Spec.Cluster).Inc()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package breakglass

import (
        "context"

        telekomv1alpha1 "github.com/telekom/k8s-breakglass/api/v1alpha1"
        "github.com/telekom/k8s-breakglass/api/v1alpha1/applyconfiguration/ssa"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

func applyBreakglassSessionStatus(ctx context.Context, c client.Client, session *telekomv1alpha1.BreakglassSession) error <span class="cov8" title="1">{
        // Set observedGeneration for kstatus compliance
        // Note: This is also set in SessionManager.UpdateBreakglassSessionStatus for cases where
        // the session doesn't have Generation set
        if session.Generation &gt; 0 </span><span class="cov0" title="0">{
                session.Status.ObservedGeneration = session.Generation
        }</span>
        <span class="cov8" title="1">return ssa.ApplyBreakglassSessionStatus(ctx, c, session)</span>
}

func applyDebugSessionStatus(ctx context.Context, c client.Client, session *telekomv1alpha1.DebugSession) error <span class="cov0" title="0">{
        // Set observedGeneration for kstatus compliance
        if session.Generation &gt; 0 </span><span class="cov0" title="0">{
                session.Status.ObservedGeneration = session.Generation
        }</span>
        <span class="cov0" title="0">return ssa.ApplyDebugSessionStatus(ctx, c, session)</span>
}

func applyBreakglassEscalationStatus(ctx context.Context, c client.Client, escalation *telekomv1alpha1.BreakglassEscalation) error <span class="cov0" title="0">{
        // Set observedGeneration for kstatus compliance
        if escalation.Generation &gt; 0 </span><span class="cov0" title="0">{
                escalation.Status.ObservedGeneration = escalation.Generation
        }</span>
        <span class="cov0" title="0">return ssa.ApplyBreakglassEscalationStatus(ctx, c, escalation)</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">/*
Copyright 2026.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package breakglass

import (
        "bytes"
        "fmt"
        "regexp"
        "strings"
        "text/template"
        "unicode"

        "github.com/Masterminds/sprig/v3"
        "k8s.io/apimachinery/pkg/api/resource"
        "sigs.k8s.io/yaml"
)

// TemplateRenderer handles Go template rendering for auxiliary resources and pod templates.
// It provides Sprig functions plus custom Breakglass functions for Kubernetes resource templating.
type TemplateRenderer struct{}

// NewTemplateRenderer creates a new template renderer.
func NewTemplateRenderer() *TemplateRenderer <span class="cov0" title="0">{
        return &amp;TemplateRenderer{}
}</span>

// RenderTemplateString renders a Go template string with the given context.
// The context is converted to a map for template access.
func (r *TemplateRenderer) RenderTemplateString(templateStr string, ctx interface{}) ([]byte, error) <span class="cov0" title="0">{
        if templateStr == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("template string is empty")
        }</span>

        // Convert context to map for template
        <span class="cov0" title="0">ctxMap, err := toMap(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert context: %w", err)
        }</span>

        // Parse template with sprig and custom functions
        <span class="cov0" title="0">funcMap := r.buildFuncMap()
        tmpl, err := template.New("template").Funcs(funcMap).Parse(templateStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse template: %w", err)
        }</span>

        // Execute template
        <span class="cov0" title="0">var buf bytes.Buffer
        if err := tmpl.Execute(&amp;buf, ctxMap); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute template: %w", err)
        }</span>

        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

// RenderMultiDocumentTemplate renders a template that may contain multiple YAML documents
// separated by "---". Returns a slice of rendered documents.
func (r *TemplateRenderer) RenderMultiDocumentTemplate(templateStr string, ctx interface{}) ([][]byte, error) <span class="cov0" title="0">{
        rendered, err := r.RenderTemplateString(templateStr, ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Split by YAML document separator
        <span class="cov0" title="0">documents := splitYAMLDocuments(rendered)
        return documents, nil</span>
}

// ValidateTemplate checks if a template is syntactically valid and can be rendered.
// It attempts a dry-run render with sample context to catch errors early.
func (r *TemplateRenderer) ValidateTemplate(templateStr string, sampleCtx interface{}) error <span class="cov0" title="0">{
        if templateStr == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("template string is empty")
        }</span>

        // Convert context to map for template
        <span class="cov0" title="0">ctxMap, err := toMap(sampleCtx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to convert context: %w", err)
        }</span>

        // Parse template
        <span class="cov0" title="0">funcMap := r.buildFuncMap()
        tmpl, err := template.New("validation").Funcs(funcMap).Parse(templateStr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("template syntax error: %w", err)
        }</span>

        // Execute template with sample context
        <span class="cov0" title="0">var buf bytes.Buffer
        if err := tmpl.Execute(&amp;buf, ctxMap); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("template execution error: %w", err)
        }</span>

        // Validate that each document is valid YAML
        <span class="cov0" title="0">documents := splitYAMLDocuments(buf.Bytes())
        for i, doc := range documents </span><span class="cov0" title="0">{
                if len(bytes.TrimSpace(doc)) == 0 </span><span class="cov0" title="0">{
                        continue</span> // Skip empty documents
                }
                <span class="cov0" title="0">var obj map[string]interface{}
                if err := yaml.Unmarshal(doc, &amp;obj); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("document %d: invalid YAML: %w", i+1, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ValidateRenderedYAML validates that rendered YAML is valid and contains required fields.
func (r *TemplateRenderer) ValidateRenderedYAML(yamlBytes []byte) error <span class="cov0" title="0">{
        if len(bytes.TrimSpace(yamlBytes)) == 0 </span><span class="cov0" title="0">{
                return nil // Empty is valid (conditional rendering may produce empty output)
        }</span>

        <span class="cov0" title="0">var obj map[string]interface{}
        if err := yaml.Unmarshal(yamlBytes, &amp;obj); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid YAML: %w", err)
        }</span>

        // Check for apiVersion and kind for Kubernetes resources
        <span class="cov0" title="0">if _, hasAPIVersion := obj["apiVersion"]; !hasAPIVersion </span><span class="cov0" title="0">{
                return fmt.Errorf("missing required field: apiVersion")
        }</span>
        <span class="cov0" title="0">if _, hasKind := obj["kind"]; !hasKind </span><span class="cov0" title="0">{
                return fmt.Errorf("missing required field: kind")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// buildFuncMap creates the template function map with Sprig and custom functions.
func (r *TemplateRenderer) buildFuncMap() template.FuncMap <span class="cov0" title="0">{
        // Start with Sprig functions
        funcMap := sprig.FuncMap()

        // Add custom Breakglass functions
        funcMap["truncName"] = truncName
        funcMap["k8sName"] = k8sName
        funcMap["parseQuantity"] = parseQuantity
        funcMap["formatQuantity"] = formatQuantity
        funcMap["required"] = requiredFunc
        funcMap["indent"] = indentFunc
        funcMap["nindent"] = nindentFunc
        funcMap["yamlQuote"] = yamlQuote
        funcMap["yamlSafe"] = yamlSafe

        return funcMap
}</span>

// splitYAMLDocuments splits a YAML byte slice by document separators (---).
// Returns non-empty documents only.
func splitYAMLDocuments(data []byte) [][]byte <span class="cov0" title="0">{
        // Split by document separator
        separator := regexp.MustCompile(`(?m)^---\s*$`)
        parts := separator.Split(string(data), -1)

        var documents [][]byte
        for _, part := range parts </span><span class="cov0" title="0">{
                trimmed := strings.TrimSpace(part)
                if trimmed != "" </span><span class="cov0" title="0">{
                        documents = append(documents, []byte(trimmed))
                }</span>
        }

        <span class="cov0" title="0">return documents</span>
}

// Custom template functions

// truncName truncates a name to fit Kubernetes 63-character limit while keeping uniqueness.
// It appends a hash suffix if truncation is needed.
func truncName(maxLen int, name string) string <span class="cov0" title="0">{
        if maxLen &lt;= 0 </span><span class="cov0" title="0">{
                maxLen = 63
        }</span>
        <span class="cov0" title="0">if len(name) &lt;= maxLen </span><span class="cov0" title="0">{
                return name
        }</span>
        // Keep first maxLen chars
        <span class="cov0" title="0">return name[:maxLen]</span>
}

// k8sName sanitizes a string to be a valid Kubernetes name.
// Kubernetes names must be lowercase alphanumeric with hyphens, max 63 chars,
// starting and ending with alphanumeric.
func k8sName(s string) string <span class="cov0" title="0">{
        if s == "" </span><span class="cov0" title="0">{
                return "resource"
        }</span>

        // Convert to lowercase
        <span class="cov0" title="0">s = strings.ToLower(s)

        // Replace invalid characters with hyphens
        var result strings.Builder
        for _, r := range s </span><span class="cov0" title="0">{
                if unicode.IsLetter(r) || unicode.IsDigit(r) </span><span class="cov0" title="0">{
                        result.WriteRune(r)
                }</span> else<span class="cov0" title="0"> if r == '-' || r == '_' || r == ' ' || r == '.' </span><span class="cov0" title="0">{
                        result.WriteRune('-')
                }</span>
                // Skip other characters
        }

        <span class="cov0" title="0">name := result.String()

        // Remove leading/trailing hyphens
        name = strings.Trim(name, "-")

        // Collapse multiple hyphens
        for strings.Contains(name, "--") </span><span class="cov0" title="0">{
                name = strings.ReplaceAll(name, "--", "-")
        }</span>

        // Truncate to 63 characters
        <span class="cov0" title="0">if len(name) &gt; 63 </span><span class="cov0" title="0">{
                name = name[:63]
                name = strings.TrimRight(name, "-")
        }</span>

        <span class="cov0" title="0">if name == "" </span><span class="cov0" title="0">{
                return "resource"
        }</span>

        <span class="cov0" title="0">return name</span>
}

// parseQuantity parses a Kubernetes quantity string (e.g., "10Gi") to bytes.
func parseQuantity(s string) (int64, error) <span class="cov0" title="0">{
        if s == "" </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        <span class="cov0" title="0">q, err := resource.ParseQuantity(s)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return q.Value(), nil</span>
}

// formatQuantity formats bytes as a Kubernetes quantity string.
func formatQuantity(bytes int64) string <span class="cov0" title="0">{
        q := resource.NewQuantity(bytes, resource.BinarySI)
        return q.String()
}</span>

// requiredFunc returns an error if the value is empty.
func requiredFunc(msg string, val interface{}) (interface{}, error) <span class="cov0" title="0">{
        if val == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("required value is missing: %s", msg)
        }</span>
        <span class="cov0" title="0">if s, ok := val.(string); ok &amp;&amp; s == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("required value is empty: %s", msg)
        }</span>
        <span class="cov0" title="0">return val, nil</span>
}

// indentFunc indents a string by the specified number of spaces.
func indentFunc(spaces int, s string) string <span class="cov0" title="0">{
        pad := strings.Repeat(" ", spaces)
        lines := strings.Split(s, "\n")
        for i, line := range lines </span><span class="cov0" title="0">{
                if line != "" </span><span class="cov0" title="0">{
                        lines[i] = pad + line
                }</span>
        }
        <span class="cov0" title="0">return strings.Join(lines, "\n")</span>
}

// nindentFunc adds a newline before the indented string.
func nindentFunc(spaces int, s string) string <span class="cov0" title="0">{
        return "\n" + indentFunc(spaces, s)
}</span>

// yamlQuote safely quotes a string for YAML values.
// This ensures user-provided values cannot inject YAML syntax.
// Use this for ANY user-provided values in templates, especially .Vars.* values.
// Example: key: {{ .Vars.userValue | yamlQuote }}
func yamlQuote(s string) string <span class="cov0" title="0">{
        // Check if value needs quoting - if it contains any YAML special chars
        needsQuoting := strings.ContainsAny(s, ":#{}[]|&gt;!&amp;*?-'\"\\`@,\n\r\t ")
        needsQuoting = needsQuoting || len(s) == 0
        needsQuoting = needsQuoting || strings.HasPrefix(s, "---")
        needsQuoting = needsQuoting || strings.HasPrefix(s, "...")
        needsQuoting = needsQuoting || isYAMLSpecialWord(s)

        if !needsQuoting </span><span class="cov0" title="0">{
                return s
        }</span>

        // Use double quotes with proper escaping
        <span class="cov0" title="0">escaped := strings.ReplaceAll(s, "\\", "\\\\")
        escaped = strings.ReplaceAll(escaped, "\"", "\\\"")
        escaped = strings.ReplaceAll(escaped, "\n", "\\n")
        escaped = strings.ReplaceAll(escaped, "\r", "\\r")
        escaped = strings.ReplaceAll(escaped, "\t", "\\t")

        return "\"" + escaped + "\""</span>
}

// yamlSafe sanitizes a string to be safe as a YAML scalar value.
// Unlike yamlQuote, this removes potentially dangerous characters.
// Use for values that should NOT contain special characters.
func yamlSafe(s string) string <span class="cov0" title="0">{
        // Replace dangerous characters with safe alternatives
        result := strings.Map(func(r rune) rune </span><span class="cov0" title="0">{
                switch r </span>{
                case ':', '#', '{', '}', '[', ']', '|', '&gt;', '!', '&amp;', '*', '?', '\'', '"', '\\', '`', '@':<span class="cov0" title="0">
                        return '-'</span>
                case '\n', '\r', '\t':<span class="cov0" title="0">
                        return ' '</span>
                default:<span class="cov0" title="0">
                        return r</span>
                }
        }, s)

        // Collapse multiple spaces/hyphens
        <span class="cov0" title="0">for strings.Contains(result, "  ") </span><span class="cov0" title="0">{
                result = strings.ReplaceAll(result, "  ", " ")
        }</span>
        <span class="cov0" title="0">for strings.Contains(result, "--") </span><span class="cov0" title="0">{
                result = strings.ReplaceAll(result, "--", "-")
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(result)</span>
}

// isYAMLSpecialWord checks if a string is a YAML special keyword.
// These must be quoted to avoid YAML interpreting them as boolean, null, etc.
func isYAMLSpecialWord(s string) bool <span class="cov0" title="0">{
        lower := strings.ToLower(s)
        switch lower </span>{
        case "true", "false", "yes", "no", "on", "off", "null", "~":<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
